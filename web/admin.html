<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Survey Admin with Multi-Language Support</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Material Icons and Materialize CSS -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
    />

    <style>
      /* Base resets */
      body, html {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      main {
        margin-top: 0px;
      }
      .navbar-fixed {
        z-index: 1000;
      }
      body.no-scroll {
        overflow: hidden;
      }

      /**********************************************
       * NAV BAR
       **********************************************/		
		#nav-title {
		  font-size: 1.1rem; /* default size */
		  cursor: pointer;
      display: inline-block;
      max-width: 90%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
		}

    .truncated {
      display: inline-block;  /* Allows width to be applied */
      width: 50vw;             /* Sets a fixed width relative to the parent */
      white-space: nowrap;    /* Keeps the text on a single line */
      overflow: hidden;       /* Hides overflow text */
      text-overflow: ellipsis;/* Displays an ellipsis for overflow */
      margin-left:5px;
    }
     


      /**********************************************
       * MAIN CONTENT
       **********************************************/
      #main-content {
        margin-left: 500px; /* On desktop, push right for sidebar */
        transition: margin-left 0.3s ease;
        padding: 0 20px;
      }
      /* This class forcibly sets margin-left to 0 */
      #main-content.no-sidebar {
        margin-left: 0 !important;
        transition: margin-left 0.3s ease;
      }


      /**********************************************
       * SIDEBAR
       **********************************************/
	/* Force the sidebar to always show a scrollbar and display it on the left */
	#sidebar {
	  position: fixed;
	  top: 64px;
	  left: 0;
	  width: 500px;
	  height: calc(100% - 64px);
	  overflow-y: scroll;              /* Always show scrollbar */
	  -webkit-overflow-scrolling: touch;
	  transition: transform 0.3s ease;
	  z-index: 999;
	  background: white;
	  box-shadow: 0 0 12px 0px;
	  direction: rtl;                  /* Force scrollbar to the left */
	}

	/* Reset the direction for inner content so that text is left-to-right */
	#questions-list {
	  direction: ltr;
	}

      #sidebar.collapsed {
        transform: translateX(-110%);
      }
      #questions-list .collection-item {
        cursor: grab;
		touch-action: none;
      }
	  
      #questions-list .collection-item:active {
        cursor: grabbing;
      }
      #questions-list .collection-item:hover {
        background-color: #e0e0e0;
      }

      /* A small circle to display question (or group) index number */
      .list-index-circle {
        display: inline-block;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        line-height: 24px;
        text-align: center;
        background-color: #2196f3;
        color: #fff;
        margin-right: 8px;
        font-size: 14px;
      }

		/* Default (desktop): no gutter */
		#sidebar.with-gutter {
		  position: fixed;
		  top: 64px;
		  left: 0;
		  width: 500px;
		  height: calc(100% - 64px);
		  overflow-y: scroll;
		  -webkit-overflow-scrolling: touch;
		  background: white;
		  box-shadow: 0 0 12px 0px;
		}
		#sidebar.with-gutter .scroll-gutter {
		  display: none;
		}
		#sidebar.with-gutter #questions-list {
		  margin-left: 0;
		}

      /**********************************************
       * QUESTIONS & STICKY-BOTTOM BUTTONS
       **********************************************/
      .question-card {
        margin-bottom: 20px;
        position: relative;
      }
      .question-type-select {
        display: block;
        margin-top: 10px;
      }
      .question-actions {
        position: absolute;
        background: antiquewhite;
        border: 0px !important;
      }

      .sticky-bottom {
        position: sticky;
        bottom: 0;
        background-color: #fff;
        z-index: 998;
        padding: 10px 0;
        box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
      }

      .sticky-bottom .col.s12 > * {
        margin-bottom: 10px;
      }

      /* Floating action buttons in each question or group. */
      .question-actions, .group-actions {
        position: absolute;
        background: #fafafa;
        border: 0px !important;
        z-index: 100;
      }
      .question-actions button,
      .group-actions button {
        margin-right: 5px;
      }

	  .recording-btn {
		background-color: red !important;
	  }


.sticky-bottom .col.s12 {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* On small screens, hide the text in the Survey Data button, showing only the icon */
@media only screen and (max-width: 600px) {
  #fetch-data-btn span {
    display: none;
  }
}

/* Left group remains a flex container */
.left-buttons {
  display: flex;
  gap: 10px;
}

  /*********************************************
   * event trigger page
   *********************************************/
#triggersList {
  overflow-y: auto;
  transition: max-height 0.5s ease;
}
.hideTriggerList {
  max-height: 0px;
  overflow: hidden;
  transition: max-height 0.5s ease;
}

.height100 {
  height: 100%;
}

.sticky-footer {
  position: sticky;
  bottom: 0;
  background-color: #fff; /* or any background to match the modal */
  z-index: 1000;  /* ensure it stays on top */
  padding: 10px 0;
}



   /*********************************************
   * summary page
   *********************************************/

    /* Container for survey summaries */
    #surveyDataContent {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
      padding: 1rem;
      box-sizing: border-box;
    }
   .full-page-overlay {
      position: fixed;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: #fff;
      overflow-y: auto;
      z-index: 10000;
      transition: left 0.3s ease;
      box-shadow: 2px 0 5px rgba(0,0,0,0.3);
    }

    .full-page-overlay.active {
      left: 0;
    }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #9e9e9e;
      color: #fff;
      box-shadow: 0 0 6px 0px black;
      position: sticky;
      top: 0;
    }
    .page-header H5 {
      margin: 0.4em;
    
    }

    .close-btn {
      background: transparent;
      border: none;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      margin-right: 1em;
    }

    .page-content {
      padding: 1rem;
    }









    /**********************************************
      * RESPONSIVE
      **********************************************/
    @media only screen and (max-width: 1200) {
      #sidebar {
        transform: translateX(-110%);
      }
      #sidebar:not(.collapsed) {
        transform: translateX(0);
      }
      /* Hide text on some buttons to save space */
      #add-question-text,
      #add-group-text,
      #undo-text,
      #redo-text,
      #generate-text {
        display: none !important;
      }
      

      /* Ensure main-content not shrink */
      #main-content {
        width : 100%;
      }
    }
    
    @media only screen and (max-width: 600px) {
      #nav-title {
        font-size: 1rem; /* smaller font on small devices */
      }
    }
  
    @media only screen and (min-width: 1200px) {
      /* Increase the sidebar width for large screens */
      #sidebar {
      width: 500px; /* Adjust to your desired width */
      }
      /* Update main content margin to match the new sidebar width */
      #main-content {
      margin-left: 500px;
      }
    }


		@keyframes highlightFade {
		  0% { background-color: lightgrey; } /* blue highlight */
		  100% { background-color: transparent; }
		}

		.highlight-new {
		  animation: highlightFade 0.5s ease-out;
		}
		
		@keyframes slideIn {
		  0% { transform: translateX(150px); opacity: 0; }  /* Start off-screen */
		  100% { transform: translateX(0); opacity: 1; }  /* End at normal position */
		}

		.slide-in {
		  animation: slideIn 0.6s ease-out;
		}
		
		
/* Mobile devices: add a 40px gutter */
@media only screen and (max-width: 768px) {
  #sidebar.with-gutter {
    width: 340px; /* original 300px + 40px for gutter */
  }
  #sidebar.with-gutter .scroll-gutter {
    display: block;
    position: absolute;
    top: 0;
    bottom: 0;  /* Instead of height: 100%, use top: 0 and bottom: 0 */
    left: 0;
    width: 40px;

   /* Create a grip/dot pattern using radial gradients */
    background: radial-gradient(circle, #aaa 2px, transparent 2px),
                radial-gradient(circle, #aaa 2px, transparent 2px);
    background-size: 10px 10px;
    background-position: 0 0, 5px 5px;	
    z-index: 1;
  }
  #sidebar.with-gutter #questions-list {
    margin-left: 40px;
    position: relative;
    z-index: 2;
  }
  #main-content { 
    margin-left: 340px;
    width: 100%; 
  }
  margin-left: 500px; /* On desktop, push right for sidebar */
  .material-icons.left {
        margin-right: 0 !important;
      }   
}		
		
     /**********************************************
       * Utility
       **********************************************/

      /* Full-page overlay spinner */
      #loadingSpinner {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.8); /* semi-transparent overlay */
        z-index: 10000;  /* make sure it's above all other elements */
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: all;  /* ensures clicks are intercepted */
      }

      /* Optional: Style for the spinner wrapper if needed */
      .spinner-wrapper {
        text-align: center;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .spinner {
        font-size: 2em;
        animation: spin 1s linear infinite;
      }

      .loading-text {
        font-size: 2em;
        margin-left: 0.5em; /* Optional spacing */
      }
		
		        

    </style>
  </head>

  <body class="grey lighten-4">
  
  	<!-- Spinner element -->
	  <div class="loading-container" id="loadingSpinner" style="display:none;">
		<div class="spinner-wrapper">
			<span class="material-icons spinner">refresh</span>
			<!-- The spinner text will be updated via setLanguage -->
			<span class="loading-text">Processing, please wait ...</span>
		</div>
	  </div>

	<!-- Materialize Modal for Store Selection -->
   
	<div id="selectStore" class="modal">
	  <div class="modal-content">
		<h4><!-- Title will be updated via setLanguage --></h4>
		<div id="storeOptions">
		  <!-- Store options will be dynamically added here -->
		</div>
	  </div>
	  <div class="modal-footer">
		<a href="#!" class="modal-close btn-flat" onclick="confirmSelection()"><!-- Confirm text will be updated via setLanguage --></a>
		<a href="#!" class="modal-close btn-flat"><!-- Cancel text will be updated via setLanguage --></a>
	  </div>
	</div>
  
	<!-- FIXED NAV WRAPPER -->
    <div class="navbar-fixed">
      <nav class="blue">
		  <div class="nav-wrapper">
			<!-- Left side buttons -->
			<ul class="left">
			  <li>
				<a href="#!" onclick="toggleSidebar()" class="tooltipped" data-tooltip="Menu">
				  <i class="material-icons">menu</i>
				</a>
			  </li>
        <!--  This is the store selector. 
			  <li>
				<a id="storeButton" onclick="initSelectStore();">
			  </li>
        -->
			</ul>

			<!-- Center brand title (clickable for switching survey) -->
			<a id="nav-title" class="brand-logo center" onclick="handleSwitchSurvey()"> </a>

			<!-- Right side button -->
			<ul class="right">
			  <li>
				<a href="#!" onclick="openSettingsModal()" class="tooltipped" data-tooltip="Settings">
				  <i class="material-icons">settings</i>
				</a>
			  </li>
			</ul>
		  </div>
		</nav>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal" style="min-height:320px;">
      <div class="modal-content">
        <h5><!-- Settings title will be updated via setLanguage --></h5>
			
        <div>
          <label for="language-select"><!-- Language label will be updated via setLanguage --></label>
          <select id="language-select" onchange="setLanguage(this.value)">
            <option value="en-US">English</option>
            <option value="zh-TW">繁體中文</option>
            <option value="ja-JP">日本語</option>
          </select>
        </div>
		
		<div>
		  <label for="endpoint-url"><!-- Endpoint URL label will be updated via setLanguage --></label>
		  <input
			type="text"
			id="endpoint-url"
			placeholder="https://your-api-endpoint.com/survey"
		  />
		</div>

      <!-- DELETE ACCOUNT SECTION -->
      <hr>
      <h6 style="color:red;">Delete Account</h6>
      <label for="delete-email">Enter Email:</label>
      <input type="email" id="delete-email" placeholder="Your email" />
      <label for="delete-password">Enter Password:</label>
      <input type="password" id="delete-password" placeholder="Your password" />
      <button id="delete-account-btn" class="btn red">Delete Account</button>



      </div>
      <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center;">
		  <button class="modal-close btn red" onclick="logout();"><!-- Logout text will be updated via setLanguage --></button>
		  <button class="modal-close btn blue"><!-- Close text will be updated via setLanguage --></button>
		</div>
    </div>
	
	<!-- Survey Link Modal -->
	<div id="surveyLinkModal" class="modal">
	  <div class="modal-content">
		<h4><!-- Survey Link title will be updated via setLanguage --></h4>
		<p id="surveyLinkText" style="word-break: break-all;"></p>
		<div style="margin-top: 20px;">
		  <a class="btn" id="copyBtn">
			<i class="material-icons left">content_copy</i><!-- Copy text will be updated via setLanguage -->
		  </a>
		  <a class="btn blue" id="goBtn">
			<i class="material-icons left">send</i><!-- Go to Survey text will be updated via setLanguage -->
		  </a>
		</div>
	  </div>
	  
	  <div class="modal-footer">
		<a href="#!" class="modal-close btn-flat"><!-- Close text will be updated via setLanguage --></a>
	  </div>
	</div>
	
<!-- Select Survey Modal -->
<div id="selectSurveyModal" class="modal">
  <div class="modal-content">
    <h4><!-- Title will be updated via setLanguage --></h4>
    <ul id="surveyList" class="collection"></ul>
  </div>
  <div
    class="modal-footer"
    style="position:sticky; bottom:0; display: flex; justify-content: space-between; align-items: center; padding: 10px 20px;"
  >
    <!-- Import Survey Button on Left -->
    <div>
      <a href="#!" id="importSurveyBtn" class="btn-flat" onclick="openImportSurveyModal()">
        <i class="material-icons left">download</i><!-- Import Survey text will be updated via setLanguage -->
      </a>
    </div>
    <!-- Confirm Button on Right -->
    <div>
      <a href="#!" id="confirmSurveyBtn" class="btn"><!-- Confirm text will be updated via setLanguage --></a>
    </div>
  </div>
</div>

<!-- Import Survey Modal (Popup) -->
<div id="importSurveyModal" class="modal">
  <div class="modal-content">
    <h4><!-- Import Survey title will be updated via setLanguage --></h4>
    <div style="margin-bottom: 15px;">
      <!-- Radio Buttons to Choose Import Mode -->
      <label style="margin-right: 10px;">
        <input name="importMode" type="radio" value="file" checked onchange="updateImportModePopup()" />
        <span id="importModeFileLabel"><!-- Will be updated via setLanguage --></span>
      </label>
      <label style="margin-right: 10px;">
        <input name="importMode" type="radio" value="url" onchange="updateImportModePopup()" />
        <span id="importModeUrlLabel"><!-- Will be updated via setLanguage --></span>
      </label>
      <label>
        <input name="importMode" type="radio" value="text" onchange="updateImportModePopup()" />
        <span id="importModeTextLabel"><!-- Will be updated via setLanguage --></span>
      </label>
    </div>
    <!-- File Import Option -->
    <div id="popupImportFileContainer" style="margin-top: 15px;">
      <input type="file" id="popupImportSurveyFile" accept=".json" style="display: none;" onchange="handleImportSurveyFilePopup(event)" />
      <button class="btn" id="chooseFileBtn" onclick="document.getElementById('popupImportSurveyFile').click();">
        <i class="material-icons left">download</i><!-- Choose File text will be updated via setLanguage -->
      </button>
    </div>
    <!-- URL Import Option -->
    <div id="popupImportUrlContainer" style="display: none; margin-top: 15px;">
      <input type="text" id="popupImportSurveyUrl" placeholder="Enter URL to JSON" style="width: 100%; padding: 8px;" />
    </div>
	<!-- Text Import Option (Manual + Auto-Generate) -->
	<div id="popupImportTextContainer" style="display: none; margin-top: 15px;">
	  <textarea
		id="popupImportSurveyText"
		placeholder="Paste JSON here"
		style="width: 100%; height: 200px; padding: 8px;"
	  ></textarea>

	  <!-- Container for the description input and the two buttons -->
	  <div id="survey-gen-container" style="margin-top: 15px;">
		<!-- Label + Textarea for user description -->
		<label for="survey-description-input" style="display: block; margin-bottom: 5px;">
		  Describe the survey you want:
		</label>
		<textarea
		  id="survey-description-input"
		  placeholder="e.g. a customer satisfaction survey with star rating and multiple choice"
		  style="width: 100%; height: 100px; padding: 8px;"
		></textarea>

		<!-- Buttons row: Generate on the left, Voice on the right -->
		<div
		  style="
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-top: 10px;
		  "
		>
		  <!-- Generate button on the left -->
		  <button id="generate-survey-schema-btn" class="btn teal" disabled>
			<i class="material-icons left">autorenew</i>
			Generate Survey Schema
		  </button>
		  <!-- Voice button on the right -->
		  <button id="start-voice-btn" class="btn teal">
			<i class="material-icons">mic</i>
		  </button>
		</div>
	  </div>
	</div>


  </div>
  <div class="modal-footer" style="display: flex; justify-content: flex-end; align-items: center; padding: 10px 20px;">
    <a href="#!" class="modal-close btn-flat"><!-- Cancel text will be updated via setLanguage --></a>
    <a href="#!" id="finalImportBtn" class="btn" onclick="handleFinalImport()"><!-- Import text will be updated via setLanguage --></a>
  </div>
</div>



<!-- Survey Event Triggers Modal -->
<div id="eventTriggersModal" class="modal height100">
  <div class="modal-content">
    <h4>addNewTrigger</h4>
    <!-- Existing triggers list -->
    <div id="triggersList"></div>
    
    <!-- New Trigger Form Container (hidden by default) -->
    <div id="newTriggerForm" style="display: none; margin-top: 20px;  padding-top: 10px;">
      <!-- Trigger type selector -->
      <div class="row">
        <div class="input-field col s12">
          <select id="triggerType">
            <option value="" disabled selected>selectTriggerType</option>
            <option value="starThreshold">starThreshold</option>
            <option value="answerMatch">answerMatch</option>
            <option value="timeBased">timeBased</option>
          </select>
          <label>Trigger Type</label>
        </div>
      </div>
      <!-- Trigger configuration panels -->
      <div id="triggerConfig">
        <!--  load by loadTriggerConfig() -->
      </div>
      <!-- Save and Cancel buttons -->
      <div class="row" style="margin-top: 10px; display: flex; justify-content: flex-end; gap: 10px;">
        <button class="btn green" onclick="saveNewTrigger()">saveTriggerButton</button>
        <button class="btn grey" onclick="cancelNewTrigger()">cancel</button>
      </div>
    </div>
  </div>
  <!-- Fixed Add Trigger Button -->
  <div class="modal-footer  sticky-footer" style="justify-content: center;">
    <button class="btn blue" onclick="showNewTriggerForm()">
      <span id="add-new-trigger-text"></span>
    </button>    
  </div>
</div>



<!-- Full Page Survey Data Summary -->
<div id="surveyDataPage" class="full-page-overlay">
  <div class="page-header">
    <h5 id="surveyDataTitle">問卷資料摘要</h4>
    <button id="surveyDataCloseBtn" class="close-btn" onclick="closeSurveyDataPage()">Close</button>
  </div>
  <div id="surveyDataContent" class="page-content">
    <!-- Fetched survey distribution and summary will be injected here -->
  </div>
</div>


    <!-- SIDEBAR -->
 
	<div id="sidebar" class="with-gutter">
	  <div class="scroll-gutter"></div>
	  <ul id="questions-list" class="collection">
		<!-- Draggable items here -->
	  </ul>
	</div>
	

    <!-- MAIN CONTENT -->
    <main>
      <div id="main-content" class="no-sidebar">
        <div class="section">
			<div style="display: flex; align-items: center; justify-content: space-between;">
			<h5 id="page-subtitle" style="flex:4;"></h5>
			<!-- Add the survey title input on the right -->
			   <div style="display: flex; align-items: center; flex:6; justify-content: space-between;">
				<div style="display: flex; align-items: center;">
				  <label id="survey-title-label" for="survey-title-input" style="margin-right: 8px; font-size:1em; width:6em;">問卷標題:</label>
				  <input id="survey-title-input" type="text" placeholder="請輸入問卷標題" style="padding: 4px 8px;" />
				</div>
				<div style="display: flex; align-items: center;">
          <label id="channel-id-label" for="channel-select" style="margin-right: 8px; font-size:1em; width:6em;">頻道代碼:</label>
          <select id="channel-select" style="padding: 4px 8px;">
            <option value="">-- 選擇頻道 --</option>
          </select>
        </div>
			  </div>
		  </div>
          <!-- NEW: Banner Image URL input (the original upload image button has been removed) -->
          <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 10px;">
            <label id="survey-banner-label" for="survey-banner-input" style="margin-right: 8px; font-size:1em; width:6em;"><!-- Banner Image URL label will be updated via setLanguage --></label>
            <input id="survey-banner-input" type="text" placeholder="<!-- Banner Image placeholder will be updated via setLanguage -->" style="padding: 4px 8px;" />
          </div>

          <!-- Questions/Groups Container -->
          <div id="questions-and-groups"></div>

          <!-- Button Row (sticky at bottom) -->
          <div class="row sticky-bottom">
            <div class="col s12">
              <!-- Left side buttons -->
              <div class="left-buttons">
                <!-- Add Question -->
                <button
                  class="btn green waves-effect waves-light"
                  id="add-question-btn"
                  onclick="addQuestion()"
                >
                  <i class="material-icons left">add</i>
                  <span id="add-question-text"></span>
                </button>
          
                <!-- Add Group -->
                <button
                  class="btn orange waves-effect waves-light"
                  id="add-group-btn"
                  onclick="addGroup()"
                >
                  <i class="material-icons left">group_work</i>
                  <span id="add-group-text"></span>
                </button>
          
                <!-- Undo / Redo -->
                <button
                  id="undo-btn"
                  class="btn grey waves-effect waves-light"
                >
                  <i class="material-icons left">undo</i>
                  <span id="undo-text"></span>
                </button>
                <button
                  id="redo-btn"
                  class="btn grey waves-effect waves-light"
                >
                  <i class="material-icons left">redo</i>
                  <span id="redo-text"></span>
                </button>
          
                <!-- NEW: Fetch Data Button (shows only icon on small screens) -->
                <button class="btn grey waves-effect waves-light" id="fetch-data-btn" onclick="fetchSurveyData()">
                  <i class="material-icons left">assessment</i>
                  <span id="fetch-data-text">Survey Data</span>
                </button>
              </div>
          
              
              <button class="btn grey waves-effect waves-light" onclick="showEventTriggers()">
                <i class="material-icons left">notifications</i>
                <span id="event-trigger-text">Event Triggers</span>
              </button>

              <!-- Right side button: Generate & Go to Survey -->
              <div class="right-buttons">
                <button
                  class="btn blue waves-effect waves-light"
                  onclick="generateSurvey()"
                >
                  <i class="material-icons left">save</i>
                  <span id="generate-text"></span>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- Materialize JS -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"
      defer
    ></script>
	<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>		
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js"></script>

    <script>
    // Global variables
    // Global variable for the Ace Editor instance
    var triggerEditor;
 	  const BASE_URL = 'https://b200.tagfans.com:5301';	    
    //  const BASE_URL = 'http://127.0.0.1:5300';
	
    // On load, check if userToken exists. If not, redirect to login.html.
    // Helper function to get URL parameters
    function getQueryParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        userId: params.get("userId"),
        userToken: params.get("userToken")
      };
    }

    const urlParams = getQueryParams();

    // Global variables for the user credentials for this session
    let currentUserId, currentUserToken;

    if (urlParams.userId && urlParams.userToken) {
      // Use credentials from the URL parameters
      currentUserId = urlParams.userId;
      currentUserToken = urlParams.userToken;
    } else if (localStorage.getItem("userId") && localStorage.getItem("userToken")) {
      // Use credentials from localStorage if they exist
      currentUserId = localStorage.getItem("userId");
      currentUserToken = localStorage.getItem("userToken");
    } else {
      // No credentials available – redirect to login
      window.location.href = "login.html?redirect=admin.html";
    }


	
	
      /***********************************************
       * TRANSLATIONS
       ***********************************************/
      const i18n_local = {
        'en-US': {
          navTitle: "Survey Admin",
          subtitle: "Create or Edit Your Survey",
          addQuestion: "Add New Question",
          addGroup: "Add New Group",
          undo: "Undo",
          redo: "Redo",
          generate: "Generate & Go to Survey",
          questionTextLabel: "Question Text",
          questionTypeLabel: "Question Type",
          textInput: "Text Input",
          radioInput: "Multiple Choice (Single Select)",
          checkboxInput: "Multiple Choice (Multiple Select)",
          dateInput: "Date Picker",
          longtextInput: "Long Text Input",
          starsInput: "Star Rating",
          uploadImage: "Upload Image", // NEW key
          requiredLabel: "Required",
          compackLabel: "Compact",
          optionsLabel: "Options",
          addOption: "Add Option",
          removeOption: "Remove",
          questionPlaceholder: "Question #",
          deleteMsg: "Question deleted",
          deleteButton: "Delete",
          moveUp: "Move Up",
          moveDown: "Move Down",
          maxStarsLabel: "Max Stars",
          /* Groups */
          groupTitleLabel: "Group Title",
          anchorQuestionLabel: "Anchor Question (Show This Group When...)",
          anchorValuesLabel: "If anchor question answer is in:",
          groupPlaceholder: "Group #",
          deleteGroupMsg: "Group deleted",
          anchorNoQuestion: "No anchor set",
          pleaseSelectSurvey: "Please select a survey",
          surveyTitleLabel: "Survey Title:",
          processingText: "Processing, please wait ...",
          menuTooltip: "Menu",
          selectStoreTitle: "Select Store",
          confirm: "Confirm",
          cancel: "Cancel",
          settingsTitle: "Settings",
          languageLabel: "Language",
          endpointUrlLabel: "Endpoint URL",
          logout: "Logout",
          close: "Close",
          surveyLinkTitle: "Survey Link",
          copy: "Copy",
          goToSurvey: "Go to Survey",
          selectSurveyTitle: "Select Survey",
          importSurvey: "Import Survey",
          enterSurveyTitle: "Please enter survey title",
          copiedToClipboard: "Copied to clipboard",
          unsavedChangesPrompt: "You have unsaved changes. Do you want to save the current survey?",
          logoutConfirm: "Are you sure you want to logout?",
          importSurveySuccess: "Survey imported successfully",
          importSurveyFail: "Failed to parse the file",
          newSurvey: "New Survey",
          surveyIdLabel: "Survey ID:",
          createNewSurvey: "Create New Survey",
          surveyIdPrefix: "ID:",
          importSurveyTitle: "Import Survey",
          importModeFile: "File",
          importModeUrl: "URL",
          importModeText: "Text",
          chooseFile: "Choose File",
          enterUrlPlaceholder: "Enter URL to JSON",
          pasteJsonPlaceholder: "Paste JSON here",
          importText: "Import",
          invalidJsonFile: "Please select a valid JSON file",
          fileParseError: "Failed to parse JSON file",
          enterUrl: "Please enter a URL",
          importSurveyUrlFail: "Failed to import survey from URL",
          pasteJsonText: "Please paste JSON text",
          parseJsonTextError: "Failed to parse JSON text",
          importSurveyFailed: "Failed to import survey",
          endpointUrlPlaceholder: "https://your-api-endpoint.com/survey",
          noOptionsAvailable: "No options available",
          importReplaceConfirmation: "Importing a new survey will replace the current survey. Do you want to continue?",
          convertToGroup: "Convert to Group",
          unpackToStandalone: "Unpack to Standalone",
          bannerImageUrl: "Banner Image URL:",
          bannerImagePlaceholder: "Enter URL for banner image",
          extraText: "Extra Text",
          fetchDataText: "Survey Data",
          surveyDataSummaryTitle: "Survey Data Summary",
          textAnswerSummaryNote: "Text answers are not summarized statistically.",
          confirmDeleteSurvey: "Are you sure you want to delete this survey?",
          surveyDeletedSuccessfully: "Survey deleted successfully",
          failedToDeleteSurvey: "Failed to delete survey",
          triggerTypeLabel: "Type: ",
          deleteTriggerButton: "Delete",
          editTriggerButton: "Edit",
          saveTriggerButton: "Save",
          cancelTriggerButton: "Cancel",
          starThresholdLabel: "Threshold (stars)",
          starCountLabel: "Required Count",
          targetQuestionLabel: "Question",
          expectedAnswerLabel: "Expected Answer(s)",
          timeWindowLabel: "Time Window (hours)",
          minimumCountLabel: "Minimum Count",
          // For trigger script translations, we will use different versions below.
          // (These are handled separately in the trigger functions.)
          eventTriggersTitle: "Event Triggers",
          addNewTrigger: "Add New Trigger",
          saveTriggerButton: "Save Trigger",
          cancelTriggerButton: "Cancel Trigger",
          selectTriggerType: "Select Trigger Type",
          starThreshold: "Star Rating Threshold",
          answerMatch: "Specific Answer",
          timeBased: "Time-based Condition",
          selectQuestion: "Select a question",
        },
        "zh-TW": {
          navTitle: "問卷管理",
          subtitle: "創建或編輯您的問卷",
          addQuestion: "新增問題",
          addGroup: "新增群組",
          undo: "復原",
          redo: "重做",
          generate: "產生並前往問卷",
          questionTextLabel: "問題內容",
          questionTypeLabel: "問題類型",
          textInput: "文字輸入",
          radioInput: "單選題",
          checkboxInput: "多選題",
          dateInput: "日期選擇",
          longtextInput: "長文本輸入",
          starsInput: "星級評分",
          uploadImage: "上傳圖片",
          requiredLabel: "必填",
          compackLabel: "壓縮顯示",
          optionsLabel: "選項",
          addOption: "新增選項",
          removeOption: "刪除",
          questionPlaceholder: "問題 #",
          deleteMsg: "已刪除問題",
          deleteButton: "刪除",
          moveUp: "上移",
          moveDown: "下移",
          maxStarsLabel: "最大星數",
          /* Groups */
          groupTitleLabel: "群組標題",
          anchorQuestionLabel: "控制顯示問題 (當此問題的答案...)",
          anchorValuesLabel: "等於下列選項時顯示此群組:",
          groupPlaceholder: "群組 #",
          deleteGroupMsg: "已刪除群組",
          anchorNoQuestion: "未設定控制問題",
          pleaseSelectSurvey: "請選擇一個問卷",
          surveyTitleLabel: "問卷標題:",
          processingText: "處理中，請稍候 ...",
          menuTooltip: "選單",
          selectStoreTitle: "選擇商店",
          confirm: "確認",
          cancel: "取消",
          settingsTitle: "設定",
          languageLabel: "語言",
          endpointUrlLabel: "端點 URL",
          logout: "登出",
          close: "關閉",
          surveyLinkTitle: "問卷連結",
          copy: "複製",
          goToSurvey: "前往問卷",
          selectSurveyTitle: "選擇問卷",
          importSurvey: "匯入問卷",
          enterSurveyTitle: "請輸入問卷標題",
          copiedToClipboard: "已複製到剪貼簿",
          unsavedChangesPrompt: "您有未儲存的變更。是否要儲存當前問卷？",
          logoutConfirm: "您確定要登出嗎？",
          importSurveySuccess: "匯入問卷成功",
          importSurveyFail: "檔案解析失敗",
          newSurvey: "新問卷",
          surveyIdLabel: "問卷 ID:",
          createNewSurvey: "建立新問卷",
          surveyIdPrefix: "編號:",
          importSurveyTitle: "匯入問卷",
          importModeFile: "檔案",
          importModeUrl: "URL",
          importModeText: "文字",
          chooseFile: "選擇檔案",
          enterUrlPlaceholder: "輸入 JSON 的 URL",
          pasteJsonPlaceholder: "貼上 JSON 內容",
          importText: "匯入",
          invalidJsonFile: "請選擇有效的 JSON 檔案",
          fileParseError: "解析 JSON 檔案失敗",
          enterUrl: "請輸入 URL",
          importSurveyUrlFail: "從 URL 匯入問卷失敗",
          pasteJsonText: "請貼上 JSON 文字",
          parseJsonTextError: "解析 JSON 文字失敗",
          importSurveyFailed: "匯入問卷失敗",
          endpointUrlPlaceholder: "https://your-api-endpoint.com/survey",
          noOptionsAvailable: "無可用選項",
          importReplaceConfirmation: "匯入新的問卷將取代目前的問卷。您確定要繼續嗎？",
          convertToGroup: "轉換為群組",
          unpackToStandalone: "拆分為獨立問題",
          bannerImageUrl: "橫幅圖片網址:",
          bannerImagePlaceholder: "輸入橫幅圖片的網址",
          extraText: "補充文字",
          fetchDataText: "問卷分析",
          surveyDataSummaryTitle: "問卷資料摘要",
          textAnswerSummaryNote: "文字回答不進行統計摘要。",
          confirmDeleteSurvey: "您確定要刪除此問卷嗎？",
          surveyDeletedSuccessfully: "問卷刪除成功",
          failedToDeleteSurvey: "刪除問卷失敗",
          triggerTypeLabel: "類型: ",
          deleteTriggerButton: "刪除",
          editTriggerButton: "編輯",
          saveTriggerButton: "儲存",
          cancelTriggerButton: "取消",
          starThresholdLabel: "閾值 (星級)",
          starCountLabel: "所需數量",
          targetQuestionLabel: "問題",
          expectedAnswerLabel: "預期答案",
          timeWindowLabel: "時間範圍 (小時)",
          minimumCountLabel: "最小數量",
          eventTriggersTitle: "事件觸發",
          addNewTrigger: "新增觸發",
          saveTriggerButton: "儲存觸發",
          cancelTriggerButton: "取消觸發",
          selectTriggerType: "選擇觸發器類型",
          starThreshold: "星級評分閾值",
          answerMatch: "特定答案",
          timeBased: "基於時間的條件",
          selectQuestion: "選擇一個問題",
        },
        "ja-JP": {
          navTitle: "アンケート管理",
          subtitle: "アンケートを作成または編集",
          addQuestion: "新しい質問を追加",
          addGroup: "新しいグループを追加",
          undo: "元に戻す",
          redo: "やり直す",
          generate: "生成してアンケートへ進む",
          questionTextLabel: "質問文",
          questionTypeLabel: "質問タイプ",
          textInput: "テキスト入力",
          radioInput: "単一選択式 (ラジオボタン)",
          checkboxInput: "複数選択式 (チェックボックス)",
          dateInput: "日付入力",
          longtextInput: "長文入力",
          starsInput: "星の評価",
          uploadImage: "画像アップロード",
          requiredLabel: "必須",
          compackLabel: "コンパクト表示",
          optionsLabel: "オプション",
          addOption: "オプションを追加",
          removeOption: "削除",
          questionPlaceholder: "質問 #",
          deleteMsg: "質問を削除しました",
          deleteButton: "削除",
          moveUp: "上へ移動",
          moveDown: "下へ移動",
          maxStarsLabel: "最大星数",
          /* Groups */
          groupTitleLabel: "グループタイトル",
          anchorQuestionLabel: "アンカー質問 (この回答によって表示...)",
          anchorValuesLabel: "アンカー質問の回答が以下の場合、表示:",
          groupPlaceholder: "グループ #",
          deleteGroupMsg: "グループを削除しました",
          anchorNoQuestion: "アンカー質問未設定",
          pleaseSelectSurvey: "アンケートを選択してください",
          surveyTitleLabel: "アンケートタイトル:",
          processingText: "処理中、しばらくお待ちください ...",
          menuTooltip: "メニュー",
          selectStoreTitle: "店舗を選択",
          confirm: "確認",
          cancel: "キャンセル",
          settingsTitle: "設定",
          languageLabel: "言語",
          endpointUrlLabel: "エンドポイント URL",
          logout: "ログアウト",
          close: "閉じる",
          surveyLinkTitle: "アンケートリンク",
          copy: "コピー",
          goToSurvey: "アンケートへ移動",
          selectSurveyTitle: "アンケートを選択",
          importSurvey: "アンケートをインポート",
          enterSurveyTitle: "アンケートタイトルを入力してください",
          copiedToClipboard: "クリップボードにコピーしました",
          unsavedChangesPrompt: "保存されていない変更があります。現在のアンケートを保存しますか？",
          logoutConfirm: "本当にログアウトしますか？",
          importSurveySuccess: "アンケートのインポートに成功しました",
          importSurveyFail: "JSONファイルの解析に失敗しました",
          newSurvey: "新規アンケート",
          surveyIdLabel: "アンケートID:",
          createNewSurvey: "新規アンケート作成",
          surveyIdPrefix: "番号:",
          importSurveyTitle: "アンケートをインポート",
          importModeFile: "ファイル",
          importModeUrl: "URL",
          importModeText: "テキスト",
          chooseFile: "ファイルを選択",
          enterUrlPlaceholder: "JSON の URL を入力",
          pasteJsonPlaceholder: "JSON を貼り付け",
          importText: "インポート",
          invalidJsonFile: "有効なJSONファイルを選択してください",
          fileParseError: "JSONファイルの解析に失敗しました",
          enterUrl: "URLを入力してください",
          importSurveyUrlFail: "URLからのアンケートインポートに失敗しました",
          pasteJsonText: "JSONテキストを貼り付けてください",
          parseJsonTextError: "JSONテキストの解析に失敗しました",
          importSurveyFailed: "アンケートのインポートに失敗しました",
          endpointUrlPlaceholder: "https://your-api-endpoint.com/survey",
          noOptionsAvailable: "利用可能なオプションはありません",
          importReplaceConfirmation: "新しいアンケートをインポートすると、現在のアンケートが置き換えられます。続行しますか？",
          convertToGroup: "グループに変換",
          unpackToStandalone: "独立に戻す",
          bannerImageUrl: "バナー画像のURL:",
          bannerImagePlaceholder: "バナー画像のURLを入力",
          extraText: "追加テキスト",
          fetchDataText: "アンケートデータ",
          surveyDataSummaryTitle: "アンケートデータサマリー",
          textAnswerSummaryNote: "テキスト回答は統計的に集計しません。",
          confirmDeleteSurvey: "このアンケートを削除してもよろしいですか？",
          surveyDeletedSuccessfully: "アンケートが正常に削除されました",
          failedToDeleteSurvey: "アンケートの削除に失敗しました",
          triggerTypeLabel: "種類: ",
          deleteTriggerButton: "削除",
          editTriggerButton: "編集",
          saveTriggerButton: "保存",
          cancelTriggerButton: "キャンセル",
          starThresholdLabel: "閾値 (星)",
          starCountLabel: "必要な数",
          targetQuestionLabel: "質問",
          expectedAnswerLabel: "予想される回答",
          timeWindowLabel: "時間枠 (時間)",
          minimumCountLabel: "最小数",
          eventTriggersTitle: "イベントトリガー",
          addNewTrigger: "新規トリガー追加",
          saveTriggerButton: "トリガー保存",
          cancelTriggerButton: "キャンセル",
          selectTriggerType: "トリガータイプを選択",
          starThreshold: "星評価の閾値",
          answerMatch: "特定の回答",
          timeBased: "時間に基づく条件",
          selectQuestion: "質問を選択",
        }
      };
      let currentLang = "en-US";

/***********************************************
 * GLOBAL DATA
 ***********************************************/
/*
  We'll store both questions and groups in the same array, each item has:
  {
    type: "question" | "group",
    id: number,
    ...
  }

  If type === "question", it has your existing question fields:
    questionText, questionType, options, required, compack, etc.

  If type === "group", it has:
    groupTitle,
    anchorQuestionId,      // which question controls the group
    anchorValuesToShow: [],// which answers trigger "show"
    subQuestions: [ {...}, {...} ] // array of normal question objects
  ...
*/    
      let surveyItems = [];
      let undoStack = [];
      let redoStack = [];
      let CurrentSurveySchemaId;
	  
      // For mobile click-outside to close the sidebar
      let mobileClickOutsideHandler = null;
	  
	  
	  window.onload = function() {
	  	
		console.log("window loaded");
	  	
	  }

      /***********************************************
       * INITIALIZATION
       ***********************************************/
      document.addEventListener("DOMContentLoaded", async function () {
          // Load existing data from localStorage
          // const existingData = localStorage.getItem("surveyQuestions");

          

          surveys = await fetchSurvey(null);


          // here we should select a survey to continue, or new one
          let existingData = null;
          if (!surveys || surveys.length === 0) {
            // No surveys exist—prompt the user to import one.
            openImportSurveyModal();
          }
          else if (surveys && surveys.length > 0) {
              if (surveys.length === 1) {
                  CurrentSurveySchemaId = surveys[0]._id;
                  
              } else {
                  // If more than one survey exists, force the user to select one.
                  let selection;
                  selection = localStorage.CurrentSurveySchemaId || await showSelectSurveyModal(surveys);
                  if (selection == 'create new')
                      selection = undefined;
                  CurrentSurveySchemaId = selection;
                 

              }
          }
          updateNavTitle();

          await fetchChannelList();


          if (CurrentSurveySchemaId === "create_new") {
              CurrentSurveySchemaId = undefined;
          } else if (CurrentSurveySchemaId) {
              let tmp = await fetchSurvey(CurrentSurveySchemaId);
              existingData = tmp;
          } else {}

          if (existingData) {
              // For backward-compatibility, older code might store only questions.
              // We'll interpret them as "type=question" items if not present:
              const parsed = (typeof existingData == "string") ? JSON.parse(existingData) : existingData;
              let items = parsed.surveyItems;
              surveyItems = items.map((item) => {
                  if (!item.type) {
                      return {
                          type: "question",
                          ...item
                      };
                  }
                  return item;
              });
              // *** Set the survey title input if one exists ***
              if (parsed.surveyTitle) {
                  document.getElementById("survey-title-input").value = parsed.surveyTitle;
              }
              // *** Set the banner image URL if exists ***
              if (parsed.bannerImage) {
                  document.getElementById("survey-banner-input").value = parsed.bannerImage;
              }
			  
              if (parsed._channelId) {
                // Save the channel ID in a global variable (if needed later)
                window.preSelectedChannel = parsed._channelId;
                // Set the dropdown's value and refresh the Materialize UI
                const channelSelect = document.getElementById("channel-select");
                if (channelSelect) {
                  channelSelect.value = parsed._channelId;
                  M.FormSelect.init(channelSelect);
                }
              }
			  
          } else {
              surveyItems = [];
          }

          // Set default language from localStorage or fallback
          const storedLang = localStorage.getItem("preferredLanguage");
          if (storedLang) {
              currentLang = storedLang;
          } else {
              currentLang = "zh-TW"; // or "en-US"
          }

          // Update the <select> UI
          const languageSelect = document.getElementById("language-select");
          if (languageSelect) {
              languageSelect.value = currentLang;
          }

          // Apply language
          setLanguage(currentLang);
          setupUndoRedoButtons();
          renderAllItems();


		  // openai call to llm user request
			document.getElementById("generate-survey-schema-btn").onclick = async () => {
			  const descriptionInput = document.getElementById("survey-description-input");
			  const description = descriptionInput.value.trim();
			  
			  // If description is empty, show toast and exit
			  if (!description) {
				M.toast({
				  html: "Please enter a survey description",
				  displayLength: 2000
				});
				return;
			  }
			  
			  // Disable the button and show the spinner
			  const genBtn = document.getElementById("generate-survey-schema-btn");
			  genBtn.disabled = true;
			  document.getElementById("loadingSpinner").style.display = "flex";
			  
			  try {
				const response = await fetch(`${BASE_URL}/api/generateSurveySchema`, {
				  method: 'POST',
          headers: { "Content-Type": "application/json" , Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
				  body: JSON.stringify({ description })
				});
				const data = await response.json();
				if (data.schema) {
				  const schemaString = typeof data.schema === 'object' ? JSON.stringify(data.schema, null, 2) : data.schema;
          const textArea = document.getElementById("popupImportSurveyText");
				  textArea.value = schemaString;
          textArea.dispatchEvent(new Event("input", { bubbles: true, cancelable: true }));

				  M.toast({
					html: "Survey schema generated successfully",
					displayLength: 2000
				  });
				} else {
				  M.toast({
					html: "Failed to generate survey schema",
					displayLength: 2000
				  });
				}
			  } catch (error) {
				console.error(error);
				M.toast({
				  html: "Error generating survey schema",
				  displayLength: 2000
				});
			  } finally {
				// Re-enable the button and hide the spinner regardless of outcome
				// genBtn.disabled = false;
				document.getElementById("loadingSpinner").style.display = "none";
			  }
			};
			// enable/disable the description text area
			document.getElementById("survey-description-input").addEventListener("input", function() {
			  const generateBtn = document.getElementById("generate-survey-schema-btn");
			  // Disable the button if the text area is empty (ignoring whitespace)
			  generateBtn.disabled = this.value.trim() === "";
			});
			
      /***********************************
       * import modal listener
       * *********************************/
      document.querySelectorAll('input[name="importMode"]').forEach(radio => {
        radio.addEventListener("change", function() {
          localStorage.setItem("importMode", this.value);
          updateImportModePopup(); // make sure the UI updates accordingly
        });
      });
      const jsonTextArea = document.getElementById("popupImportSurveyText");
      const finalImportBtn = document.getElementById("finalImportBtn");

      // Initially disable if text area is empty:
        if (jsonTextArea.value.trim() === "") {
          finalImportBtn.classList.add("disabled");
        } else {
          finalImportBtn.classList.remove("disabled");
        }

        // Update button state on input change:
        jsonTextArea.addEventListener("input", function () {
          if (this.value.trim() === "") {
            finalImportBtn.classList.add("disabled");
          } else {
            finalImportBtn.classList.remove("disabled");
          }
        });


          // Handle responsive sidebar on load & resize
          const sidebar = document.getElementById("sidebar");
          const mainContent = document.getElementById("main-content");
          function checkScreenSize() {
              if (window.innerWidth < 992) {
                  // On mobile, hide (collapse) sidebar
                  sidebar.classList.add("collapsed");
                  mainContent.classList.add("no-sidebar");
                  enableMobileClickOutsideToCloseSidebar();
              } else {
                  // On desktop, show sidebar
                  sidebar.classList.remove("collapsed");
                  mainContent.classList.remove("no-sidebar");
                  disableMobileClickOutsideToCloseSidebar();
              }
          }




          document.getElementById("delete-account-btn").addEventListener("click", async function() {
              const email = document.getElementById("delete-email").value.trim();
              const password = document.getElementById("delete-password").value;
              if (!email || !password) {
                  M.toast({ html: "Email and password are required", displayLength: 2000 });
                  return;
              }
              try {
                  // Verify credentials via the login API
                  const loginResponse = await fetch(`${BASE_URL}/api/login`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ email, password })
                  });
                  const loginData = await loginResponse.json();
                  if (!loginResponse.ok) {
                        M.toast({ html: loginData.error || "Invalid credentials", displayLength: 2000 });
                        return;
                  }
                  // Ensure the loginData user matches the currently logged-in user.
                  if (loginData.userId !== localStorage.getItem("userId")) {
                        M.toast({ html: "Provided credentials do not match the current account", displayLength: 2000 });
                        return;
                  }                  
                  // If verified, prompt user to type "cancel" for confirmation
                  const confirmation = prompt("Type 'cancel' to confirm account deletion:");
                  if (confirmation !== "cancel") {
                        M.toast({ html: "Account deletion cancelled", displayLength: 2000 });
                        return;
                  }
                  // Call the delete user API
                  const deleteResponse = await fetch(`${BASE_URL}/api/user/${currentUserId}`, {
                        method: "DELETE",
                        headers: {Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
                  });
                  const deleteData = await deleteResponse.json();
                  if (deleteResponse.ok) {
                        M.toast({ html: "User account deleted successfully", displayLength: 2000 });
                        // Clear local storage and redirect to login page
                        localStorage.removeItem("userId");
                        localStorage.removeItem("userToken");
                        window.location.href = "login.html";
                  } else {
                        M.toast({ html: deleteData.error || "Failed to delete account", displayLength: 2000 });
                  }
              } catch (err) {
                  console.error(err);
                  M.toast({ html: "Error deleting account", displayLength: 2000 });
              }
          });


          const modalElem = document.getElementById('eventTriggersModal');
          M.Modal.init(modalElem, {
            onOpenStart: () => {
              // When modal opens, initialize the select elements
              M.FormSelect.init(document.querySelectorAll('select'));
              loadTriggerConfig();
            },
            onOpenEnd: () => {
              // Initialize select elements as before
              M.FormSelect.init(document.querySelectorAll('select'));
              loadTriggerConfig();
              
            }            
          });









          
          window.addEventListener("resize", checkScreenSize);
          checkScreenSize();
      });
      /***********************************************
       * MOBILE CLICK-OUTSIDE-TO-CLOSE SIDEBAR
       ***********************************************/
      function enableMobileClickOutsideToCloseSidebar() {
        // Only attach once
        if (!mobileClickOutsideHandler) {
          mobileClickOutsideHandler = function (e) {
            const sidebar = document.getElementById("sidebar");
            const toggleElements = document.querySelectorAll('[onclick="toggleSidebar()"]');
            // If it's not collapsed already and user clicks outside it => close
            if (!sidebar.classList.contains("collapsed")) {
              if (!sidebar.contains(e.target) && !toggleElements[0].contains(e.target)) {
                toggleSidebar();
              }
            }
          };
          document.addEventListener("click", mobileClickOutsideHandler);
        }
      }

      function disableMobileClickOutsideToCloseSidebar() {
        if (mobileClickOutsideHandler) {
          document.removeEventListener("click", mobileClickOutsideHandler);
          mobileClickOutsideHandler = null;
        }
      }

      /***********************************************
       * SIDEBAR TOGGLE
       ***********************************************/
      function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const mainContent = document.getElementById("main-content");
        sidebar.classList.toggle("collapsed");
        if (sidebar.classList.contains("collapsed")) {
          mainContent.classList.add("no-sidebar");
        } else {
          mainContent.classList.remove("no-sidebar");
        }
      }

      /***********************************************
       * LANGUAGE SELECTION
       ***********************************************/
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize Materialize modal
        const modalElems = document.querySelectorAll(".modal");
        M.Modal.init(modalElems, {
            onCloseEnd: function () {
                // Save the current settings when the modal closes
                const selectedLang = document.getElementById("language-select").value;
                const endpointUrl = document.getElementById("endpoint-url").value;
				
                localStorage.setItem("preferredLanguage", selectedLang);
                localStorage.setItem("surveyEndpoint", endpointUrl);
				
            },
        });

		// Get the language select element (make sure it's declared here)
		const langSelect = document.getElementById("language-select");		
		 // Detect iOS device
		  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
		  if (!isIOS) {
			// Only initialize Materialize's custom select on non-iOS devices.
			var elems = document.querySelectorAll("select");
			M.FormSelect.init(elems);
		  }
		  else {
			// For iOS, force the native select control to show by adding browser-default
			if (langSelect) {
			  langSelect.classList.add("browser-default");
			}
		  }

        // Load stored settings for language and endpoint URL
        let storedLang = localStorage.getItem("preferredLanguage") || "zh-TW";
		if (!i18n_local[storedLang]){
			storedLang = "zh-TW";
		}
		
        
        document.getElementById("language-select").value = storedLang;
        setLanguage(storedLang);

        const storedEndpoint = localStorage.getItem("surveyEndpoint") || "";
        document.getElementById("endpoint-url").value = storedEndpoint;
		
		
      });      
	  function openSettingsModal() {
        const modal = M.Modal.getInstance(
          document.getElementById("settings-modal")
        );
        modal.open();
      }

      function setLanguage(lang) {
        localStorage.setItem("preferredLanguage", lang);
        currentLang = lang;

        // Update dropdown value
        const languageSelect = document.getElementById("language-select");
        if (languageSelect) {
          languageSelect.value = lang;
        }
        // Update UI text using i18n_local values...
        document.getElementById("nav-title").textContent = i18n_local[currentLang].navTitle;
        document.getElementById("page-subtitle").textContent = i18n_local[currentLang].subtitle;
        document.getElementById("survey-title-label").textContent = i18n_local[lang].surveyTitleLabel;
        document.getElementById("add-question-text").textContent = i18n_local[currentLang].addQuestion;
        document.getElementById("add-group-text").textContent = i18n_local[currentLang].addGroup;
        document.getElementById("undo-text").textContent = i18n_local[currentLang].undo;
        document.getElementById("redo-text").textContent = i18n_local[currentLang].redo;
        document.getElementById("generate-text").textContent = i18n_local[currentLang].generate;
        document.getElementById("event-trigger-text").textContent = i18n_local[currentLang].eventTriggersTitle;
        document.getElementById("add-new-trigger-text").textContent = i18n_local[currentLang].addNewTrigger;
        document.getElementById("survey-title-label").textContent = i18n_local[currentLang].surveyTitleLabel;
        const bannerLabel = document.getElementById("survey-banner-label");
        if(bannerLabel) { bannerLabel.textContent = i18n_local[currentLang].bannerImageUrl; }
        const bannerInput = document.getElementById("survey-banner-input");
        if(bannerInput) { bannerInput.setAttribute("placeholder", i18n_local[currentLang].bannerImagePlaceholder); }
        document.getElementById("fetch-data-text").textContent = i18n_local[currentLang].fetchDataText;
        document.getElementById("add-question-text").textContent = i18n_local[lang].addQuestion;

  // Update spinner text
  const loadingTextEl = document.querySelector('.loading-text');
  if(loadingTextEl) { loadingTextEl.textContent = i18n_local[lang].processingText; }
  
  // Update tooltip for Menu button
  const menuBtn = document.querySelector('[onclick="toggleSidebar()"]');
  if(menuBtn) { menuBtn.setAttribute("data-tooltip", i18n_local[lang].menuTooltip); }
  
  // Update store button text if not already set by store selection
  const storeBtn = document.getElementById("storeButton");
  if(storeBtn && (!storeBtn.textContent || storeBtn.textContent.trim() === "選擇商店")) {
    storeBtn.textContent = i18n_local[lang].selectStoreTitle;
  }
  
  // Update Settings modal texts
  const settingsTitleEl = document.querySelector("#settings-modal h5");
  if(settingsTitleEl) { settingsTitleEl.textContent = i18n_local[lang].settingsTitle; }
  const langLabel = document.querySelector("#settings-modal label[for='language-select']");
  if(langLabel) { langLabel.textContent = i18n_local[lang].languageLabel; }
  const endpointLabel = document.querySelector("#settings-modal label[for='endpoint-url']");
  if(endpointLabel) { endpointLabel.textContent = i18n_local[lang].endpointUrlLabel; }
  const settingsFooterButtons = document.querySelectorAll("#settings-modal .modal-footer button");
  if(settingsFooterButtons.length >= 2) {
    settingsFooterButtons[0].textContent = i18n_local[lang].logout;
    settingsFooterButtons[1].textContent = i18n_local[lang].close;
  }
  
  // Update Survey Link modal texts
  const surveyLinkTitleEl = document.querySelector("#surveyLinkModal h4");
  if(surveyLinkTitleEl) { surveyLinkTitleEl.textContent = i18n_local[lang].surveyLinkTitle; }
  const copyBtn = document.getElementById("copyBtn");
  if(copyBtn) { 
    copyBtn.innerHTML = '<i class="material-icons left">content_copy</i>' + i18n_local[lang].copy; 
  }
  const goBtn = document.getElementById("goBtn");
  if(goBtn) { 
    goBtn.innerHTML = '<i class="material-icons left">send</i>' + i18n_local[lang].goToSurvey; 
  }
  const surveyLinkClose = document.querySelector("#surveyLinkModal .modal-footer a");
  if(surveyLinkClose) { surveyLinkClose.textContent = i18n_local[lang].close; }
  
  // Update Select Survey modal texts
  const selectSurveyTitleEl = document.querySelector("#selectSurveyModal h4");
  if(selectSurveyTitleEl) { selectSurveyTitleEl.textContent = i18n_local[lang].selectSurveyTitle; }
  // Update Import Survey button text in Select Survey modal footer
  const importSurveyBtn = document.getElementById("importSurveyBtn");
	if (importSurveyBtn) {
	  importSurveyBtn.innerHTML = '<i class="material-icons left">download</i>' + i18n_local[lang].importSurvey;
	}
  const confirmSurveyBtn = document.getElementById("confirmSurveyBtn");
  if(confirmSurveyBtn) { confirmSurveyBtn.textContent = i18n_local[lang].confirm; }
  
  // Update text for select store modal buttons
	const selectStoreModal = document.getElementById("selectStore");
	if (selectStoreModal) {
	  const storeConfirm = selectStoreModal.querySelector(".modal-footer a:nth-child(1)");
	  const storeCancel = selectStoreModal.querySelector(".modal-footer a:nth-child(2)");
	  if (storeConfirm) storeConfirm.textContent = i18n_local[currentLang].confirm;
	  if (storeCancel) storeCancel.textContent = i18n_local[currentLang].cancel;
	}

  // Update endpoint URL placeholder in settings modal
  const endpointInput = document.getElementById("endpoint-url");
  if(endpointInput) { endpointInput.setAttribute("placeholder", i18n_local[lang].endpointUrlPlaceholder); }
  
  // Update Import Survey modal texts
  const importSurveyTitleEl = document.querySelector("#importSurveyModal h4");
  if(importSurveyTitleEl) { importSurveyTitleEl.textContent = i18n_local[lang].importSurveyTitle; }
  
  // Update radio button labels in Import Survey modal
  const importModeFileLabel = document.getElementById("importModeFileLabel");
  if(importModeFileLabel) { importModeFileLabel.textContent = i18n_local[lang].importModeFile; }
  const importModeUrlLabel = document.getElementById("importModeUrlLabel");
  if(importModeUrlLabel) { importModeUrlLabel.textContent = i18n_local[lang].importModeUrl; }
  const importModeTextLabel = document.getElementById("importModeTextLabel");
  if(importModeTextLabel) { importModeTextLabel.textContent = i18n_local[lang].importModeText; }
  
  // Update Choose File button text
  const chooseFileBtn = document.getElementById("chooseFileBtn");
  if(chooseFileBtn) {
    chooseFileBtn.innerHTML = '<i class="material-icons left">download</i>' + i18n_local[lang].chooseFile;
  }
  
  // Update placeholder for URL import option
  const importUrlInput = document.getElementById("popupImportSurveyUrl");
  if(importUrlInput) {
    importUrlInput.setAttribute("placeholder", i18n_local[lang].enterUrlPlaceholder);
  }
  
  // Update placeholder for Text import option
  const importTextArea = document.getElementById("popupImportSurveyText");
  if(importTextArea) {
    importTextArea.setAttribute("placeholder", i18n_local[lang].pasteJsonPlaceholder);
  }
  
  // Update Import Survey modal footer buttons text
  const importModalFooterButtons = document.querySelectorAll("#importSurveyModal .modal-footer a");
  if(importModalFooterButtons.length >= 2) {
    importModalFooterButtons[0].textContent = i18n_local[lang].cancel;
    importModalFooterButtons[1].textContent = i18n_local[lang].importText;
  }

  document.getElementById("fetch-data-text").textContent = i18n_local[lang].fetchDataText;
  document.getElementById("surveyDataCloseBtn").textContent = i18n_local[lang].close;
  document.getElementById("surveyDataTitle").textContent = i18n_local[lang].surveyDataSummaryTitle;  
 
  translateButtons(lang);
  translateOptions(lang);
  translateHeaders(lang)
  

        // Re-render items if necessary
        renderAllItems();
      }


      function translateButtons(lang) {
        const currentTranslations = i18n_local[lang];
        document.querySelectorAll("button").forEach((btn) => {
          const key = btn.textContent.trim();
          if (currentTranslations.hasOwnProperty(key)) {
            btn.textContent = currentTranslations[key];
          }
        });
      }
      function translateHeaders(lang) {
        const currentTranslations = i18n_local[lang];
        document.querySelectorAll("H4").forEach((header) => {
          const key = header.textContent.trim();
          if (currentTranslations.hasOwnProperty(key)) {
            header.textContent = currentTranslations[key];
          }
        });
      }
      function translateOptions(lang) {
        const currentTranslations = i18n_local[lang];
        document.querySelectorAll("option").forEach((option) => {
          const key = option.textContent.trim();
          if (currentTranslations.hasOwnProperty(key)) {
            option.textContent = currentTranslations[key];
          }
        });
      }

      /***********************************************
       * NEW: DRAG & DROP HANDLERS FOR SIDEBAR ITEMS
       ***********************************************/
      // For top-level items (questions and group headers)
      function handleTopDragStart(e) {
        e.dataTransfer.setData("text/plain", JSON.stringify({ type: "top", index: parseInt(e.target.dataset.index, 10) }));
      }
      function handleTopDragOver(e) {
        e.preventDefault();
      }
// Top-level drop handler: always reorders top-level items.
function handleTopDrop(e) {
  e.preventDefault();
  const targetLI = e.target.closest("li");
  if (!targetLI || !targetLI.dataset.index) return;
  const targetIndex = parseInt(targetLI.dataset.index, 10);
  const draggedData = JSON.parse(e.dataTransfer.getData("text/plain"));
  if (draggedData.type !== "top") return;
  const draggedIndex = draggedData.index;
  if (draggedIndex === targetIndex) return;
  // Reorder the main surveyItems array.
  const draggedItem = surveyItems.splice(draggedIndex, 1)[0];
  surveyItems.splice(targetIndex, 0, draggedItem);
  renderAllItems();
}


// Sub-question drop handler: handles reordering of sub–questions
// and allows a standalone question (dragged as "top") to be dropped into a group.
function handleSubDrop(e) {
  e.preventDefault();
  const targetLI = e.target.closest("li");
  if (!targetLI || targetLI.dataset.type !== "sub") return;
  const targetGroupIndex = parseInt(targetLI.dataset.groupIndex, 10);
  const targetSubIndex = parseInt(targetLI.dataset.subIndex, 10);
  const draggedData = JSON.parse(e.dataTransfer.getData("text/plain"));
      
  if (draggedData.type === "sub") {
    // Reorder within (or between) groups:
    const sourceGroup = surveyItems[draggedData.groupIndex];
    if (!sourceGroup || !sourceGroup.subQuestions) return;
    const draggedSub = sourceGroup.subQuestions.splice(draggedData.subIndex, 1)[0];
    surveyItems[targetGroupIndex].subQuestions.splice(targetSubIndex, 0, draggedSub);
    renderAllItems();
  } else if (draggedData.type === "top") {
    // Dragged item is a standalone question.
    const draggedItem = surveyItems.splice(draggedData.index, 1)[0];
    surveyItems[targetGroupIndex].subQuestions.splice(targetSubIndex, 0, draggedItem);
    renderAllItems();
  }
}




      /***********************************************
		 * MODIFY DRAG & DROP HANDLERS FOR SUB–QUESTIONS
		 * Allow moving a sub–question from one group to another.
		 ***********************************************/
		function handleSubDragStart(e) {
		  const targetLI = e.target.closest("li");
		  const groupIndex = parseInt(targetLI.dataset.groupIndex, 10);
		  const subIndex = parseInt(targetLI.dataset.subIndex, 10);
		  e.dataTransfer.setData("text/plain", JSON.stringify({ type: "sub", groupIndex: groupIndex, subIndex: subIndex }));
		}

		function handleSubDragOver(e) {
		  e.preventDefault();
		}

		function handleSubDrop(e) {
		  e.preventDefault();
		  const targetLI = e.target.closest("li");
		  if (!targetLI || targetLI.dataset.type !== "sub") return;
		  const targetGroupIndex = parseInt(targetLI.dataset.groupIndex, 10);
		  const targetSubIndex = parseInt(targetLI.dataset.subIndex, 10);
		  const draggedData = JSON.parse(e.dataTransfer.getData("text/plain"));
		  if (draggedData.type !== "sub") return;
		  // Remove the dragged sub–question from its original group:
		  const sourceGroup = surveyItems[draggedData.groupIndex];
		  if (!sourceGroup || !sourceGroup.subQuestions) return;
		  const draggedSub = sourceGroup.subQuestions.splice(draggedData.subIndex, 1)[0];
		  // Insert the dragged sub–question into the target group's subQuestions array:
		  const targetGroup = surveyItems[targetGroupIndex];
		  targetGroup.subQuestions.splice(targetSubIndex, 0, draggedSub);
		  renderAllItems();
		}

      
      /***********************************************
       * RENDER MASTER
       ***********************************************/
      function renderAllItems() {
        const container = document.getElementById("questions-and-groups");
        container.innerHTML = "";

        // Render each item: question or group
        surveyItems.forEach((item, index) => {
          if (item.type === "question") {
            container.appendChild(renderQuestionCard(item, index));
          } else if (item.type === "group") {
            container.appendChild(renderGroupCard(item, index));
          }
        });

        // Also re-render sidebar
        renderSidebarList();
      }

	/***********************************************
       * RENDER QUESTION CARD (for standalone and sub‐questions)
       ***********************************************/
      function renderQuestionCard(questionObj, index, { isSubQuestion = false, groupIndex = null } = {}) {
	  // questionObj = { type: 'question', questionText, questionType, ... }
        const card = document.createElement("div");
        card.className = isSubQuestion ? "card question-card sub-question" : "card question-card";
	  // For sub‐questions, include the group index in the ID
        card.id = isSubQuestion ? `question-card-${groupIndex}-${index}-sub` : `question-card-${index}`;

        const cardContent = document.createElement("div");
        cardContent.className = "card-content";

        // QUESTION TEXT
        const questionLabel = document.createElement("label");
        questionLabel.textContent = i18n_local[currentLang].questionTextLabel;
        cardContent.appendChild(questionLabel);

        const inputText = document.createElement("input");
        inputText.type = "text";
        inputText.className = "input-field";
        inputText.value = questionObj.questionText || "";
        inputText.oninput = (e) => {
          questionObj.questionText = e.target.value;
          renderSidebarList();
        };
        cardContent.appendChild(inputText);

        // QUESTION TYPE
        const typeLabel = document.createElement("label");
        typeLabel.textContent = i18n_local[currentLang].questionTypeLabel;
        cardContent.appendChild(typeLabel);

        const selectType = document.createElement("select");
        selectType.className = "browser-default question-type-select";
        selectType.onchange = (e) => {
          questionObj.questionType = e.target.value;
          // Clear specialized fields if switching
          if (
            e.target.value === "text" ||
            e.target.value === "date" ||
            e.target.value === "longtext"
          ) {
            questionObj.options = [];
            delete questionObj.maxStars;
            delete questionObj.answer;
          }
          if (e.target.value === "radio" || e.target.value === "checkbox") {
            questionObj.options = questionObj.options || [];
            delete questionObj.maxStars;
            delete questionObj.answer;
          }
          if (e.target.value === "stars") {
            questionObj.maxStars = questionObj.maxStars || 5;
            questionObj.options = [];
            delete questionObj.answer;
          }
          if (e.target.value === "uploadImage") {
            // For image upload, initialize answer as empty.
            questionObj.answer = questionObj.answer || "";
            questionObj.options = [];
            delete questionObj.maxStars;
          }
          renderAllItems();
        };

        const typeOptions = [
          { value: "text", label: i18n_local[currentLang].textInput },
          { value: "radio", label: i18n_local[currentLang].radioInput },
          { value: "checkbox", label: i18n_local[currentLang].checkboxInput },
          { value: "date", label: i18n_local[currentLang].dateInput },
          { value: "longtext", label: i18n_local[currentLang].longtextInput },
          { value: "stars", label: i18n_local[currentLang].starsInput },
          { value: "uploadImage", label: i18n_local[currentLang].uploadImage }
        ];
        typeOptions.forEach((opt) => {
          const optEl = document.createElement("option");
          optEl.value = opt.value;
          optEl.text = opt.label;
          selectType.appendChild(optEl);
        });
        selectType.value = questionObj.questionType || "text";
        cardContent.appendChild(selectType);

        // REQUIRED + COMPACT row
        const switchesRow = document.createElement("div");
        switchesRow.style.display = "flex";
        switchesRow.style.gap = "1.5em";
        switchesRow.style.margin = "10px 0";

        // REQUIRED SWITCH
        const requiredSwitchContainer = document.createElement("div");
        requiredSwitchContainer.className = "switch required-switch";
        requiredSwitchContainer.innerHTML = `
          <label>
            <input type="checkbox" ${questionObj.required ? "checked" : ""}/>
            <span class="lever"></span>
            ${i18n_local[currentLang].requiredLabel}
          </label>
        `;
        requiredSwitchContainer.querySelector("input").addEventListener("change", (e) => {
          questionObj.required = e.target.checked;
        });
        switchesRow.appendChild(requiredSwitchContainer);

        // COMPACT SWITCH (radio/checkbox only)
        if (questionObj.questionType === "radio" || questionObj.questionType === "checkbox") {
          const compackSwitchContainer = document.createElement("div");
          compackSwitchContainer.className = "switch compack-switch";
          compackSwitchContainer.innerHTML = `
            <label>
              <input type="checkbox" ${questionObj.compack ? "checked" : ""}/>
              <span class="lever"></span>
              ${i18n_local[currentLang].compackLabel}
            </label>
          `;
          compackSwitchContainer
            .querySelector("input")
            .addEventListener("change", (e) => {
            questionObj.compack = e.target.checked;
          });
          switchesRow.appendChild(compackSwitchContainer);
        } else {
          questionObj.compack = false;
        }
        cardContent.appendChild(switchesRow);

        // OPTIONS (for radio/checkbox)
        if (questionObj.questionType === "radio" || questionObj.questionType === "checkbox") {
          const optionsLabel = document.createElement("label");
          optionsLabel.textContent = i18n_local[currentLang].optionsLabel;
          cardContent.appendChild(optionsLabel);

          questionObj.options = questionObj.options || [];
          questionObj.options.forEach((opt, optIndex) => {
  // Convert plain string to object if necessary.
            if (typeof opt !== "object") {
              questionObj.options[optIndex] = { text: opt, hasTextInput: false };
              opt = questionObj.options[optIndex];
            }

  // Create a container row.
            const rowDiv = document.createElement("div");
            rowDiv.className = "row";

  // --- Option Text Input Column ---
            const colInputDiv = document.createElement("div");
            colInputDiv.className = "col s8";
            const optionInput = document.createElement("input");
            optionInput.type = "text";
            optionInput.className = "input-field";
            optionInput.value = opt.text;
            optionInput.oninput = (e) => {
              questionObj.options[optIndex].text = e.target.value;
            };
            colInputDiv.appendChild(optionInput);
            rowDiv.appendChild(colInputDiv);

  // --- "Require Extra Text" Toggle Column ---
            const colToggleDiv = document.createElement("div");
            colToggleDiv.className = "col s2";
            const extraLabel = document.createElement("label");
            extraLabel.style.fontSize = "0.8em";
  // Create the checkbox with proper Materialize markup.
            const extraCheckbox = document.createElement("input");
            extraCheckbox.type = "checkbox";
            extraCheckbox.classList.add("filled-in");
            extraCheckbox.checked = opt.hasTextInput;
            extraCheckbox.onchange = (e) => {
              questionObj.options[optIndex].hasTextInput = e.target.checked;
            };
            extraLabel.appendChild(extraCheckbox);
  // Materialize requires a sibling <span> to render the custom checkbox.
            const extraSpan = document.createElement("span");
            extraSpan.textContent = i18n_local[currentLang].extraText;
            extraLabel.appendChild(extraSpan);
            colToggleDiv.appendChild(extraLabel);
            rowDiv.appendChild(colToggleDiv);

  // --- Remove Option Button Column ---
            const colButtonDiv = document.createElement("div");
            colButtonDiv.className = "col s2 right-align";
            const removeBtn = document.createElement("button");
            removeBtn.className = "btn-small red waves-effect waves-light";
            removeBtn.textContent = i18n_local[currentLang].removeOption;
            removeBtn.onclick = () => {
              pushUndo({
                type: "delete-option",
                parentIndex: index,
                parentType: isSubQuestion ? "group-sub" : "main",
                optionIndex: optIndex,
                deletedOption: opt,
              });
              questionObj.options.splice(optIndex, 1);
              renderAllItems();
            };
            colButtonDiv.appendChild(removeBtn);
            rowDiv.appendChild(colButtonDiv);

  // Append the constructed row to the card content.
            cardContent.appendChild(rowDiv);
          });


          // ADD OPTION BUTTON
          const addOptionBtn = document.createElement("button");
          addOptionBtn.className = "btn grey darken-2 waves-effect waves-light";
          addOptionBtn.style.marginTop = "10px";
          addOptionBtn.style.marginLeft = "10px";
          addOptionBtn.innerHTML = `
            <i class="material-icons left">add</i>${i18n_local[currentLang].addOption}
          `;
          addOptionBtn.onclick = () => {
            questionObj.options.push("");
            renderAllItems();
          };
          cardContent.appendChild(addOptionBtn);
        }

        // STAR RATING
        if (questionObj.questionType === "stars") {
          const maxStarsLabel = document.createElement("label");
          maxStarsLabel.textContent = i18n_local[currentLang].maxStarsLabel;
          cardContent.appendChild(maxStarsLabel);
          const maxStarsInput = document.createElement("input");
          maxStarsInput.type = "number";
          maxStarsInput.value = questionObj.maxStars || 5;
          maxStarsInput.min = "1";
          maxStarsInput.oninput = (e) => {
            questionObj.maxStars = parseInt(e.target.value, 10);
          };
          cardContent.appendChild(maxStarsInput);
        }
        
        // NEW: UPLOAD IMAGE QUESTION HANDLER
        if (questionObj.questionType === "uploadImage") {/*
          const uploadLabel = document.createElement("label");
          uploadLabel.textContent = i18n_local[currentLang].uploadImage;
          cardContent.appendChild(uploadLabel);

          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = "image/*";
          fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = function(evt) {
                questionObj.answer = evt.target.result;
                previewImg.style.display = "block";
                previewImg.src = evt.target.result;
              };
              reader.readAsDataURL(file);
            }
          };
          cardContent.appendChild(fileInput);

          // Preview image element:
          const previewImg = document.createElement("img");
          previewImg.style.maxWidth = "100%";
          previewImg.style.marginTop = "10px";
          previewImg.style.display = questionObj.answer ? "block" : "none";
          if (questionObj.answer) {
            previewImg.src = questionObj.answer;
          }
          cardContent.appendChild(previewImg);
		  */
        }

		 /********* ACTION BUTTONS *********/
        const cardAction = document.createElement("div");
        cardAction.className = "card-action question-actions";

		  // Move up button
        const moveUpBtn = document.createElement("button");
        moveUpBtn.className = "btn-small grey waves-effect waves-light";
        moveUpBtn.innerHTML = `<i class="material-icons">arrow_upward</i>`;
        moveUpBtn.style.marginRight = "5px";
        moveUpBtn.title = i18n_local[currentLang].moveUp;

		  // Move down button
        const moveDownBtn = document.createElement("button");
        moveDownBtn.className = "btn-small grey waves-effect waves-light";
        moveDownBtn.innerHTML = `<i class="material-icons">arrow_downward</i>`;
        moveDownBtn.style.marginRight = "5px";
        moveDownBtn.title = i18n_local[currentLang].moveDown;

		  // Delete button
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn-small red waves-effect waves-light";
        deleteBtn.innerHTML = `<i class="material-icons">delete</i>`;
        deleteBtn.title = i18n_local[currentLang].deleteButton;

        if (!isSubQuestion) {
			// For standalone questions, attach standard actions…
          moveUpBtn.onclick = () => moveItemUp(index);
          moveDownBtn.onclick = () => moveItemDown(index);
          deleteBtn.onclick = () => deleteQuestion(index);
			// ...and add a **Group** button to convert the question into a group.
          const groupBtn = document.createElement("button");
          groupBtn.className = "btn-small blue waves-effect waves-light";
          groupBtn.innerHTML = `<i class="material-icons">group</i>`;
          groupBtn.title = i18n_local[currentLang].convertToGroup;
          groupBtn.onclick = () => convertQuestionToGroup(index);
          cardAction.appendChild(groupBtn);
        } else {
			// For sub‐questions, attach sub‐question actions…
          moveUpBtn.onclick = () => moveSubQuestionUp(groupIndex, index);
          moveDownBtn.onclick = () => moveSubQuestionDown(groupIndex, index);
          deleteBtn.onclick = () => deleteSubQuestion(groupIndex, index);
			// ...and add an **Unpack** button to remove it from the group.
          const unpackBtn = document.createElement("button");
          unpackBtn.className = "btn-small orange waves-effect waves-light";
          unpackBtn.innerHTML = `<i class="material-icons">call_split</i>`;
          unpackBtn.title = i18n_local[currentLang].unpackToStandalone;
          unpackBtn.onclick = () => unpackSubQuestion(groupIndex, index);
          cardAction.appendChild(unpackBtn);
        }
		  
		  // Append the common action buttons
        cardAction.appendChild(moveUpBtn);
        cardAction.appendChild(moveDownBtn);
        cardAction.appendChild(deleteBtn);

        card.appendChild(cardContent);
        card.appendChild(cardAction);
        return card;
      }

		/***********************************************
		 * NEW FUNCTIONS: CONVERT & UNPACK
		 ***********************************************/
      function convertQuestionToGroup(index) {
		  // Take a standalone question and convert it to a group.
		  // Here we “wrap” the question inside a group so that it now has sub‐questions.
        const question = surveyItems[index];
        const group = {
          type: "group",
			id: question.id, // reuse the question id or generate a new one as desired
          groupTitle: question.questionText || "",
          anchorQuestionId: null,
          anchorValuesToShow: [],
			// Place the original question as the first sub‐question:
          subQuestions: [question]
        };
        surveyItems[index] = group;
        renderAllItems();
      }

      function unpackSubQuestion(groupIndex, subIndex) {
		  // Remove a sub‐question from a group and add it as a standalone question.
        const groupItem = surveyItems[groupIndex];
        const question = groupItem.subQuestions.splice(subIndex, 1)[0];
        surveyItems.push(question);
        renderAllItems();
      }


		/***********************************************
		 * UPDATE GROUP CARD RENDERING
		 * Add a drop zone so that standalone questions can be dragged into a group.
		 ***********************************************/
      function renderGroupCard(groupObj, index) {
        const card = document.createElement("div");
        card.className = "card group-card";
        card.id = `group-card-${index}`;

        const cardContent = document.createElement("div");
        cardContent.className = "card-content";

		  // GROUP TITLE
        const groupTitleLabel = document.createElement("label");
        groupTitleLabel.textContent = i18n_local[currentLang].groupTitleLabel;
        cardContent.appendChild(groupTitleLabel);

        const groupTitleInput = document.createElement("input");
        groupTitleInput.type = "text";
        groupTitleInput.value = groupObj.groupTitle || "";
        groupTitleInput.oninput = (e) => {
          groupObj.groupTitle = e.target.value;
          renderSidebarList();
        };
        cardContent.appendChild(groupTitleInput);


        // ANCHOR QUESTION SELECT
        const anchorLabel = document.createElement("label");
        anchorLabel.textContent = i18n_local[currentLang].anchorQuestionLabel;
        cardContent.appendChild(anchorLabel);

        const anchorSelect = document.createElement("select");
        anchorSelect.className = "browser-default";
        const allQuestions = surveyItems.filter(item => item.type === "question");
        // Option: no anchor
        {
          const optNone = document.createElement("option");
          optNone.value = "";
          optNone.text = `-- ${i18n_local[currentLang].anchorNoQuestion} --`;
          anchorSelect.appendChild(optNone);
        }
        // All question items
        allQuestions.forEach((qItem) => {
          const opt = document.createElement("option");
          opt.value = qItem.id;
          opt.text = qItem.questionText
            ? qItem.questionText.substring(0, 40)
            : `Q# ${qItem.id}`;
          anchorSelect.appendChild(opt);
        });
        anchorSelect.value = groupObj.anchorQuestionId || "";
        anchorSelect.onchange = (e) => {
          groupObj.anchorQuestionId = e.target.value ? parseInt(e.target.value, 10) : null;
		  renderAllItems(); // re-render to update the anchor values dropdown immediately
        };
        cardContent.appendChild(anchorSelect);

        
// ANCHOR VALUES (Replace text input with multiple select)
        const anchorValuesLabel = document.createElement("label");
        anchorValuesLabel.textContent = i18n_local[currentLang].anchorValuesLabel;
        cardContent.appendChild(anchorValuesLabel);

// Create a multiple select element
        const anchorValuesSelect = document.createElement("select");
        anchorValuesSelect.multiple = true;
anchorValuesSelect.style.height = "auto"; // adjust as needed

// Find the anchor question from surveyItems using groupObj.anchorQuestionId
        let anchorQuestionOptions = [];
        if (groupObj.anchorQuestionId) {
          const anchorQuestion = surveyItems.find(q => q.type === "question" && q.id == groupObj.anchorQuestionId);
          if (anchorQuestion) {
            if (anchorQuestion.questionType === "radio" || anchorQuestion.questionType === "checkbox") {
              anchorQuestionOptions = anchorQuestion.options || [];
            } else if (anchorQuestion.questionType === "stars") {
      // Generate options from 1 to the star count
              const maxStars = anchorQuestion.maxStars || 5;
              anchorQuestionOptions = [];
              for (let i = 1; i <= maxStars; i++) {
                anchorQuestionOptions.push(i.toString());
              }
            }
          }
        }


// Populate the select element with options
        if (anchorQuestionOptions.length === 0) {
  // Add a default option if there are no choices
          const defaultOpt = document.createElement("option");
          defaultOpt.value = "";
          defaultOpt.text = i18n_local[currentLang].noOptionsAvailable;
          anchorValuesSelect.appendChild(defaultOpt);
        } else {
          anchorQuestionOptions.forEach(option => {
            const optEl = document.createElement("option");
    // If the option is an object, use its "text" property; otherwise, use the option directly.
            const optionText = typeof option === 'object' ? option.text : option;
            optEl.value = optionText;
            optEl.text = optionText;
    // Mark the option as selected if it is already in groupObj.anchorValuesToShow
            if (groupObj.anchorValuesToShow && groupObj.anchorValuesToShow.includes(optionText)) {
              optEl.selected = true;
            }
            anchorValuesSelect.appendChild(optEl);
          });
        }

// Update groupObj.anchorValuesToShow when selection changes
        anchorValuesSelect.onchange = (e) => {
          const selectedOptions = Array.from(e.target.selectedOptions).map(opt => opt.value);
          groupObj.anchorValuesToShow = selectedOptions;
        };

        cardContent.appendChild(anchorValuesSelect);
// Delay initialization to ensure the element is attached
        setTimeout(() => {
          M.FormSelect.init(document.querySelectorAll('select[multiple]'));
        }, 0);


  // SUB–QUESTIONS CONTAINER
        const subQuestionsContainer = document.createElement("div");
        subQuestionsContainer.style.marginTop = "20px";
        groupObj.subQuestions = groupObj.subQuestions || [];

        groupObj.subQuestions.forEach((sq, sqIndex) => {
          const subQCard = renderQuestionCard(sq, sqIndex, { isSubQuestion: true, groupIndex: index });
          subQuestionsContainer.appendChild(subQCard);
        });

  // ADD BUTTON: To add a new sub–question manually.
        const addSubQuestionBtn = document.createElement("button");
        addSubQuestionBtn.className = "btn green waves-effect waves-light";
        addSubQuestionBtn.style.marginTop = "10px";
        addSubQuestionBtn.innerHTML = `<i class="material-icons left">add</i>${i18n_local[currentLang].addQuestion}`;
        addSubQuestionBtn.onclick = () => {
          const newQ = {
            type: "question",
            id: Date.now(),
            questionText: "",
            questionType: "text",
            required: false,
            compack: false,
            options: [],
          };
          groupObj.subQuestions.push(newQ);
          renderAllItems();
    // Optionally scroll to the new sub–question
          setTimeout(() => {
            const subIndex = groupObj.subQuestions.length - 1;
            const newCard = document.getElementById(`question-card-${index}-${subIndex}-sub`);
            if (newCard) {
              newCard.scrollIntoView({ behavior: "smooth" });
            }
          }, 0);
        };
        subQuestionsContainer.appendChild(addSubQuestionBtn);

        cardContent.appendChild(subQuestionsContainer);

  // GROUP CARD ACTIONS (move up, move down, delete group)
        const cardAction = document.createElement("div");
        cardAction.className = "card-action group-actions";

        const moveUpBtn = document.createElement("button");
        moveUpBtn.className = "btn-small grey waves-effect waves-light";
        moveUpBtn.innerHTML = `<i class="material-icons">arrow_upward</i>`;
        moveUpBtn.style.marginRight = "5px";
        moveUpBtn.title = i18n_local[currentLang].moveUp;
        moveUpBtn.onclick = () => moveItemUp(index);

        const moveDownBtn = document.createElement("button");
        moveDownBtn.className = "btn-small grey waves-effect waves-light";
        moveDownBtn.innerHTML = `<i class="material-icons">arrow_downward</i>`;
        moveDownBtn.style.marginRight = "5px";
        moveDownBtn.title = i18n_local[currentLang].moveDown;
        moveDownBtn.onclick = () => moveItemDown(index);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn-small red waves-effect waves-light";
        deleteBtn.innerHTML = `<i class="material-icons">delete</i>`;
        deleteBtn.title = i18n_local[currentLang].deleteButton;
        deleteBtn.onclick = () => deleteGroup(index);

        cardAction.appendChild(moveUpBtn);
        cardAction.appendChild(moveDownBtn);
        cardAction.appendChild(deleteBtn);

        card.appendChild(cardContent);
        card.appendChild(cardAction);
        return card;
      }

      /***********************************************
       * RENDER SIDEBAR
       ***********************************************/
      function renderSidebarList() {
        const listContainer = document.getElementById("questions-list");
        listContainer.innerHTML = "";

        surveyItems.forEach((item, index) => {
          if (item.type === "question") {
      // Render top-level standalone question
            const listItem = document.createElement("li");
            listItem.className = "collection-item";
            listItem.draggable = true;
            listItem.dataset.type = "top";
            listItem.dataset.index = index;
      
      // Display index circle and text
            const indexCircle = document.createElement("span");
            indexCircle.className = "list-index-circle";
            indexCircle.textContent = index + 1;
            listItem.appendChild(indexCircle);
      
            const textSpan = document.createElement("span");
            textSpan.textContent = item.questionText
              ? item.questionText.substring(0, 40) + (item.questionText.length > 40 ? "..." : "")
              : i18n_local[currentLang].questionPlaceholder + (index + 1);
            listItem.appendChild(textSpan);
      
      // Attach top-level drag events
            listItem.addEventListener("dragstart", handleTopDragStart);
            listItem.addEventListener("dragover", handleTopDragOver);
            listItem.addEventListener("drop", handleTopDrop);
      
      // On click, scroll to question card
            listItem.onclick = () => {
              const cardId = `question-card-${index}`;
              const targetCard = document.getElementById(cardId);
              if (targetCard) {
                const elementPosition = targetCard.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - 50;
                window.scrollTo({ top: offsetPosition, behavior: "smooth" });
              }
            };
            addContextMenuAndSwipeForStandalone(listItem, index);
            listContainer.appendChild(listItem);
          } else if (item.type === "group") {
      // Render group header
            const groupItem = document.createElement("li");
            groupItem.className = "collection-item";
            groupItem.draggable = true;
            groupItem.dataset.type = "top";
            groupItem.dataset.index = index;
      
            const indexCircle = document.createElement("span");
            indexCircle.className = "list-index-circle";
            indexCircle.textContent = index + 1;
            groupItem.appendChild(indexCircle);
      
            const textSpan = document.createElement("span");
            textSpan.textContent = item.groupTitle
              ? item.groupTitle.substring(0, 40) + (item.groupTitle.length > 40 ? "..." : "")
              : i18n_local[currentLang].groupPlaceholder + (index + 1);
            groupItem.appendChild(textSpan);
      
            groupItem.addEventListener("dragstart", handleTopDragStart);
            groupItem.addEventListener("dragover", handleTopDragOver);
            groupItem.addEventListener("drop", handleTopDrop);
      
            groupItem.onclick = () => {
              const cardId = `group-card-${index}`;
              const targetCard = document.getElementById(cardId);
              if (targetCard) {
                const elementPosition = targetCard.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - 50;
                window.scrollTo({ top: offsetPosition, behavior: "smooth" });
              }
            };

            listContainer.appendChild(groupItem);

      // Render the group's sub–questions in a nested list (UL)
            if (item.subQuestions && item.subQuestions.length > 0) {
              const subList = document.createElement("ul");
              subList.style.listStyle = "none";
              subList.style.paddingLeft = "20px";
        // Save the parent group index so we can use it in the drop handler.
              subList.dataset.groupIndex = index;

        // Attach drop handler on the UL to catch drops in the empty area.
              subList.addEventListener("dragover", (e) => { e.preventDefault(); });
              subList.addEventListener("drop", (e) => {
                e.preventDefault();
                const draggedData = JSON.parse(e.dataTransfer.getData("text/plain"));
                if (draggedData.type === "top") {
                  const groupIdx = parseInt(subList.dataset.groupIndex, 10);
			// Check if the target group exists:
                  if (!surveyItems[groupIdx]) {
                    console.error("Group at index", groupIdx, "not found.");
                    return;
                  }
			// Ensure the group has a subQuestions array:
                  if (!surveyItems[groupIdx].subQuestions) {
                    surveyItems[groupIdx].subQuestions = [];
                  }
			// Remove the dragged item from the top-level array:
                  const targetGroup = surveyItems[groupIdx];
                  const draggedItem = surveyItems.splice(draggedData.index, 1)[0];
			// Push the dragged standalone question into the target group's subQuestions:
                  targetGroup.subQuestions.push(draggedItem);
                  renderAllItems();
                }
              });


        // For each sub–question, create an LI with its own drop handler.
              item.subQuestions.forEach((subItem, subIndex) => {
                const subListItem = document.createElement("li");
                subListItem.className = "collection-item";
                subListItem.draggable = true;
                subListItem.dataset.type = "sub";
                subListItem.dataset.groupIndex = index;
                subListItem.dataset.subIndex = subIndex;

          // Display text for the sub–question
                let subDisplayText = "";
                if (subItem.questionText) {
                  subDisplayText = subItem.questionText.substring(0, 40) + (subItem.questionText.length > 40 ? "..." : "");
                } else {
                  subDisplayText = i18n_local[currentLang].questionPlaceholder + (subIndex + 1);
                }
                const subTextSpan = document.createElement("span");
                subTextSpan.textContent = subDisplayText;
                subListItem.appendChild(subTextSpan);

          // Attach sub–question drag events
                subListItem.addEventListener("dragstart", handleSubDragStart);
                subListItem.addEventListener("dragover", handleSubDragOver);
                subListItem.addEventListener("drop", handleSubDrop);

          // On click, scroll to sub–question card.
                subListItem.onclick = () => {
                  const targetCard = document.getElementById(`question-card-${index}-${subIndex}-sub`);
                  if (targetCard) {
                    const elementPosition = targetCard.getBoundingClientRect().top;
                    const offsetPosition = elementPosition + window.pageYOffset - 50;
                    window.scrollTo({ top: offsetPosition, behavior: "smooth" });
                  }
                };
                addContextMenuAndSwipeForSub(subListItem, index, subIndex);
                subList.appendChild(subListItem);
              });

              listContainer.appendChild(subList);
            }
          }
        });
      }

// For standalone questions: attach right-click and swipe handlers to convert to group
      function addContextMenuAndSwipeForStandalone(listItem, index) {
        listItem.addEventListener("contextmenu", function(e) {
          e.preventDefault();
          showContextMenu(e.pageX, e.pageY, [
            { label: i18n_local[currentLang].convertToGroup || "Convert to Group", action: function() { convertQuestionToGroup(index); } }
          ]);
          return false;
        });
        addSwipeListener(listItem, function(direction) {
          if (direction === "left") {
            showSlideAction(listItem,'<i class="material-icons">group_work</i>', function() {
              convertQuestionToGroup(index);
            });
          }
        });
      }

// For sub‑questions: attach right-click and swipe handlers to unpack to standalone
      function addContextMenuAndSwipeForSub(listItem, groupIndex, subIndex) {
        listItem.addEventListener("contextmenu", function(e) {
          e.preventDefault();
          showContextMenu(e.pageX, e.pageY, [
            { label: i18n_local[currentLang].unpackToStandalone || "Unpack to Standalone", action: function() { unpackSubQuestion(groupIndex, subIndex); } }
          ]);
          return false;
        });
        addSwipeListener(listItem, function(direction) {
          if (direction === "left") {
            showSlideAction(listItem, '<i class="material-icons">call_split</i>', function() {
              unpackSubQuestion(groupIndex, subIndex);
            });
          }
        });
      }
// Simple swipe listener: if a left swipe is detected, call the callback with "left"
      function addSwipeListener(element, callback) {
        let touchstartX = 0;
        let touchstartY = 0;
        element.addEventListener(
          'touchstart',
          function(event) {
            touchstartX = event.changedTouches[0].screenX;
            touchstartY = event.changedTouches[0].screenY;
          },
          { passive: true }
        );
        element.addEventListener(
          'touchend',
          function(event) {
            const touchendX = event.changedTouches[0].screenX;
            const touchendY = event.changedTouches[0].screenY;
            const deltaX = touchstartX - touchendX;
            const deltaY = touchstartY - touchendY;
      // Trigger only if horizontal movement is significant and dominant
            if (Math.abs(deltaX) > 50 && Math.abs(deltaX) > Math.abs(deltaY)) {
              callback("left");
            }
          },
          { passive: true }
        );
      }



// Display a slide-out overlay action on mobile
      function showSlideAction(element, label, action) {
        if (element.querySelector('.slide-action-overlay')) return;
        const overlay = document.createElement('div');
        overlay.className = 'slide-action-overlay';
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.width = '150px';
        overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
        overlay.style.color = 'white';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        overlay.style.cursor = 'pointer';
        overlay.innerHTML = label;
        element.style.position = 'relative';
        element.appendChild(overlay);
        overlay.addEventListener('click', function(e) {
          e.stopPropagation();
          action();
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
        });
        setTimeout(function() {
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
        }, 3000);
      }

// Display a custom context menu at the specified coordinates with given items
      function showContextMenu(x, y, items) {
        let existingMenu = document.getElementById('custom-context-menu');
        if (existingMenu) {
          existingMenu.parentNode.removeChild(existingMenu);
        }
        const menu = document.createElement('div');
        menu.id = 'custom-context-menu';
        menu.style.position = 'absolute';
        menu.style.top = y + 'px';
        menu.style.left = x + 'px';
        menu.style.backgroundColor = 'white';
        menu.style.border = '1px solid #ccc';
        menu.style.boxShadow = '0 2px 5px rgba(0,0,0,0.3)';
        menu.style.zIndex = 10000;
        items.forEach(function(item) {
          const menuItem = document.createElement('div');
          menuItem.textContent = item.label;
          menuItem.style.padding = '8px 12px';
          menuItem.style.cursor = 'pointer';
          menuItem.addEventListener('click', function(e) {
            e.stopPropagation();
            item.action();
            if (menu.parentNode) {
              menu.parentNode.removeChild(menu);
            }
          });
          menu.appendChild(menuItem);
        });
        document.body.appendChild(menu);
        document.addEventListener('click', function handler() {
          if (menu.parentNode) {
            menu.parentNode.removeChild(menu);
          }
          document.removeEventListener('click', handler);
        });
      }

      /***********************************************
       * CRUD: ADD QUESTION / ADD GROUP
       ***********************************************/
      function addQuestion() {
        const newQuestion = {
          type: "question",
          id: Date.now(),
          questionText: "",
          questionType: "text",
          options: [],
          required: false,
          compack: false,
        };
        surveyItems.push(newQuestion);
        renderAllItems();
        // Scroll to the last
        setTimeout(() => {
          const lastIndex = surveyItems.length - 1;
          const lastCard = document.getElementById(`question-card-${lastIndex}`);
          if (lastCard) {
            lastCard.scrollIntoView({ behavior: "smooth" });
          }
        }, 0);
      }

      function addGroup() {
        const newGroup = {
          type: "group",
          id: Date.now(),
          groupTitle: "",
          anchorQuestionId: null,
          anchorValuesToShow: [],
          subQuestions: [],
        };
        surveyItems.push(newGroup);
        renderAllItems();
        // Scroll to the last
        setTimeout(() => {
          const lastIndex = surveyItems.length - 1;
          const lastCard = document.getElementById(`group-card-${lastIndex}`);
          if (lastCard) {
            lastCard.scrollIntoView({ behavior: "smooth" });
          }
        }, 0);
      }

      /***********************************************
       * CRUD: DELETE QUESTION / GROUP / SUBQUESTION
       ***********************************************/
      function deleteQuestion(index) {
        const deletedQ = surveyItems[index];
        pushUndo({
          type: "delete-question",
          index: index,
          deletedItem: deletedQ,
        });
        surveyItems.splice(index, 1);
        renderAllItems();
        M.toast({ html: i18n_local[currentLang].deleteMsg, displayLength: 3000 });
      }

      function deleteGroup(index) {
        const deletedG = surveyItems[index];
        pushUndo({
          type: "delete-group",
          index: index,
          deletedItem: deletedG,
        });
        surveyItems.splice(index, 1);
        renderAllItems();
        M.toast({ html: i18n_local[currentLang].deleteGroupMsg, displayLength: 3000 });
      }

      function deleteSubQuestion(groupIndex, subIndex) {
        const groupItem = surveyItems[groupIndex];
        const deletedQ = groupItem.subQuestions[subIndex];
        pushUndo({
          type: "delete-sub-question",
          groupIndex,
          subIndex,
          deletedItem: deletedQ,
        });
        groupItem.subQuestions.splice(subIndex, 1);
        renderAllItems();
      }

      /***********************************************
       * MOVE UP/DOWN: MAIN LEVEL
       ***********************************************/
      function moveItemUp(index) {
        if (index > 0) {
          const temp = surveyItems[index];
          surveyItems[index] = surveyItems[index - 1];
          surveyItems[index - 1] = temp;
          renderAllItems();
        }
      }

      function moveItemDown(index) {
        if (index < surveyItems.length - 1) {
          const temp = surveyItems[index];
          surveyItems[index] = surveyItems[index + 1];
          surveyItems[index + 1] = temp;
          renderAllItems();
        }
      }

      /***********************************************
       * MOVE UP/DOWN: SUB QUESTIONS
       ***********************************************/
      function moveSubQuestionUp(groupIndex, subIndex) {
        const groupItem = surveyItems[groupIndex];
        if (subIndex > 0) {
          const temp = groupItem.subQuestions[subIndex];
          groupItem.subQuestions[subIndex] = groupItem.subQuestions[subIndex - 1];
          groupItem.subQuestions[subIndex - 1] = temp;
          renderAllItems();
        }
      }

      function moveSubQuestionDown(groupIndex, subIndex) {
        const groupItem = surveyItems[groupIndex];
        if (subIndex < groupItem.subQuestions.length - 1) {
          const temp = groupItem.subQuestions[subIndex];
          groupItem.subQuestions[subIndex] = groupItem.subQuestions[subIndex + 1];
          groupItem.subQuestions[subIndex + 1] = temp;
          renderAllItems();
        }
      }

      /***********************************************
       * UNDO/REDO
       ***********************************************/
      function pushUndo(action) {
        undoStack.push(action);
        redoStack = [];
      }

      function undoAction() {
        if (undoStack.length === 0) return;
        const action = undoStack.pop();
        let redoActionObj = null;
        switch (action.type) {
          case "delete-question": {
            surveyItems.splice(action.index, 0, action.deletedItem);
            redoActionObj = {
              type: "delete-question",
              index: action.index,
              deletedItem: action.deletedItem,
            };
            break;
          }
          case "delete-group": {
            surveyItems.splice(action.index, 0, action.deletedItem);
            redoActionObj = {
              type: "delete-group",
              index: action.index,
              deletedItem: action.deletedItem,
            };
            break;
          }
          case "delete-sub-question": {
            const { groupIndex, subIndex, deletedItem } = action;
            const groupItem = surveyItems[groupIndex];
            groupItem.subQuestions.splice(subIndex, 0, deletedItem);
            redoActionObj = {
              type: "delete-sub-question",
              groupIndex,
              subIndex,
              deletedItem,
            };
            break;
          }
          case "delete-option": {
            const { parentIndex, parentType, optionIndex, deletedOption } = action;
            if (parentType === "main") {
              surveyItems[parentIndex].options.splice(optionIndex, 0, deletedOption);
            } else if (parentType === "group-sub") {
              // not storing sub-question index here, so no direct approach
              // In real usage you'd store the subIndex too for precise restore
              // For brevity, skipping more complicated logic
            }
            redoActionObj = {
              type: "delete-option",
              parentIndex, parentType, optionIndex, deletedOption
            };
            break;
          }
          default:
            break;
        }
        if (redoActionObj) {
          redoStack.push(redoActionObj);
        }
        renderAllItems();
      }

      function redoAction() {
        if (redoStack.length === 0) return;
        const action = redoStack.pop();
        let undoActionObj = null;
        switch (action.type) {
          case "delete-question": {
            const deletedQ = surveyItems.splice(action.index, 1)[0];
            undoActionObj = {
              type: "delete-question",
              index: action.index,
              deletedItem: deletedQ,
            };
            break;
          }
          case "delete-group": {
            const deletedG = surveyItems.splice(action.index, 1)[0];
            undoActionObj = {
              type: "delete-group",
              index: action.index,
              deletedItem: deletedG,
            };
            break;
          }
          case "delete-sub-question": {
            const { groupIndex, subIndex } = action;
            const groupItem = surveyItems[groupIndex];
            const deletedQ = groupItem.subQuestions.splice(subIndex, 1)[0];
            undoActionObj = {
              type: "delete-sub-question",
              groupIndex,
              subIndex,
              deletedItem: deletedQ,
            };
            break;
          }
          case "delete-option": {
            const { parentIndex, parentType, optionIndex } = action;
            let deletedOpt = null;
            if (parentType === "main") {
              deletedOpt = surveyItems[parentIndex].options.splice(optionIndex, 1)[0];
            } else if (parentType === "group-sub") {
              // same note as above
            }
            undoActionObj = {
              type: "delete-option",
              parentIndex, parentType, optionIndex,
              deletedOption: deletedOpt,
            };
            break;
          }
          default:
            break;
        }
        if (undoActionObj) {
          undoStack.push(undoActionObj);
        }
        renderAllItems();
      }

      function setupUndoRedoButtons() {
        const undoBtn = document.getElementById("undo-btn");
        const redoBtn = document.getElementById("redo-btn");
        undoBtn.onclick = () => undoAction();
        redoBtn.onclick = () => redoAction();
      }

      /***********************************************
       * GENERATE & GO
       ***********************************************/
      async function generateSurvey() {
		  // Get the survey title input value
        const surveyTitleInput = document.getElementById("survey-title-input");
        const surveyTitle = surveyTitleInput ? surveyTitleInput.value.trim() : "";

		  // Validate: user must enter a title
        if (!surveyTitle) {
          M.toast({ html: i18n_local[currentLang].enterSurveyTitle, displayLength: 2000 });
          surveyTitleInput.focus();
			return;  // stop the function if title is missing
        }

		  // Get the endpoint URL from the settings modal input
        const endpointUrl = document.getElementById("endpoint-url").value;
          
      // Get the banner image URL from the new input
        const bannerImageUrl = document.getElementById("survey-banner-input").value.trim();
		  
        const channelSelect = document.getElementById("channel-select");
        const selectedChannelId = channelSelect.value;

        const channelId = selectedChannelId.trim();

		  // Create an output object that includes the survey title and banner image URL
        const surveyOutput = {
          endpointUrl: endpointUrl,
          surveyItems: surveyItems,
			surveyTitle: surveyTitle,   // <-- Added field
      bannerImage: bannerImageUrl, // NEW: Banner image URL
			storeTitle: null, //@fixme, need to update
			storeId: null, //@fimxme, need to update
          _channelId : channelId,
          _userId: currentUserId
        };

		  // Save the complete structure to localStorage
        localStorage.setItem("surveyQuestions", JSON.stringify(surveyOutput));
        let result = await updateSurvey(CurrentSurveySchemaId, surveyOutput);
        if (!CurrentSurveySchemaId) {
          CurrentSurveySchemaId = result?._id;
          localStorage.CurrentSurveySchemaId = CurrentSurveySchemaId;
        }

		  // Create the URL string
        const finalURL = window.location.origin +
                 window.location.pathname.replace("admin.html", "survey.html") +
                 "?id=" + CurrentSurveySchemaId;


		  // Set the URL text inside the modal
        document.getElementById("surveyLinkText").textContent = finalURL;

		  // Set up the copy button to copy the URL to clipboard
        document.getElementById("copyBtn").onclick = function() {
          navigator.clipboard.writeText(finalURL).then(() => {
            M.toast({ html: i18n_local[currentLang].copiedToClipboard, displayLength: 2000 });
          });
        };

		  // Set up the Go button to navigate to the URL
        document.getElementById("goBtn").onclick = function() {
          window.location.href = finalURL;
        };

		  // Open the modal (initialize if necessary)
        const modalElem = document.getElementById("surveyLinkModal");
        let modalInstance = M.Modal.getInstance(modalElem);
        if (!modalInstance) {
          modalInstance = M.Modal.init(modalElem);
        }
        modalInstance.open();
      }


	  	  
      /***********************************************
       * fetch and update survey context
       ***********************************************/
      async function fetchSurvey(surveySchemaId, callback) {
        try {
          let url = "";
          if (surveySchemaId) {
          // Get a specific survey schema by its id.
            url = `${BASE_URL}/api/survey/${surveySchemaId}`;
          } else {
          // If no id is provided, fetch all surveys for the current user.
            url = `${BASE_URL}/api/survey?userId=${currentUserId}`;
          }
          const response = await fetch(url, {
            headers: {Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
          });
          const data = await response.json();
          if (typeof callback === "function") {
            callback(null, data);
          }
          return data;
        } catch (error) {
          if (typeof callback === "function") {
            callback(error);
          }
          throw error;
        }
      }

      async function updateSurvey(surveySchemaId, content, callback) {
        try {
          let response;
          if (surveySchemaId) {
          // Update an existing survey schema.
            response = await fetch(`${BASE_URL}/api/survey/${surveySchemaId}`, {
              method: "PUT",
              headers: { "Content-Type": "application/json", Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
              body: JSON.stringify(content),
            });
          } else {
          // Create a new survey schema.
            response = await fetch(`${BASE_URL}/api/survey`, {
              method: "POST",
              headers: { "Content-Type": "application/json", Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
              body: JSON.stringify(content),
            });
          }
          const data = await response.json();
          if (typeof callback === "function") {
            callback(null, data);
          }
          return data;
        } catch (error) {
          if (typeof callback === "function") {
            callback(error);
          }
          throw error;
        }
      }

      async function updateSurveyCounter(surveySchemaId, callback) {
        try {
          const response = await fetch(`${BASE_URL}/api/survey/${surveySchemaId}/counter`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" , Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
          });
          const data = await response.json();
          if (typeof callback === "function") {
            callback(null, data);
          }
          return data;
        } catch (error) {
          if (typeof callback === "function") {
            callback(error);
          }
          throw error;
        }
      }

      function showSelectSurveyModal(surveys, dismissible = false) {
        return new Promise((resolve) => {
    // Populate the list
          const surveyList = document.getElementById("surveyList");
    surveyList.innerHTML = ""; // clear any previous items
          const importSurveyBtn = document.getElementById("importSurveyBtn");
    // Add existing surveys to the list
          surveys.forEach((survey) => {
            const li = document.createElement("li");
            li.className = "collection-item";
            li.style.cursor = "pointer";
      
      // Display survey title if available; otherwise fallback to survey ID
            if (survey.surveyTitle) {
              li.textContent = `${survey.surveyTitle} (ID: ${survey._id})`;
            } else {
              li.textContent = i18n_local[currentLang].surveyIdLabel + " " + survey._id;
            }
            li.dataset.surveyId = survey._id;

      // Pre-select if this survey is the current one.
            if (survey._id === localStorage.CurrentSurveySchemaId) {
              li.classList.add("blue", "white-text");
            }
      // Highlight the clicked item
            li.onclick = function () {
              document.querySelectorAll("#surveyList .collection-item").forEach((item) => {
                item.classList.remove("blue", "white-text");
              });
              li.classList.add("blue", "white-text");
        
        // Enable the import button only if the selected survey matches the current one.
              if (li.dataset.surveyId === localStorage.CurrentSurveySchemaId) {
                importSurveyBtn.removeAttribute("disabled");
              } else {
                importSurveyBtn.setAttribute("disabled", true);
              }
            };
      // ADD: Delete icon for survey deletion
            const deleteIcon = document.createElement("i");
            deleteIcon.className = "material-icons right";
            deleteIcon.style.cursor = "pointer";
            deleteIcon.textContent = "delete";
            deleteIcon.onclick = async (e) => {
              e.stopPropagation();
              if (confirm(i18n_local[currentLang].confirmDeleteSurvey)) {
                try {
                  const response = await fetch(`${BASE_URL}/api/survey/${survey._id}`, {
                    headers: { Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
                    method: "DELETE"
                  });
                  const result = await response.json();
                  if (response.ok) {
                    M.toast({ html: i18n_local[currentLang].surveyDeletedSuccessfully, displayLength: 2000 });
                    li.remove();
                  } else {
                    M.toast({ html: result.error || i18n_local[currentLang].failedToDeleteSurvey, displayLength: 2000 });
                  }
                } catch (error) {
                  M.toast({ html: "Error deleting survey", displayLength: 2000 });
                }
              }
            };
            li.appendChild(deleteIcon);
            surveyList.appendChild(li);
          });

    // Add the "Create New" item at the bottom
          const createNewItem = document.createElement("li");
          createNewItem.className = "collection-item";
          createNewItem.style.cursor = "pointer";
          createNewItem.style.fontWeight = "bold";
          createNewItem.textContent = i18n_local[currentLang].newSurvey;
          createNewItem.dataset.surveyId = "create new";
          createNewItem.onclick = function () {
            document.querySelectorAll("#surveyList .collection-item").forEach((item) => {
              item.classList.remove("blue", "white-text");
            });
            createNewItem.classList.add("blue", "white-text");
            if (createNewItem.dataset.surveyId === localStorage.CurrentSurveySchemaId) {
              importSurveyBtn.removeAttribute("disabled");
            } else {
              importSurveyBtn.setAttribute("disabled", true);
            }
          };
          surveyList.appendChild(createNewItem);

    // Open the modal (ensuring it doesn't dismiss if nothing is selected)
          const modalElem = document.getElementById("selectSurveyModal");
          let modalInstance = M.Modal.getInstance(modalElem);
          if (modalInstance) {
            modalInstance.options.dismissible = dismissible;
          } else {
            modalInstance = M.Modal.init(modalElem, {
              dismissible: dismissible
            });
          }
          const selectedItem = document.querySelector("#surveyList .collection-item.blue");
          if (selectedItem && selectedItem.dataset.surveyId === localStorage.CurrentSurveySchemaId) {
            importSurveyBtn.removeAttribute("disabled");
          } else {
            importSurveyBtn.setAttribute("disabled", true);
          }
          modalInstance.open();

    // When user clicks "Confirm", get the selected survey ID
          const confirmBtn = document.getElementById("confirmSurveyBtn");
          confirmBtn.onclick = function () {
            const selectedItem = document.querySelector("#surveyList .collection-item.blue");
            if (selectedItem) {
              const selectedId = selectedItem.dataset.surveyId;
              modalInstance.close();
              if (selectedId === "create new") {
          // If "create new" is selected, pop up the import survey modal directly.
                delete localStorage.CurrentSurveySchemaId;
                CurrentSurveySchemaId = null;
                openImportSurveyModal();
              } else {
                localStorage.CurrentSurveySchemaId = selectedId;
              }
              resolve(selectedId);
            } else {
              M.toast({
                html: i18n_local[currentLang].pleaseSelectSurvey,
                displayLength: 2000
              });
            }
          };
        });
      }

let isSurveyModified;
      function handleSwitchSurvey() {
        if (isSurveyModified) {
    // Use Materialize's confirm modal or simply window.confirm.
    // Here we'll use window.confirm for simplicity.
          if (window.confirm(i18n_local[currentLang].unsavedChangesPrompt)) {
      // User wants to save changes, so call generateSurvey.
            generateSurvey().then(() => {
        // Once saved, open the survey list modal to let user select another survey.
              openSurveyListModal();
            });
          } else {
      // User does not want to save changes; simply open the survey list modal.
            openSurveyListModal();
          }
        } else {
          openSurveyListModal();
        }
      }

      async function openSurveyListModal() {
  // Assume 'surveys' is already available or fetch it here.
  const surveys = await fetchSurvey(); // or however you fetch the list
  
  // Open the survey list modal and get the selected survey ID
        let selectedId = await showSelectSurveyModal(surveys, true);

  
        if (selectedId) {
    // Switch survey after the user selects one.
    // You might want to store the selected survey ID and then reload the survey content.
    // For example:
          switchSurveyById(selectedId);
        }
      }

      async function switchSurveyById(surveyId) {
        if (surveyId === "create new") {
    // Handle creating a new survey
          surveyItems = [];
          document.getElementById("survey-title-input").value = "";
          document.getElementById("survey-banner-input").value = "";
          CurrentSurveySchemaId = undefined;
          isSurveyModified = false;
          renderAllItems();
        } else {
    // Fetch the survey by its id
          let tmp = await fetchSurvey(surveyId);
          const existingData = tmp;
          if (existingData) {
            const parsed = typeof existingData === "string" ? JSON.parse(existingData) : existingData;
            surveyItems = parsed.surveyItems.map(item => item.type ? item : { type: "question", ...item });
      // Set the survey title input if one exists
            if (parsed.surveyTitle) {
              document.getElementById("survey-title-input").value = parsed.surveyTitle;
            }
            else {
              document.getElementById("survey-title-input").value = '';
            }
      // Set the banner image input if one exists
            if (parsed.bannerImage) {
              document.getElementById("survey-banner-input").value = parsed.bannerImage;
            } else {
              document.getElementById("survey-banner-input").value = '';
            }
      // Set the channel Id   
            if (parsed._channelId) {
        // Save the channel ID in a global variable (if needed later)
              window.preSelectedChannel = parsed._channelId;
        // Set the dropdown's value and refresh the Materialize UI
              const channelSelect = document.getElementById("channel-select");
              if (channelSelect) {
                channelSelect.value = parsed._channelId;
                M.FormSelect.init(channelSelect);
              }
            }
            CurrentSurveySchemaId = surveyId;
            isSurveyModified = false;
            renderAllItems();
          }
        }
        updateNavTitle();
        window.scrollTo({ top: 0, behavior: "auto" });
        document.querySelectorAll(".question-card, .group-card").forEach((el) => {
          el.classList.add("slide-in");
          setTimeout(() => el.classList.remove("slide-in"), 1000);
        });
      }

      async function logout() {
        let res = confirm(i18n_local[currentLang].logoutConfirm);
        if (res) {  
    // clear the cookie authentication
          const response = await fetch(`${BASE_URL}/api/logout`, {
            method: 'POST',
            body: JSON.stringify({ userId: localStorage.userId }),
            credentials: "include"
          });
          const data = await response.json();
          console.log(data);
          delete localStorage.userId;
          delete localStorage.userToken;
          setTimeout(function(){
            location.reload();
          }, 1000)
        }
      }

      function updateNavTitle() {
        const navTitleEl = document.getElementById("nav-title");
        let titleText = "";
        if (!CurrentSurveySchemaId) {
          titleText = i18n_local[currentLang].importSurvey;
        } else if (CurrentSurveySchemaId === "create new") {
          titleText = i18n_local[currentLang].newSurvey;
        } else {
          titleText = CurrentSurveySchemaId;
        }
        navTitleEl.innerHTML = `<span class=''><i class="material-icons left">library_add</i>${i18n_local[currentLang].surveyIdPrefix} (${titleText})</span>`;
      }



     /***********************************************
       * IMPORT SURVEY
       ***********************************************/

// Global variable to hold imported survey JSON (from file)
      var importedSurveyDataFromFile = null;

// Opens the Import Survey popup modal and resets its fields.
      function openImportSurveyModal() {


   // NEW: Check if there's an existing survey loaded
        if (CurrentSurveySchemaId) {
          if (!confirm(i18n_local[currentLang].importReplaceConfirmation)) {
      // If user cancels, exit the import process.
            return;
          }
        }
        const modalElem = document.getElementById('importSurveyModal');
        let modalInstance = M.Modal.getInstance(modalElem);
        if (!modalInstance) {
          modalInstance = M.Modal.init(modalElem, { dismissible: true });
        }
  // Reset mode to "file" by default.
        const storedMode = localStorage.getItem("importMode") || "text";
        document.querySelector('input[name="importMode"][value="' + storedMode + '"]').checked = true;
        updateImportModePopup();
  // Clear any previous inputs.
        document.getElementById('popupImportSurveyFile').value = "";
        document.getElementById('popupImportSurveyUrl').value = "";
        document.getElementById('popupImportSurveyText').value = "";
        importedSurveyDataFromFile = null;
        modalInstance.open();
      }

// Updates the popup UI based on the selected import mode.
      function updateImportModePopup() {
        const mode = document.querySelector('input[name="importMode"]:checked').value;
        document.getElementById("popupImportFileContainer").style.display = (mode === "file") ? "block" : "none";
        document.getElementById("popupImportUrlContainer").style.display = (mode === "url") ? "block" : "none";
        document.getElementById("popupImportTextContainer").style.display = (mode === "text") ? "block" : "none";
      }

// Handles file import in the popup modal.
// After the file is read and parsed correctly, the import process is triggered automatically.
      function handleImportSurveyFilePopup(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            importedSurveyDataFromFile = JSON.parse(e.target.result);
      // M.toast({ html: "File loaded successfully", displayLength: 2000 });
      // Automatically trigger the import process.
            handleFinalImport();
          } catch (error) {
            M.toast({ html: i18n_local[currentLang].fileParseError, displayLength: 2000 });
          }
        };
        reader.readAsText(file);
      }

// Called when the user clicks "Import" in the popup modal (or automatically for file mode).
      async function handleFinalImport() {
        const mode = document.querySelector('input[name="importMode"]:checked').value;
        let importedData;
        if (mode === "file") {
          if (!importedSurveyDataFromFile) {
            M.toast({ html: i18n_local[currentLang].invalidJsonFile, displayLength: 3000 });
            return;
          }
          importedData = importedSurveyDataFromFile;
        } else if (mode === "url") {
          const url = document.getElementById('popupImportSurveyUrl').value.trim();
          if (!url) {
            M.toast({ html: i18n_local[currentLang].enterUrl, displayLength: 3000 });
            return;
          }
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error("Network error");
            }
            importedData = await response.json();
          } catch (error) {
            M.toast({ html: i18n_local[currentLang].importSurveyUrlFail, displayLength: 3000 });
            return;
          }
        } else if (mode === "text") {
          const text = document.getElementById('popupImportSurveyText').value.trim();
          if (!text) {
            M.toast({ html: i18n_local[currentLang].pasteJsonText, displayLength: 3000 });
            return;
          }
          try {
            importedData = JSON.parse(text);
          } catch (error) {
            M.toast({ html: i18n_local[currentLang].parseJsonTextError, displayLength: 3000 });
            return;
          }
        }
  
  // Validate and process the imported data.
        try {
          if (!importedData.surveyItems) {
            throw new Error(i18n_local[currentLang].invalidSurveySchema || "Invalid survey schema: missing surveyItems");
          }

    // Update survey items and UI
          surveyItems = importedData.surveyItems;
          document.getElementById("survey-title-input").value = importedData.surveyTitle || "";
    // Update banner image if available
          document.getElementById("survey-banner-input").value = importedData.bannerImage || "";
    
    // Add effect for smoother UI

    renderAllItems(); // Render imported survey

          window.scrollTo({ top: 0, behavior: "auto" });
    // Add highlight effect to new items
          document.querySelectorAll(".question-card, .group-card").forEach((el) => {
            el.classList.add("slide-in");
            setTimeout(() => {
              el.classList.remove("slide-in")
	  }, 1000); // Remove highlight after effect
          });

    

    // Show success message
          M.toast({ html: i18n_local[currentLang].importSurveySuccess, displayLength: 3000 });

    // Close import modal
          const importModalElem = document.getElementById('importSurveyModal');
          const importModalInstance = M.Modal.getInstance(importModalElem);
          if (importModalInstance) importModalInstance.close();

    // Close select survey modal (if open)
          const selectModalElem = document.getElementById('selectSurveyModal');
          const selectModalInstance = M.Modal.getInstance(selectModalElem);
          if (selectModalInstance) selectModalInstance.close();
        } catch (error) {
          M.toast({ html: i18n_local[currentLang].importSurveyFailed, displayLength: 2000 });
        }
      }




// fetch survey data using the REST API.
      async function fetchSurveyData() {
  
        if (!CurrentSurveySchemaId) {
          M.toast({ html: "surveyId is required to fetch survey data", displayLength: 3000 });
          return;
        }
  
  // Build the API URL. In this example, we map channelId to _typeId and use _type=survey.
        const url = `${BASE_URL}/api/read-data?_typeId=${encodeURIComponent(CurrentSurveySchemaId)}&_type=survey`;
        try {
          const response = await fetch(url, {
            headers: { "Content-Type": "application/json" , Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
          });
          const result = await response.json();
          if (result.error) {
            M.toast({ html: result.error, displayLength: 3000 });
            return;
          }
    // Call the summary function with the fetched data.
          summarizeSurveyData(result.data);
        } catch (err) {
          console.error("Error fetching survey data:", err);
          M.toast({ html: "Error fetching survey data", displayLength: 3000 });
        }
      }

      async function summarizeSurveyData(responses) {
  // First, fetch the survey schema
        let surveySchema = await fetchSurvey(CurrentSurveySchemaId);
  // Flatten the survey items into an ordered array of questions.
        let orderedQuestions = [];
        surveySchema.surveyItems.forEach(item => {
          if (item.type === "question") {
            orderedQuestions.push(item);
          } else if (item.type === "group" && Array.isArray(item.subQuestions)) {
      // For groups, add sub-questions in the order they appear.
            item.subQuestions.forEach(subq => {
              orderedQuestions.push(subq);
            });
          }
        });
  
  // Aggregate responses by questionId.
        const summaryMap = {};
        responses.forEach(response => {
          response.forEach(item => {
            const qid = item.questionId;
            if (!summaryMap[qid]) {
              summaryMap[qid] = {
          question: item.question, // update to last row to reflect current text
                type: item.questionType,
                answers: []
              };
            }
      // Update question and type (in case they change in later responses)
            summaryMap[qid].question = item.question;
            summaryMap[qid].type = item.questionType;
            summaryMap[qid].answers.push(item.answer);
          });
        });
        const content = document.getElementById("surveyDataContent");
        content.innerHTML = "";
  
  // Define color arrays for the charts.
        const backgroundColors = [
          'rgba(255, 99, 132, 0.6)',
          'rgba(54, 162, 235, 0.6)',
          'rgba(255, 206, 86, 0.6)',
          'rgba(75, 192, 192, 0.6)',
          'rgba(153, 102, 255, 0.6)',
          'rgba(255, 159, 64, 0.6)'
        ];
        const borderColors = [
          'rgba(255, 99, 132, 1)',
          'rgba(54, 162, 235, 1)',
          'rgba(255, 206, 86, 1)',
          'rgba(75, 192, 192, 1)',
          'rgba(153, 102, 255, 1)',
          'rgba(255, 159, 64, 1)'
        ];
  
  // Iterate over questions following the schema order.
        orderedQuestions.forEach(questionSchema => {
    // Convert question ID to string for consistency.
          const qid = questionSchema.id.toString();
    // Use responses if available; otherwise, create an empty summary.
          let summary = summaryMap[qid] || {
            question: questionSchema.questionText,
            type: questionSchema.questionType,
            answers: []
          };
    
    // Build summary based on the question type.
          if (questionSchema.questionType === "radio" || questionSchema.questionType === "checkbox") {
      // For radio/checkbox: use schema options to determine order and include missing options.
            const options = (questionSchema?.options.map(option => option.text)) || [];
            let freq = {};
            options.forEach(opt => { freq[opt] = 0; });
            summary.answers.forEach(ans => {
              if (Array.isArray(ans)) {
                ans.forEach(a => {
                  if (freq[a] !== undefined) {
                    freq[a]++;
                  } else {
                    freq[a] = 1;
                  }
                });
              } else {
                if (freq[ans] !== undefined) {
                  freq[ans]++;
                } else {
                  freq[ans] = 1;
                }
              }
            });
            const labels = options;
            const dataCounts = labels.map(label => freq[label] || 0);
            createSummaryBlock(questionSchema, summary, labels, dataCounts);
          } else if (questionSchema.questionType === "stars") {
      // For stars: create a scale from 1 to maxStars.
            let maxStars = questionSchema.maxStars || 5;
            let labels = [];
            let freq = {};
            for (let i = 1; i <= maxStars; i++) {
              labels.push(i.toString());
              freq[i] = 0;
            }
            summary.answers.forEach(ans => {
              let num = Number(ans);
              if (num >= 1 && num <= maxStars) {
                freq[num]++;
              }
            });
            const dataCounts = labels.map(label => freq[label] || 0);
            createSummaryBlock(questionSchema, summary, labels, dataCounts, true);
          } else if (questionSchema.questionType === "date") {
      // For date questions, aggregate unique dates from responses.
            let freq = {};
            summary.answers.forEach(ans => {
              freq[ans] = (freq[ans] || 0) + 1;
            });
      // Order dates by natural order.
            let labels = Object.keys(freq).sort();
            const dataCounts = labels.map(label => freq[label]);
            createSummaryBlock(questionSchema, summary, labels, dataCounts);
          } else if (questionSchema.questionType === "text" || questionSchema.questionType === "longtext") {
      // For text answers, simply display a note.
            createSummaryBlock(questionSchema, summary, null, null);
          }
        });
  
  // Open the full-page overlay.
        openSurveyDataPage();
  
  // Helper function: creates the summary block (chart and/or list) for a question.
        function createSummaryBlock(questionSchema, summary, labels, dataCounts, isStars = false) {
          const container = document.createElement("div");
          container.className = "question-summary";
          container.style.padding = "1rem";
          container.style.border = "1px solid #ddd";
          container.style.borderRadius = "8px";
          container.style.boxShadow = "0 2px 5px rgba(0,0,0,0.1)";
          container.style.background = "#fff";
    
    // Header: question text and type.
          const header = document.createElement("h5");
          header.textContent = `${questionSchema.questionText} (${questionSchema.questionType})`;
          header.style.fontSize = "1rem";
          header.style.marginBottom = "0.5rem";
          header.style.color = "#333";
          container.appendChild(header);
    
    // For text/longtext, display note and do not create a chart.
          if (questionSchema.questionType === "text" || questionSchema.questionType === "longtext") {
            const note = document.createElement("p");
            note.textContent = i18n_local[currentLang].textAnswerSummaryNote;
            note.style.fontStyle = "italic";
            note.style.color = "#666";
            container.appendChild(note);
            content.appendChild(container);
            return;
          }
    
    // Create a canvas element for the chart.
          const canvas = document.createElement("canvas");
          canvas.id = "chart_" + questionSchema.id;
          canvas.style.width = "100%";
          canvas.style.height = "200px";
          canvas.style.marginBottom = "0.5rem";
          container.appendChild(canvas);
    
    // Delay chart creation to ensure canvas is in the DOM.
          setTimeout(() => {
            new Chart(canvas, {
              type: 'bar',
              data: {
                labels: labels,
                datasets: [{
                  label: questionSchema.questionText,
                  data: dataCounts,
                  backgroundColor: backgroundColors.slice(0, labels.length),
                  borderColor: borderColors.slice(0, labels.length),
                  borderWidth: 1
                }]
              },
              options: {
                responsive: false,
                maintainAspectRatio: false,
                scales: {
                  y: {
                    beginAtZero: true,
                    ticks: { precision: 0 },
                    title: {
                      display: true,
                      text: "回應數量",
                      font: { size: 14, weight: 'bold' }
                    }
                  },
                  x: {
                    title: {
                      display: true,
                      text: "選項",
                      font: { size: 14, weight: 'bold' }
                    }
                  }
                },
                plugins: { legend: { display: false } }
              }
            });
          }, 100);
    
    // For stars questions, also calculate and display the average rating.
          if (questionSchema.questionType === "stars") {
            const total = summary.answers.reduce((sum, ans) => sum + Number(ans), 0);
            const avg = summary.answers.length ? total / summary.answers.length : 0;
            const avgP = document.createElement("p");
            avgP.style.fontWeight = "bold";
            avgP.style.color = "#00796b";
            avgP.textContent = `平均評分: ${avg.toFixed(2)} （共 ${summary.answers.length} 筆回應）`;
            container.appendChild(avgP);
          } else if (questionSchema.questionType === "radio" ||
                     questionSchema.questionType === "checkbox" ||
                     questionSchema.questionType === "date") {
      // Display frequency list below the chart.
            const list = document.createElement("ul");
            list.style.listStyleType = "none";
            list.style.paddingLeft = "0";
            labels.forEach(label => {
              const li = document.createElement("li");
              li.textContent = `${label}: ${dataCounts[labels.indexOf(label)]} 筆`;
              li.style.padding = "0.25rem 0";
              list.appendChild(li);
            });
            container.appendChild(list);
          }
          content.appendChild(container);
        }
      }



// Functions to open and close the full-page overlay.
      function openSurveyDataPage() {
        const page = document.getElementById("surveyDataPage");
        page.classList.add("active");
      }

      function closeSurveyDataPage() {
        const page = document.getElementById("surveyDataPage");
        page.classList.remove("active");
      }

// Function to fetch the user's channels and populate the dropdown.
      async function fetchChannelList() {
        try {
    // Send a POST request to list channels for the current user.
          const response = await fetch(`${BASE_URL}/api/list-admin`, {
            method: 'POST',
            headers: {
              "Content-Type": "application/json",
              "Authorization": "Bearer " + currentUserToken,
              "X-User-Id": currentUserId
            },
            body: JSON.stringify({ userId: currentUserId })
          });
          const data = await response.json();
    // If there is an error in the response, handle it.
          if (data.error) {
            M.toast({ html: data.error, displayLength: 2000 });
            return;
          }
          const selectElem = document.getElementById("channel-select");
    // Clear any previous options (except the default one).
          selectElem.innerHTML = `<option value="">-- 選擇頻道 --</option>`;
    
    // Populate the dropdown with channels. Assume each channel object has channelId and channelDescription.
          data.channels.forEach(channel => {
            const option = document.createElement("option");
            option.value = channel.channelId;
            option.textContent = channel.channelDescription || channel.channelId;
            selectElem.appendChild(option);
          });
    // Reinitialize the Materialize select to update the dropdown UI
          M.FormSelect.init(document.querySelectorAll('#channel-select'));
        } catch (error) {
          console.error("Error fetching channels:", error);
          M.toast({ html: "無法取得頻道清單", displayLength: 2000 });
        }
      }

      /*******************************************
 * Survey Event trigger funtions 
 */
let currentTriggers = [];

      async function showEventTriggers() {
  // Open the modal
        const modal = M.Modal.getInstance(document.getElementById('eventTriggersModal'));
        modal.open();

  // Load triggers if we have a survey selected
        if (CurrentSurveySchemaId) {
          try {
            const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}/triggers`);
            currentTriggers = await response.json();
            renderTriggersList();
          } catch (error) {
            console.error('Error loading triggers:', error);
      M.toast({ html: 'Failed to load triggers', classes: 'red' });
          }
        }
      }

      function renderTriggersList() {
        const container = document.getElementById('triggersList');
        container.innerHTML = "";
        currentTriggers.forEach(trigger => {
          const cardPanel = document.createElement("div");
          cardPanel.className = "card-panel";
    
    // Create a header container that always shows Title and Type
          const headerContainer = document.createElement("div");
          headerContainer.className = "trigger-header";
          const header = document.createElement("h6");
          header.textContent = trigger.name;
          headerContainer.appendChild(header);
    
          const typePara = document.createElement("p");
    typePara.textContent = "類型: " + trigger.conditionType;
          headerContainer.appendChild(typePara);
    
          cardPanel.appendChild(headerContainer);
    
    // Create a container for the script content
          const scriptContainer = document.createElement("div");
          scriptContainer.className = "trigger-script";
          const scriptPre = document.createElement("pre");
          scriptPre.textContent = trigger.script;
          scriptPre.style.maxHeight = "200px";
          scriptPre.style.overflowY = "auto";
          scriptPre.style.whiteSpace = "pre-wrap";
          scriptPre.style.wordBreak = "break-word";
          scriptPre.style.cursor = "pointer";
    // Allow user to toggle expansion if needed
          scriptPre.addEventListener("click", function() {
            scriptPre.style.maxHeight = scriptPre.style.maxHeight === "none" ? "200px" : "none";
          });
          scriptContainer.appendChild(scriptPre);
          cardPanel.appendChild(scriptContainer);
    
    // Button container for Delete and Edit buttons
          const buttonContainer = document.createElement("div");
          buttonContainer.style.display = "flex";
          buttonContainer.style.gap = "10px";
          buttonContainer.style.marginTop = "10px";
    
    // Delete button
          const deleteButton = document.createElement("button");
          deleteButton.className = "btn red";
          deleteButton.textContent = i18n_local[currentLang].deleteTriggerButton;
          deleteButton.onclick = () => deleteTrigger(trigger._id);
          buttonContainer.appendChild(deleteButton);
    
    // Edit button
          const editButton = document.createElement("button");
          editButton.className = "btn blue";
          editButton.textContent = i18n_local[currentLang].editTriggerButton;
          buttonContainer.appendChild(editButton);
    
    // When user clicks Edit, only replace the script container with an Ace editor.
          editButton.onclick = () => {
      // Create a new div to host the Ace editor
            const editorDiv = document.createElement("div");
            editorDiv.style.width = "100%";
            editorDiv.style.height = "400px";
      // Replace script container's content with the editor div
            scriptContainer.innerHTML = "";
            scriptContainer.appendChild(editorDiv);
      
      // Initialize Ace on the new div
            const editor = ace.edit(editorDiv);
            editor.setTheme("ace/theme/monokai");
            editor.session.setMode("ace/mode/javascript");
            editor.session.setOption("useWorker", true);
            editor.setOptions({ fontSize: "12pt", showPrintMargin: false });
            editor.setValue(trigger.script, -1);
      
      // Remove the Edit button from the button container
            buttonContainer.removeChild(editButton);
      
      // Create Save and Cancel buttons
            const saveButton = document.createElement("button");
            saveButton.className = "btn green";
            saveButton.textContent = i18n_local[currentLang].saveTriggerButton;
            const cancelButton = document.createElement("button");
            cancelButton.className = "btn grey";
            cancelButton.textContent = i18n_local[currentLang].cancel;
            buttonContainer.appendChild(saveButton);
            buttonContainer.appendChild(cancelButton);
      
      // Save button: update the trigger's script and revert back to static view
            saveButton.onclick = async () => {
              const updatedScript = editor.getValue();
              // Create an updated trigger object that includes the full data
              const updatedTrigger = {
                name: trigger.name,
                conditionType: trigger.conditionType, // "starThreshold", "answerMatch", or "timeBased"
                parameters: trigger.parameters,         // retain existing parameters
                script: updatedScript
              };
              try {
                const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}/triggers/${trigger._id}`, {
                  method: 'PUT',
                  headers: { 
                    "Content-Type": "application/json",
                    Authorization: "Bearer " + currentUserToken,
                    "X-User-Id": currentUserId
                  },
                  body: JSON.stringify(updatedTrigger)
                });
                const result = await response.json();
                if (response.ok) {
            // Update local trigger data and revert scriptContainer to a <pre> view
                  trigger.script = updatedScript;
                  const newPre = document.createElement("pre");
                  newPre.textContent = updatedScript;
                  newPre.style.maxHeight = "200px";
                  newPre.style.overflowY = "auto";
                  newPre.style.whiteSpace = "pre-wrap";
                  newPre.style.wordBreak = "break-word";
                  newPre.style.cursor = "pointer";
                  newPre.addEventListener("click", function() {
                    newPre.style.maxHeight = newPre.style.maxHeight === "none" ? "200px" : "none";
                  });
                  scriptContainer.innerHTML = "";
                  scriptContainer.appendChild(newPre);
            
            // Remove Save and Cancel buttons, add back the Edit button
                  buttonContainer.removeChild(saveButton);
                  buttonContainer.removeChild(cancelButton);
                  buttonContainer.appendChild(editButton);
                } else {
                  M.toast({ html: result.error || "儲存腳本失敗", displayLength: 2000 });
                }
              } catch (err) {
                console.error(err);
                M.toast({ html: "儲存腳本時發生錯誤", displayLength: 2000 });
              }
            };
      
      // Cancel button: discard changes and revert to the original script view
            cancelButton.onclick = () => {
        // Restore the original <pre> element
              scriptContainer.innerHTML = "";
              scriptContainer.appendChild(scriptPre);
        // Remove Save and Cancel buttons, add back the Edit button
              buttonContainer.removeChild(saveButton);
              buttonContainer.removeChild(cancelButton);
              buttonContainer.appendChild(editButton);
            };
          };
          cardPanel.appendChild(buttonContainer);
          container.appendChild(cardPanel);
        });
      }

      async function deleteTrigger(triggerId) {
        const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}/triggers/${triggerId}`, {
          method: 'DELETE',
          headers: { "Content-Type": "application/json" , Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
          body: JSON.stringify({})
        });
        let result = await response.json();
        if (result?.success){
          currentTriggers = currentTriggers.filter(item => item._id !== triggerId);
        }
        renderTriggersList();
      }

      async function saveNewTrigger() {
        const type = document.getElementById('triggerType').value;
        let script, params = {};
        if (type === 'starThreshold') {
          params = {
            threshold: parseFloat(document.getElementById('starThreshold').value),
            count: parseInt(document.getElementById('starCount').value, 10)
          };
          script = generateStarThresholdScript(params);
        } else if (type === 'answerMatch') {
          const targetAnswerElem = document.getElementById('targetAnswer');
          const selectedAnswers = Array.from(targetAnswerElem.selectedOptions).map(opt => opt.value);
          params = {
            questionId: document.getElementById('targetQuestion').value,
            answer: selectedAnswers
          };
          script = generateAnswerMatchScript(params);
        }
        const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}/triggers`, {
          method: 'POST',
          headers: { "Content-Type": "application/json", Authorization: "Bearer " + currentUserToken, "X-User-Id": currentUserId},
          body: JSON.stringify({
            name: `Trigger ${currentTriggers.length + 1}`,
            conditionType: type,
            parameters: params,
            script: script
          })
        });
        currentTriggers = await response.json();
        cancelNewTrigger();
        renderTriggersList();
      }

      function showNewTriggerForm() {
  // Hide the triggers list
        document.getElementById("triggersList").classList.add("hideTriggerList");
  
  // Show the new trigger form
        document.getElementById("newTriggerForm").style.display = "block";
  
  // Hide the "Add New Trigger" button (assumed to be the blue button in the modal footer)
        const addTriggerBtn = document.querySelector("#eventTriggersModal .modal-footer .btn.blue");
        if (addTriggerBtn) {
          addTriggerBtn.style.display = "none";
        }
      }

      function cancelNewTrigger() {
  // Hide the new trigger form
        document.getElementById("newTriggerForm").style.display = "none";
  
  // Show the triggers list again
        document.getElementById("triggersList").classList.remove("hideTriggerList");
  
  // Show back the "Add New Trigger" button
        const addTriggerBtn = document.querySelector("#eventTriggersModal .modal-footer .btn.blue");
        if (addTriggerBtn) {
          addTriggerBtn.style.display = "";
        }
      }

      function generateStarThresholdScript(params) {
        if (currentLang === 'zh-TW') {
          return `
    const threshold = ${params.threshold};
    const requiredCount = ${params.count};

    (function() {
      return async function checkCondition(surveyData) {
        // 篩選出所有星級評分題，其回答低於設定的 threshold
        const lowRatedQuestions = surveyData.data.filter(q => 
          q.questionType === 'stars' && Number(q.answer) < threshold
        );
        if (lowRatedQuestions.length >= requiredCount) {
          // 收集觸發條件的題目文字
          const triggeredQuestions = lowRatedQuestions.map(q => q.question).join('、');
          return \`觸發條件達成：共有 \${lowRatedQuestions.length} 題星級評分題的回答低於 \${threshold} 星。觸發題目：\${triggeredQuestions}。原因：這些題目的評分均低於設定的 \${threshold} 星。\`;
        }
        return null;
      };
    })();
  `;
        } else if (currentLang === 'ja-JP') {
          return `
    const threshold = ${params.threshold};
    const requiredCount = ${params.count};

    (function() {
      return async function checkCondition(surveyData) {
        const lowRatedQuestions = surveyData.data.filter(q => 
          q.questionType === 'stars' && Number(q.answer) < threshold
        );
        if (lowRatedQuestions.length >= requiredCount) {
          const triggeredQuestions = lowRatedQuestions.map(q => q.question).join('、');
          return \`条件が満たされました：\${lowRatedQuestions.length} 件の星評価の質問の回答が \${threshold} 星未満です。対象の質問: \${triggeredQuestions}。理由: これらの質問の評価はすべて設定された \${threshold} 星未満です。\`;
        }
        return null;
      };
    })();
  `;
        } else {
          return `
    const threshold = ${params.threshold};
    const requiredCount = ${params.count};

    (function() {
      return async function checkCondition(surveyData) {
        const lowRatedQuestions = surveyData.data.filter(q => 
          q.questionType === 'stars' && Number(q.answer) < threshold
        );
        if (lowRatedQuestions.length >= requiredCount) {
          const triggeredQuestions = lowRatedQuestions.map(q => q.question).join(', ');
          return \`Condition met: There are \${lowRatedQuestions.length} star rating questions with answers below \${threshold} stars. Triggered questions: \${triggeredQuestions}. Reason: All these questions have ratings below the set threshold of \${threshold} stars.\`;
        }
        return null;
      };
    })();
  `;
        }
      }

      function generateAnswerMatchScript(params) {
        if (currentLang === 'zh-TW') {
          return `
    (function() {
      async function checkCondition(surveyData) {
        // 直接使用傳入的預期答案陣列
        const expectedAnswers = ${JSON.stringify(params.answer)};
        
        // 透過比較 questionId（轉為數字）尋找目標問題
        const targetQuestion = surveyData.data.find(q => q.questionId === Number('${params.questionId}'));
        if (targetQuestion) {
          let answer = targetQuestion.answer;
          // 如果答案不是陣列，則轉換為陣列
          if (!Array.isArray(answer)) {
            answer = [answer];
          }
          
          // 檢查答案中是否有符合任一預期答案
          const matched = expectedAnswers.some(expected => answer.includes(expected));
          if (matched) {
            return \`觸發條件達成：問題「\${targetQuestion.question}」的回答（\${answer.join(', ')}）包含預期選項（\${expectedAnswers.join(', ')}）。原因：該回答符合預期的答案條件。\`;
          }
        }
        return null;
      }
      return checkCondition;
    })();
  `;
        } else if (currentLang === 'ja-JP') {
          return `
    (function() {
      async function checkCondition(surveyData) {
        const expectedAnswers = ${JSON.stringify(params.answer)};
        const targetQuestion = surveyData.data.find(q => q.questionId === Number('${params.questionId}'));
        if (targetQuestion) {
          let answer = targetQuestion.answer;
          if (!Array.isArray(answer)) {
            answer = [answer];
          }
          const matched = expectedAnswers.some(expected => answer.includes(expected));
          if (matched) {
            return \`条件が満たされました：質問「\${targetQuestion.question}」の回答（\${answer.join(', ')}）に、予想される選択肢（\${expectedAnswers.join(', ')}）が含まれています。理由：その回答は期待される条件を満たしています。\`;
          }
        }
        return null;
      }
      return checkCondition;
    })();
  `;
        } else {
          return `
    (function() {
      async function checkCondition(surveyData) {
        const expectedAnswers = ${JSON.stringify(params.answer)};
        const targetQuestion = surveyData.data.find(q => q.questionId === Number('${params.questionId}'));
        if (targetQuestion) {
          let answer = targetQuestion.answer;
          if (!Array.isArray(answer)) {
            answer = [answer];
          }
          const matched = expectedAnswers.some(expected => answer.includes(expected));
          if (matched) {
            return \`Condition met: The answer for question "\${targetQuestion.question}" (\${answer.join(', ')}) contains the expected option(s) (\${expectedAnswers.join(', ')}). Reason: The answer meets the expected criteria.\`;
          }
        }
        return null;
      }
      return checkCondition;
    })();
  `;
        }
      }

      function loadTriggerConfig() {
  // Clear previous config
        const configContainer = document.getElementById('triggerConfig');
        configContainer.innerHTML = '';

  // Add configuration panels for each trigger type (your existing code)...
        const triggerTypes = {
          starThreshold: `
      <div class="row">
        <div class="input-field col s6">
          <input type="number" id="starThreshold" step="0.1" min="1">
          <label for="starThreshold">${i18n_local[currentLang].starThresholdLabel}</label>
        </div>
        <div class="input-field col s6">
          <input type="number" id="starCount" min="1">
          <label for="starCount">${i18n_local[currentLang].starCountLabel}</label>
        </div>
      </div>
    `,
          answerMatch: `
      <div class="row">
        <div class="input-field col s6">
          <select id="targetQuestion">
            <!-- Options will be populated via JS -->
          </select>
          <label>${i18n_local[currentLang].targetQuestionLabel}</label>
        </div>
        <div class="input-field col s6">
          <select id="targetAnswer" multiple>
            <!-- Options will be populated via JS -->
          </select>
          <label>${i18n_local[currentLang].expectedAnswerLabel}</label>
        </div>
      </div>
    `,
          timeBased: `
      <div class="row">
        <div class="input-field col s6">
          <input type="number" id="timeWindow" min="1">
          <label>${i18n_local[currentLang].timeWindowLabel}</label>
        </div>
        <div class="input-field col s6">
          <input type="number" id="minimumCount">
          <label>${i18n_local[currentLang].minimumCountLabel}</label>
        </div>
      </div>
    `
        };
        for (const [type, html] of Object.entries(triggerTypes)) {
          const div = document.createElement("div");
          div.className = "trigger-config";
          div.dataset.type = type;
          div.style.display = "none";
          div.innerHTML = html;
          configContainer.appendChild(div);
        }

  // Initialize Materialize components
        M.FormSelect.init(document.querySelectorAll('select'));
        M.updateTextFields();
      }


// Add this to handle trigger type changes
      document.getElementById('triggerType').addEventListener('change', function() {
        const selectedType = this.value;
        const configPanels = document.querySelectorAll('.trigger-config');
        configPanels.forEach(panel => {
          panel.style.display = panel.dataset.type === selectedType ? 'block' : 'none';
        });
        if (selectedType === 'answerMatch') {
          populateQuestionSelect();
    // Add listener so that when the selected question changes, the answers get updated
          document.getElementById('targetQuestion').addEventListener('change', populateExpectedAnswerSelect);
        }
      });

      async function populateQuestionSelect() {
        const select = document.getElementById('targetQuestion');
        select.innerHTML = `<option value="" disabled selected>${i18n_local[currentLang].selectQuestion}</option>`;
        if (CurrentSurveySchemaId) {
          try {
            const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}`);
            const survey = await response.json();
            survey.surveyItems.forEach(item => {
              if (item.type === 'question') {
                const option = document.createElement('option');
                option.value = item.id;
                option.textContent = item.questionText || `Question ${item.id}`;
                select.appendChild(option);
              }
            });
            M.FormSelect.init(select);
          } catch (error) {
            console.error('Error loading questions:', error);
            M.toast({ html: 'Failed to load questions', classes: 'red' });
          }
        }
  // When the question is changed, update the expected answers
        select.addEventListener('change', populateExpectedAnswerSelect);
      }

      function populateExpectedAnswerSelectElement(options) {
        const selectElem = document.getElementById('targetAnswer');
        selectElem.innerHTML = '';
        options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt;
          option.textContent = opt;
          selectElem.appendChild(option);
        });
        M.FormSelect.init(selectElem);
      }

      async function populateExpectedAnswerSelect() {
        const targetQuestionSelect = document.getElementById('targetQuestion');
        const selectedQuestionId = targetQuestionSelect.value;
        if (!selectedQuestionId) return;
        try {
          const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}`);
          const survey = await response.json();
          let question;
    // Search for the matching question (either standalone or in a group)
          survey.surveyItems.forEach(item => {
            if (item.type === 'question' && item.id == selectedQuestionId) {
              question = item;
            } else if (item.type === 'group' && Array.isArray(item.subQuestions)) {
              item.subQuestions.forEach(subq => {
                if (subq.id == selectedQuestionId) {
                  question = subq;
                }
              });
            }
          });
          if (question) {
            let options = [];
            if (question.questionType === 'radio' || question.questionType === 'checkbox') {
              options = (question.options || []).map(opt =>
                typeof opt === 'object' ? opt.text : opt
              );
            } else if (question.questionType === 'stars') {
              const maxStars = question.maxStars || 5;
              for (let i = 1; i <= maxStars; i++) {
                options.push(i.toString());
              }
            }
            populateExpectedAnswerSelectElement(options);
          }
        } catch (error) {
          console.error("Error populating expected answer select:", error);
        }
      }

      /***********************************************
       * VOICE recognition
       ***********************************************/

// Global variables for voice recognition insertion tracking
      let isListening = false;
      let recognition = null;
let insertionPoint = null;     // The starting index where recognized text is inserted
let lastInsertedLength = 0;    // How many characters of interim text have been inserted
let keyInserted = false;       // Indicate key is inserting, so that the recog result should be skip
      let rec;
// Helper to create a new SpeechRecognition instance
      function createRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          alert("Speech recognition is not supported in this browser.");
          return null;
        }
        rec = new SpeechRecognition();
  rec.continuous = true;       // Keep listening until manually stopped
  rec.interimResults = true;   // Get interim (partial) results
  rec.lang = currentLang || 'en-US';          // Adjust as needed

        document.getElementById("start-voice-btn").classList.add("recording-btn");
// Global variable to track the current interim string
        let currentInterim = "";

        rec.onresult = (event) => {
          const descInput = document.getElementById("survey-description-input");
          if (insertionPoint === null) {
            insertionPoint = descInput.selectionStart;
            lastInsertedLength = 0;
            currentInterim = "";
          }
  
  // Use only the last result from the event
          let result = event.results[event.results.length - 1];
          let transcript = result[0].transcript;
  
  //console.log(result);
  
  // If the result is not final and the new transcript is a partial (i.e. a prefix)
  // of the previously inserted interim, then skip updating the display.
          if (!result.isFinal && currentInterim && (currentInterim.indexOf(transcript)>=0 || currentInterim.length > transcript.length)  ) {
            console.log("repeat");
            return;
          }
          if (keyInserted) {
            console.log("interrupt");
            if (result.isFinal) {		
              lastInsertedLength = 0;
              currentInterim = "";
            }
            return;
          } 
          console.log(keyInserted, transcript);
  
  // Remove the previously inserted interim text from the textarea:
          let currentVal = descInput.value;
          let before = currentVal.substring(0, insertionPoint);
          let after = currentVal.substring(insertionPoint + lastInsertedLength);

  // Insert the new transcript
          descInput.value = before + transcript + after;
  
  // Move the cursor to the end of the newly inserted text
          const newCursorPos = insertionPoint + transcript.length;
          descInput.setSelectionRange(newCursorPos, newCursorPos);
          descInput.focus();
  
	
  
  // Update lastInsertedLength and currentInterim
          lastInsertedLength = transcript.length;
          currentInterim = transcript;
  
  // If the result is final, finalize the insertion:
          if (result.isFinal) {
    // Advance the insertion point so that future speech is appended at the end of this text.
            insertionPoint += transcript.length;
            lastInsertedLength = 0;
            currentInterim = "";
	
	// trigger the button 
	// Manually dispatch an "input" event so the listener fires
            const event = new Event("input", { bubbles: true, cancelable: true });
            descInput.dispatchEvent(event);
          }
        };
        rec.onerror = (event) => {
          console.error("Speech recognition error:", event.error);
          try {
            rec.stop();
          } catch(e) {}
        };
        rec.onend = () => {
    // Reset variables when recognition ends
          isListening = false;
          recognition = null;
          insertionPoint = null;
          lastInsertedLength = 0;
          if (keyInserted) {
            rec.start();
            isListening = true;
            keyInserted = false;
            return;
          }
          document.getElementById("start-voice-btn").innerHTML = '<i class="material-icons">mic</i>';
          document.getElementById("start-voice-btn").classList.remove("recording-btn");
        };
        return rec;
      }

// Add event listeners to update the insertion point if user manually changes the cursor
      const descInput = document.getElementById("survey-description-input");
      descInput.addEventListener("click", () => {
        if (isListening) {
          insertionPoint = descInput.selectionStart;
          lastInsertedLength = 0;
        }
      });
      descInput.addEventListener("keyup", () => {
        if (isListening) {
          insertionPoint = descInput.selectionStart;
          lastInsertedLength = 0;
	keyInserted = true; // indicate we should break the recognition for 200ms
          rec.stop();
        }
      });

// Handle voice button clicks
      document.getElementById("start-voice-btn").addEventListener("click", () => {
        if (!isListening) {
    // Start recognition: create a new instance and record the current cursor position
          recognition = createRecognition();
          if (!recognition) return;
          insertionPoint = descInput.selectionStart;
          lastInsertedLength = 0;
          try {
            recognition.start();
            isListening = true;
            document.getElementById("start-voice-btn").innerHTML = '<i class="material-icons">mic_off</i>';
          } catch (err) {
            console.error("Error starting speech recognition:", err);
          }
        } else {
          try {
            recognition.stop();
      // onend handler will reset state
          } catch (err) {
            console.error("Error stopping speech recognition:", err);
          }
        }
      });

// Also stop recognition if the user clicks the "Generate Survey Schema" button
      document.getElementById("generate-survey-schema-btn").addEventListener("click", () => {
        if (isListening && recognition) {
          try {
            recognition.stop();
          } catch (err) {
            console.error("Error stopping speech recognition:", err);
          }
        }
  // Continue with your generate logic here...
      });
    </script>
  </body>
</html>
