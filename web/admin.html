<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Survey Admin with Multi-Language Support</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Material Icons and Materialize CSS -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
    />

    <style>
/* Base resets */
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
}
main {
        margin-top: 0px;
}
.navbar-fixed {
  z-index: 1000;
}
body.no-scroll {
  overflow: hidden;
}

      /**********************************************
       * NAV BAR
       **********************************************/		
#nav-title {
		  font-size: 1.1rem; /* default size */
		  cursor: pointer;
  display: inline-block;
  max-width: 70%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.truncated {
      display: inline-block;  /* Allows width to be applied */
      width: 50vw;             /* Sets a fixed width relative to the parent */
      white-space: nowrap;    /* Keeps the text on a single line */
      overflow: hidden;       /* Hides overflow text */
      text-overflow: ellipsis;/* Displays an ellipsis for overflow */
      margin-left:5px;
}



      /**********************************************
       * MAIN CONTENT
       **********************************************/
#main-content {
        margin-left: 500px; /* On desktop, push right for sidebar */
        transition: margin-left 0.3s ease;
  padding: 0 20px;
}
      /* This class forcibly sets margin-left to 0 */
#main-content.no-sidebar {
  margin-left: 0 !important;
        transition: margin-left 0.3s ease;
}

/* GROUP CARD STYLING */
.group-card {
  border-left: 4px solid #2196F3 !important;
  margin-top: 1.5rem;
}

.group-title-header {
  background-color: #e3f2fd;
  padding: 1rem;
  margin: -1rem -1rem 1rem -1rem;
  border-radius: 4px 4px 0 0;
}

.group-title-header label {
  color: #0d47a1 !important;
  font-size: 1.1rem !important;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.group-title-input {
  font-size: 1.2rem !important;
  font-weight: 600 !important;
  border-bottom: 2px solid #2196F3 !important;
  padding: 0.5rem 0 !important;
}

.group-title-input:focus {
  border-bottom: 2px solid #1565C0 !important;
  box-shadow: 0 1px 0 0 #1565C0 !important;
}

/* Add some spacing between groups */
.group-card + .group-card {
  margin-top: 2rem;
}


/* Card highlight effect */
/* Card highlight effect */
.question-card.highlighted,
.group-card.highlighted {
  box-shadow: 0 0 12px #ffa50087;
  border: 4px solid orange !important;
  transform: scale(1.02);
  transition: all 0.3s ease;
}


/**********************************************
  * SIDEBAR
  **********************************************/



  /* 讓整個列表都能垂直滑動 */
#sidebar,
#questions-list {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;  /* iOS 平滑滾動 */
  direction: ltr;
  overscroll-behavior: contain;
  overscroll-behavior-y: contain;
}

/* 清除原本 collection-item 的 touch-action:none */
#questions-list .collection-item {
  touch-action: pan-y;       /* 只阻擋水平方向，允許垂直捲動 */
  pointer-events: auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* 把手區域才能攔截手勢，開始拖曳 */
#questions-list .drag-handle {
  cursor: grab;
  touch-action: none;                /* 禁用滑動，以便啟動拖曳 */
  padding: 0 8px;
  user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;  
}
#questions-list .drag-handle:active {
  cursor: grabbing;
}
     
	/* Force the sidebar to always show a scrollbar and display it on the left */
#sidebar {
  position: fixed;
  top: 64px;
  left: 0;
  width: 500px;
  height: calc(100% - 64px);
	  overflow-y: scroll;              /* Always show scrollbar */
	  -webkit-overflow-scrolling: touch;
  transition: transform 0.3s ease;
  z-index: 999;
	  background: white;
	  box-shadow: 0 0 12px 0px;
	  direction: rtl;                  /* Force scrollbar to the left */
	}

	/* Reset the direction for inner content so that text is left-to-right */
	

#sidebar.collapsed {
  transform: translateX(-110%);
}
  
	  
      #questions-list .collection-item:active {
        cursor: grabbing;
      }
      #questions-list .collection-item:hover {
        background-color: #e0e0e0;
      }

      /* A small circle to display question (or group) index number */
      .list-index-circle {
        display: inline-block;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        line-height: 24px;
        text-align: center;
        background-color: #2196f3;
        color: #fff;
        margin-right: 8px;
        font-size: 14px;
      }

		/* Default (desktop): no gutter */
#sidebar.with-gutter {
		  position: fixed;
		  top: 64px;
		  left: 0;
  width: 500px;
		  height: calc(100% - 64px);
		  overflow-y: scroll;
		  -webkit-overflow-scrolling: touch;
		  background: white;
		  box-shadow: 0 0 12px 0px;
}
#sidebar.with-gutter .scroll-gutter {
  display: none;
}
#sidebar.with-gutter #questions-list {
  margin-left: 0;
}

    .group-index-circle {
      background-color: #ff9800; /* Distinct color for groups */
      border-radius: 4px;        /* Square with slightly rounded corners */
	  color: black;
}

/* 讓編號圓圈（list-index-circle / group-index-circle）維持固定大小，不會被壓縮或撐開 */
#questions-list .list-index-circle,
#questions-list .group-index-circle {
  flex: 0 0 auto;
}


    /* 確保 fallback clone 跟 .collection-item 完全相同 */
.sortable-fallback {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;            /* 撐滿側邊欄 */
  padding: 0 16px;        /* 跟 .collection-item 預設 padding 一致 */
  background: #fff;       /* 跟列表項一致的背景 */
  box-shadow: none;       /* 如果正常項目沒 shadow，就去掉 */
  /* 如果你有其他像 font-size、line-height 等 custom style，也一起寫進來 */
}


/* ────── 頂層項目 (問題 & 群組) ────── */
/* 文字靠左，拖拉把手 (handle) 靠右 */
#questions-list .collection-item[data-type="top"] {
  justify-content: flex-start;    /* 先排 index circle + 文字，最後 handle */
}
#questions-list .collection-item[data-type="top"] .drag-handle {
  margin-left: auto;              /* 把 handle 推到最右邊 */
}
#questions-list .collection-item[data-type="top"] span:nth-child(2) {
  text-align: left;               /* 文字靠左 */
  color: #000;                    /* 可自訂頂層文字顏色 */
}

#questions-list .collection-item[data-type="top"] {
  padding-left: 8px;
}
#questions-list .collection-item.is-group-item {
  padding-left: 20px;
}

/* ────── 子題 (sub-questions) ────── */
/* 拖拉把手靠左，文字靠右，文字顏色較淡 */
#questions-list .collection-item[data-type="sub"] {
  display: flex;
  justify-content: space-between !important;
  align-items: center;
  color: #888;                  /* 子題文字顏色 */
  padding: 6px 16px;              /* 如同 .sortable-fallback */
}

#questions-list .collection-item[data-type="sub"] .drag-handle {
  margin-left: auto;            /* 把把手推到最右邊 */
  margin-right: 0.2em;
  cursor: grab;
}


#questions-list .collection-item[data-type="sub"] span {
  text-align: left;             /* 文字靠左 */
  margin-right: auto;           /* 讓文字撐滿中間 */
}

/* ────── 群組＋子題連線 ────── */
/* 1) 群組標題（collection-item 中有 .group-index-circle 的那一行）加左邊粗線 */
#questions-list > li.collection-item span.group-index-circle {
  /* 讓整個 li 都被線框影響 */
  position: relative;
}
#questions-list > li.collection-item span.group-index-circle::before {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  left: -12px;           /* 距離圈圈往左 12px */
  width: 4px;            /* 線的粗細 */
  background-color: #2196f3;  /* 你想要的群組色 */
  border-radius: 2px;
}

/* 2) 緊跟在那個群組標題後面的 UL（它的 data-group-index 等於上面 li 的 data-index）也加左邊同一條線 */
#questions-list > li.collection-item + ul[data-group-index] {
  border-left: 4px solid #2196f3; /* 跟前面一樣的顏色與粗細 */
  margin-left: 2.8em;             /* 臨時內縮，讓子題往右一點 */
  padding-left: 1em;              /* 文字不會緊貼線 */
}




/* allow top-level text to wrap on multiple lines */
#questions-list .collection-item[data-type="top"] span:nth-child(2) {
  flex: 1 1 auto;
  min-width: 0;               /* enable shrinking below content width */
  white-space: normal;        /* allow line-breaks */
  overflow-wrap: break-word;  /* break long words if needed */
}

/* allow sub-question text to wrap on multiple lines */
#questions-list .collection-item[data-type="sub"] span {
  white-space: normal;
  overflow-wrap: break-word;
  }



/* Highlight style for sidebar items */
#questions-list .collection-item.highlighted {
  background-color: #e3f2fd;
  border-left: 4px solid #2196F3;
}



 
.collection-placeholder {
	pointer-events: none;
	height : 2em;
	border : 2px dashed #ccc;
	borderRadius : 4px;
	margin : 4px 0 4px 1em;
	width : 85%;
}

/* Hide index circle in the drag ghost preview */
.sortable-ghost .list-index-circle,
.sortable-ghost .group-index-circle {
  visibility: hidden !important;
  width:10px;
}
/* Disable nesting visual when dragging groups */
.sortable-ghost.is-group-item [data-group-index]::before {
  display: none !important;
}


/**********************************************
  * QUESTIONS & STICKY-BOTTOM BUTTONS
  **********************************************/
.question-card { 
  margin-bottom: 20px;
  position: relative;
}
.question-type-select {
  display: block;
  margin-top: 10px;
}
      .question-actions {
  position: absolute;
        background: antiquewhite;
        border: 0px !important;
}

.sticky-bottom {
  position: sticky;
  bottom: 0;
        background-color: #fff;
  z-index: 998;
  padding: 10px 0;
        box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
}

      .sticky-bottom .col.s12 > * {
        margin-bottom: 10px;
      }

      /* Floating action buttons in each question or group. */
      .question-actions, .group-actions {
        position: absolute;
        background: #fafafa;
        border: 0px !important;
        z-index: 100;
      }
      .question-actions button,
      .group-actions button {
        margin-right: 5px;
      }

	  .recording-btn {
		background-color: red !important;
	  }


.sticky-bottom .col.s12 {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* On small screens, hide the text in the Survey Data button, showing only the icon */
@media only screen and (max-width: 600px) {
  #fetch-data-btn span {
    display: none;
}
}

/* Left group remains a flex container */
.left-buttons {
  display: flex;
  gap: 10px;
  margin-right: 1em;
}
.right-buttons {
  display: flex;
  gap: 10px;
}

  /*********************************************
   * event trigger page
   *********************************************/
#triggersList {
  overflow-y: auto;
  transition: max-height 0.5s ease;
}
.hideTriggerList {
  max-height: 0px;
  overflow: hidden;
  transition: max-height 0.5s ease;
}

.height100 {
  height: 100%;
}

.sticky-footer {
  position: sticky;
  bottom: 0;
  background-color: #fff; /* or any background to match the modal */
  z-index: 1000;  /* ensure it stays on top */
  padding: 10px 0;
}

.highlight {
  animation: fadeHighlight 2s ease-out;
}
@keyframes fadeHighlight {
  from { background-color: #fff59d; }
  to   { background-color: transparent; }
}


   /*********************************************
   * summary page
   *********************************************/

    /* Container for survey summaries */
#surveyDataContent {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 1rem;
  padding: 1rem;
  box-sizing: border-box;
}
.full-page-overlay {
  position: fixed;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: #fff;
  overflow-y: auto;
  z-index: 10000;
  transition: left 0.3s ease;
  box-shadow: 2px 0 5px rgba(0,0,0,0.3);
}

    .full-page-overlay.active {
      left: 0;
    }

.page-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #9e9e9e;
  color: #fff;
      box-shadow: 0 0 6px 0px black;
  position: sticky;
  top: 0;
}
    .page-header H5 {
      margin: 0.4em;
    
    }

.close-btn {
  background: transparent;
  border: none;
  color: #fff;
  font-size: 1.2rem;
  cursor: pointer;
  margin-right: 1em;
}

    .page-content {
      padding: 1rem;
    }


  /**********************************************
  * Root Bottom bar
  **********************************************/
.more-select-container {
  position: relative;
      width: 50px;            /* Adjust width as needed */
      height: 40px;           /* Adjust height as needed */
      background-color: white; /* Button background color (blue) */
  border-radius: 4px;
  display: inline-block;
}

    /* Hide the native select UI */
.more-select {
  width: 100%;
  height: 100%;
  opacity: 0;
  position: absolute;
  top: 0;
  left: 0;
  border: none;
      -webkit-appearance: none;
      -moz-appearance: none;
  appearance: none;
  cursor: pointer;
}

    /* Use a pseudo-element to display the more_vert icon */
.more-select-container::before {
  content: 'more_vert';
  font-family: 'Material Icons';
  font-size: 24px;
  line-height: 40px;
  color: #565656;
  text-align: center;
  display: block;
  pointer-events: none;
}
       





    /**********************************************
      * RESPONSIVE
      **********************************************/

  
    /* Mobile devices: add a 40px gutter */
    @media only screen and (max-width: 768px) {

      #nav-title {
        font-size: 1rem; /* smaller font on small devices */
      }  
      #sidebar.with-gutter {
        width: 300px; /* original 300px + 40px for gutter */
      }

    

      #sidebar.with-gutter .scroll-gutter {
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;  /* Instead of height: 100%, use top: 0 and bottom: 0 */
        left: 0;
        width: 0px;

      /* Create a grip/dot pattern using radial gradients */
        background: radial-gradient(circle, #aaa 2px, transparent 2px),
                    radial-gradient(circle, #aaa 2px, transparent 2px);
        background-size: 10px 10px;
        background-position: 0 0, 5px 5px;	
        z-index: 1;
      }
      #sidebar.with-gutter #questions-list {
        margin-left: 0px;
        position: relative;
        z-index: 2;
      }
      #main-content { 
        margin-left: 300px;
        width: 100%; 
      }
      
      .material-icons.left {
        margin-right: 0 !important;
      }  
      
      /* Hide text on some buttons to save space */
      #add-question-text,
      #add-group-text,
      #undo-text,
      #redo-text,
	  #preview-text,
      #fetch-data-text,
      #event-trigger-text,
      #generate-text {
        display: none !important;
      }
      .sticky-bottom i.left {
        margin-right: 0px;
      }
   
    }		    
  
    @media only screen and (min-width: 1200px) {
      /* Increase the sidebar width for large screens */
      #sidebar {
      width: 500px; /* Adjust to your desired width */
      }
      /* Update main content margin to match the new sidebar width */
      #main-content {
      margin-left: 500px;
      }
    }


		@keyframes highlightFade {
		  0% { background-color: lightgrey; } /* blue highlight */
		  100% { background-color: transparent; }
		}

		.highlight-new {
		  animation: highlightFade 0.5s ease-out;
		}
		
		@keyframes slideIn {
		  0% { transform: translateX(150px); opacity: 0; }  /* Start off-screen */
		  100% { transform: translateX(0); opacity: 1; }  /* End at normal position */
		}

		.slide-in {
		  animation: slideIn 0.6s ease-out;
		}
		
		

		
     /**********************************************
       * Utility
       **********************************************/

      /* Full-page overlay spinner */
      #loadingSpinner {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.8); /* semi-transparent overlay */
        z-index: 10000;  /* make sure it's above all other elements */
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: all;  /* ensures clicks are intercepted */
      }

      /* Optional: Style for the spinner wrapper if needed */
      .spinner-wrapper {
        text-align: center;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .spinner {
        font-size: 2em;
        animation: spin 1s linear infinite;
      }

      .loading-text {
        font-size: 2em;
        margin-left: 0.5em; /* Optional spacing */
      }
		
	/***********************	
	*  Survey select list
	************************/
	
	#importSurveyBtn, #exportSurveyBtn {
	  border: 1px solid #ddd;
	  border-radius: 4px;
	  padding: 0 1rem;
	  transition: all 0.3s ease;
	}

	#importSurveyBtn:hover, #exportSurveyBtn:hover {
	  background-color: rgba(0,0,0,0.1);
	}	     


	/* In the style section */
	#surveyList .collection-item.teal {
		border-left: 4px solid #009688;
	}

	#surveyList .collection-item i.right {
		margin-left: 10px;
	}

	#exportSurveyBtn:disabled {
		background-color: #dfdfdf !important;
		color: #666 !important;
		cursor: not-allowed;
	}	
	
	
	
	/***********************	
	*  Preview Frame
	************************/
	#preview-modal.modal {
	  top: 0 !important;               /* pin to top of screen */
	  right: 0 !important;             /* pin to right edge */
	  left: 0 !important;              /* pin to left edge */
	  width: 100% !important;          /* full width */
	  height: 100% !important;         /* full height */
	  max-height: none !important;     /* disable Materialize’s max-height cap */
	  overflow: hidden !important;     /* hide any overflow on the container */
	}

	/* 2. Make the content area occupy all of the modal (minus the footer) */
	#preview-modal .modal-content {
	  position: absolute;
	  top: 0;
	  left: 0;
	  right: 0;
	  bottom: 56px;            /* adjust if your footer is taller/shorter */
	  padding: 0 !important;   /* remove default padding */
	  overflow: hidden;        /* hide scrollbars inside the content area */
	}

	/* 3. Ensure the footer stays pinned at the bottom */
	#preview-modal .modal-footer {
	  position: absolute;
	  left: 0;
	  right: 0;
	  bottom: 0;
	  z-index: 10;
	  padding: 0.5rem 1rem;
	}

	/* 4. Have the iframe fill its parent exactly */
	#preview-frame {
	  width: 100%;
	  height: 100%;
	  border: none;
	}


    </style>
  </head>

  <body class="grey lighten-4">
  
  	<!-- Spinner element -->
	  <div class="loading-container" id="loadingSpinner" style="display:none;">
		<div class="spinner-wrapper">
			<span class="material-icons spinner">refresh</span>
			<!-- The spinner text will be updated via setLanguage -->
			<span class="loading-text">Processing, please wait ...</span>
		</div>
	  </div>

	<!-- Materialize Modal for Store Selection -->
   
	<div id="selectStore" class="modal">
	  <div class="modal-content">
		<h4><!-- Title will be updated via setLanguage --></h4>
		<div id="storeOptions">
		  <!-- Store options will be dynamically added here -->
		</div>
	  </div>
	  <div class="modal-footer">
		<a href="#!" class="modal-close btn-flat" onclick="confirmSelection()"><!-- Confirm text will be updated via setLanguage --></a>
		<a href="#!" class="modal-close btn-flat"><!-- Cancel text will be updated via setLanguage --></a>
	  </div>
	</div>
  
	<!-- FIXED NAV WRAPPER -->
    <div class="navbar-fixed">
      <nav class="blue">
		  <div class="nav-wrapper">
			<!-- Left side buttons -->
			<ul class="left">
			  <li>
				<a href="#!" onclick="toggleSidebar()" class="tooltipped" data-tooltip="Menu">
				  <i class="material-icons">menu</i>
				</a>
			  </li>
        <!--  This is the store selector. 
			  <li>
				<a id="storeButton" onclick="initSelectStore();">
			  </li>
        -->
			</ul>

			<!-- Center brand title (clickable for switching survey) -->
			<a id="nav-title" class="brand-logo center" onclick="handleSwitchSurvey()"> </a>

			<!-- Right side button -->
			<ul class="right">
			  <li>
				<a href="#!" onclick="openSettingsModal()" class="tooltipped" data-tooltip="Settings">
				  <i class="material-icons">settings</i>
				</a>
			  </li>
			</ul>
		  </div>
		</nav>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal" style="min-height:320px;">
      <div class="modal-content">
        <h5><!-- Settings title will be updated via setLanguage --></h5>
			
        <div>
          <label for="language-select"><!-- Language label will be updated via setLanguage --></label>
          <select id="language-select" onchange="setLanguage(this.value)">
            <option value="en-US">English</option>
            <option value="zh-TW">繁體中文</option>
            <option value="ja-JP">日本語</option>
          </select>
        </div>
		
		<div>
		  <label for="endpoint-url"><!-- Endpoint URL label will be updated via setLanguage --></label>
		  <input
			type="text"
			id="endpoint-url"
			placeholder="https://your-api-endpoint.com/survey"
		  />
		</div>

      <!-- DELETE ACCOUNT SECTION -->
     
      <div id="delete-account-fields" style="display: none;">
        <h6 class="delete-account-title" style="color:red;"></h6>
        <label for="delete-email" class="delete-email-label"></label>
        <input type="email" id="delete-email" placeholder="" />
        <label for="delete-password" class="delete-password-label"></label>
        <input type="password" id="delete-password" placeholder="" />
      </div>
     
      <div style="display: flex; gap: 10px; margin:3em 0 1em;">
        
        <button id="delete-account-btn" class="btn red"></button>
        <button id="cancel-delete-account-btn" class="btn green" style="display: none;">cancel</button>
      </div>



      </div>
      <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center; padding: 0 1.7em;">
		  <button class="modal-close btn red" onclick="logout();"><!-- Logout text will be updated via setLanguage --></button>
		  <button class="modal-close btn blue"><!-- Close text will be updated via setLanguage --></button>
		</div>
    </div>
	
	<!-- Survey Link Modal -->
	<div id="surveyLinkModal" class="modal">
	  <div class="modal-content">
		<h4><!-- Survey Link title will be updated via setLanguage --></h4>
		<p id="surveyLinkText" style="word-break: break-all;"></p>
		<div style="margin-top: 20px;">
		  <a class="btn" id="copyBtn">
			<i class="material-icons left">content_copy</i><!-- Copy text will be updated via setLanguage -->
		  </a>
		  <a class="btn blue" id="goBtn">
			<i class="material-icons left">send</i><!-- Go to Survey text will be updated via setLanguage -->
		  </a>
		</div>
	  </div>
	  
	  <div class="modal-footer">
		<a href="#!" class="modal-close btn-flat"><!-- Close text will be updated via setLanguage --></a>
	  </div>
	</div>
	
<!-- Select Survey Modal -->
<div id="selectSurveyModal" class="modal">
  <div class="modal-content">
    <h4><!-- Title will be updated via setLanguage --></h4>
    <ul id="surveyList" class="collection"></ul>
  </div>
  <div
    class="modal-footer"
    style="position:sticky; bottom:0; display: flex; justify-content: space-between; align-items: center; padding: 10px 20px;"
  >
    <!-- Import Survey Button on Left -->
    <div>
      <a href="#!" id="importSurveyBtn" class="btn-flat" onclick="openImportSurveyModal()">
        <i class="material-icons left">download</i><!-- Import Survey text will be updated via setLanguage -->
      </a>
    </div>
	  <a href="#!" id="exportSurveyBtn" class="btn-flat" onclick="exportSurvey()">
		<i class="material-icons left">upload</i>
		<span id="export-survey-text"></span>
	  </a>
	
    <!-- Confirm Button on Right -->
    <div>
      <a href="#!" id="confirmSurveyBtn" class="btn"><!-- Confirm text will be updated via setLanguage --></a>
    </div>
  </div>
</div>

<!-- Import Survey Modal (Popup) -->
<div id="importSurveyModal" class="modal">
  <div class="modal-content">
    <h4><!-- Import Survey title will be updated via setLanguage --></h4>
    <div style="margin-bottom: 15px;">
      <!-- Radio Buttons to Choose Import Mode -->
      <label style="margin-right: 10px;">
        <input name="importMode" type="radio" value="file" checked onchange="updateImportModePopup()" />
        <span id="importModeFileLabel"><!-- Will be updated via setLanguage --></span>
      </label>
      <label style="margin-right: 10px;">
        <input name="importMode" type="radio" value="url" onchange="updateImportModePopup()" />
        <span id="importModeUrlLabel"><!-- Will be updated via setLanguage --></span>
      </label>
      <label>
        <input name="importMode" type="radio" value="text" onchange="updateImportModePopup()" />
        <span id="importModeTextLabel"><!-- Will be updated via setLanguage --></span>
      </label>
    </div>
    <!-- File Import Option -->
    <div id="popupImportFileContainer" style="margin-top: 15px;">
      <input type="file" id="popupImportSurveyFile" accept=".json" style="display: none;" onchange="handleImportSurveyFilePopup(event)" />
      <button class="btn" id="chooseFileBtn" onclick="document.getElementById('popupImportSurveyFile').click();">
        <i class="material-icons left">download</i><!-- Choose File text will be updated via setLanguage -->
      </button>
    </div>
    <!-- URL Import Option -->
    <div id="popupImportUrlContainer" style="display: none; margin-top: 15px;">
      <input type="text" id="popupImportSurveyUrl" placeholder="Enter URL to JSON" style="width: 100%; padding: 8px;" />
    </div>
	<!-- Text Import Option (Manual + Auto-Generate) -->
	<div id="popupImportTextContainer" style="display: none; margin-top: 15px;">
	  <textarea
		id="popupImportSurveyText"
		placeholder="Paste JSON here"
		style="width: 100%; height: 200px; padding: 8px;"
	  ></textarea>

	  <!-- Container for the description input and the two buttons -->
	  <div id="survey-gen-container" style="margin-top: 15px;">
		<!-- Label + Textarea for user description -->
		<label for="survey-description-input" style="display: block; margin-bottom: 5px;">
		  Describe the survey you want:
		</label>
		<textarea
		  id="survey-description-input"
		  placeholder="e.g. a customer satisfaction survey with star rating and multiple choice"
		  style="width: 100%; height: 100px; padding: 8px;"
		></textarea>

		<!-- Buttons row: Generate on the left, Voice on the right -->
		<div
		  style="
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-top: 10px;
		  "
		>
		  <!-- Generate button on the left -->
		  <button id="generate-survey-schema-btn" class="btn teal" disabled>
			<i class="material-icons left">autorenew</i>
			Generate Survey Schema
		  </button>
		  <!-- Voice button on the right -->
		  <button id="start-voice-btn" class="btn teal">
			<i class="material-icons">mic</i>
		  </button>
		</div>
	  </div>
	</div>


  </div>
  <div class="modal-footer" style="display: flex; justify-content: flex-end; align-items: center; padding: 10px 20px;">
    <a href="#!" class="modal-close btn-flat"><!-- Cancel text will be updated via setLanguage --></a>
    <a href="#!" id="finalImportBtn" class="btn" onclick="handleFinalImport()"><!-- Import text will be updated via setLanguage --></a>
  </div>
</div>



<!-- Survey Event Triggers Modal -->
<div id="eventTriggersModal" class="modal height100">
  <div class="modal-content">
    <h4>addNewTrigger</h4>
    <!-- Existing triggers list -->
    <div id="triggersList"></div>
    
    <!-- New Trigger Form Container (hidden by default) -->
    <div id="newTriggerForm" style="display: none; margin-top: 20px;  padding-top: 10px;">
      <!-- Trigger type selector -->
      <div class="row">
        <div class="input-field col s12">
          <select id="triggerType">
            <option value="" disabled selected>selectTriggerType</option>
            <option value="starThreshold">starThreshold</option>
            <option value="answerMatch">answerMatch</option>
            <option value="timeBased">timeBased</option>
          </select>
          <label>Trigger Type</label>
        </div>
      </div>
      <!-- Trigger configuration panels -->
      <div id="triggerConfig">
        <!--  load by loadTriggerConfig() -->
      </div>
      <!-- Save and Cancel buttons -->
      <div class="row" style="margin-top: 10px; display: flex; justify-content: flex-end; gap: 10px;">
        <button class="btn green" onclick="saveNewTrigger()">saveTriggerButton</button>
        <button class="btn grey" onclick="cancelNewTrigger()">cancel</button>
      </div>
    </div>
  </div>
  <!-- Fixed Add Trigger Button -->
  <div class="modal-footer  sticky-footer" style="justify-content: center;">
    <button class="btn blue" onclick="showNewTriggerForm()">
      <span id="add-new-trigger-text"></span>
    </button>    
  </div>
</div>


<!-- preview  Modal -->
<div id="preview-modal" class="modal">
  <div class="modal-content" style="padding:0;">
    <iframe id="preview-frame"
            src="survey.html"
            style="overflow: hidden; width:100%; border:none;">
    </iframe>
  </div>
  <div class="modal-footer">
    <a href="#!" class="modal-close btn translate">close++preview</a>
  </div>
</div>


<!-- Full Page Survey Data Summary -->
<div id="surveyDataPage" class="full-page-overlay">
  <div class="page-header">
    <h5 id="surveyDataTitle">問卷資料摘要</h4>
    <button id="surveyDataCloseBtn" class="close-btn" onclick="closeSurveyDataPage()">Close</button>
  </div>
  <div id="surveyDataContent" class="page-content">
    <!-- Fetched survey distribution and summary will be injected here -->
  </div>
</div>


    <!-- SIDEBAR -->
 
	<div id="sidebar" class="with-gutter">
	  <div class="scroll-gutter"></div>
	  <ul id="questions-list" class="collection">
		<!-- Draggable items here -->
	  </ul>
	</div>
	

    <!-- MAIN CONTENT -->
    <main>
      <div id="main-content" class="no-sidebar">
        <div class="section">
		
          <!-- <h5 id="page-subtitle" style="flex:4;"></h5> -->
          
          <div style="display: flex; align-items: center;">
            <label id="survey-title-label" for="survey-title-input" style="margin-right: 8px; font-size:1em; width:6em;">問卷標題:</label>
            <input id="survey-title-input" type="text" placeholder="請輸入問卷標題" style="padding: 4px 8px;" />
          </div>
          <div style="display: flex; align-items: center;">
            <label id="channel-id-label" for="channel-select" style="margin-right: 8px; font-size:1em; width:6em;">頻道代碼:</label>
            <select id="channel-select" style="padding: 4px 8px;">
              <option value="">-- 選擇頻道 --</option>
            </select>
          </div>		 
          <!-- Banner Image URL input (the original upload image button has been removed) -->
          <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 10px;">
            <label id="survey-banner-label" for="survey-banner-input" style="margin-right: 8px; font-size:1em; width:6em;"><!-- Banner Image URL label will be updated via setLanguage --></label>
            <input id="survey-banner-input" type="text" placeholder="<!-- Banner Image placeholder will be updated via setLanguage -->" style="padding: 4px 8px;" />
          </div>

          <!-- Questions/Groups Container -->
          <div id="questions-and-groups"></div>

          <!-- Button Row (sticky at bottom) -->
          <div class="row sticky-bottom">
            <div class="col s12">
              <!-- Left side buttons: always visible -->
              <div class="left-buttons">
                <!-- Add Question -->
                <button
                  class="btn green waves-effect waves-light"
                  id="add-question-btn"
                  onclick="addQuestion()"
                >
                  <i class="material-icons left">add</i>
                  <span id="add-question-text"></span>
                </button>
          
                <!-- Add Group -->
                <button
                  class="btn orange waves-effect waves-light"
                  id="add-group-btn"
                  onclick="addGroup()"
                >
                  <i class="material-icons left">group_work</i>
                  <span id="add-group-text"></span>
                </button>
          
                <!-- Undo / Redo -->
                <button id="undo-btn" class="btn grey waves-effect waves-light">
                  <i class="material-icons left">undo</i>
                  <span id="undo-text"></span>
                </button>
                <button id="redo-btn" class="btn grey waves-effect waves-light">
                  <i class="material-icons left">redo</i>
                  <span id="redo-text"></span>
                </button>
				
				
				<button id="preview-btn" class="btn teal waves-effect"					
					onclick="previewSurvey()">
				  <i class="material-icons left">visibility</i>
				  <span id="preview-text">Preview</span>
			   </button>
				
              </div>
			  
			  
				
			  
          
              <!-- Right side buttons for desktop: visible on medium and larger screens -->
              <div class="right-buttons hide-on-small-only">
                <button
                  class="btn grey waves-effect waves-light"
                  id="fetch-data-btn"
                  onclick="fetchSurveyData()"
                >
                  <i class="material-icons left">assessment</i>
                  <span id="fetch-data-text">Survey Data</span>
                </button>
                <button
                  class="btn grey waves-effect waves-light"
                  onclick="showEventTriggers()"
                >
                  <i class="material-icons left">notifications</i>
                  <span id="event-trigger-text">Event Triggers</span>
                </button>
                <button
                  class="btn blue waves-effect waves-light"
                  onclick="generateSurvey()"
                >
                  <i class="material-icons left">save</i>
                  <span id="generate-text"></span>
                </button>
				
				
				
              </div>
          
              <!-- Mobile: show a native select styled as an icon-only button -->
              <div class="right-buttons show-on-small hide-on-med-and-up">
                <div class="more-select-container">
                  <select id="more-actions-select" class="browser-default more-select">
                    <option value="" disabled selected hidden></option>
                    <option value="survey-data">fetchDataText</option>
                    <option value="event-triggers">eventTriggersTitle</option>
                    <option value="generate-survey">generate</option>
                  </select>
                </div>
              </div>

            </div>
          </div>
          
        </div>
      </div>
    </main>

    <!-- Materialize JS -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"
      defer
    ></script>
	<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>		
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js"></script>



<!-- 在頁面底部引入 SortableJS -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>




<script>
    // Global variables
    // Global variable for the Ace Editor instance
    var triggerEditor;
    const BASE_URL = 'https://b200.tagfans.com:5301';
    //  const BASE_URL = 'http://127.0.0.1:5300';

    // On load, check if userToken exists. If not, redirect to login.html.
    // Helper function to get URL parameters
    function getQueryParams() {
        const params = new URLSearchParams(window.location.search);
        return {
            userId: params.get("userId"),
            userToken: params.get("userToken")
        };
    }

    const urlParams = getQueryParams();

    // Global variables for the user credentials for this session
    let currentUserId, currentUserToken;

    if (urlParams.userId && urlParams.userToken) {
        // Use credentials from the URL parameters
        currentUserId = urlParams.userId;
        currentUserToken = urlParams.userToken;
    } else if (localStorage.getItem("userId") && localStorage.getItem("userToken")) {
        // Use credentials from localStorage if they exist
        currentUserId = localStorage.getItem("userId");
        currentUserToken = localStorage.getItem("userToken");
    } else {
        // No credentials available – redirect to login
        window.location.href = "login.html?redirect=admin.html";
    }

    /***********************************************
     * TRANSLATIONS
     ***********************************************/
    const i18n_local = {
        'en-US': {
            navTitle: "Survey Admin",
            subtitle: "Create or Edit Your Survey",
            addQuestion: "Add New Question",
            addGroup: "Add New Group",
            undo: "Undo",
            redo: "Redo",
			preview: "Preview",
            generate: "Generate",
            questionTextLabel: "Question Text",
            questionTypeLabel: "Question Type",
            textInput: "Text Input",
            radioInput: "Multiple Choice (Single Select)",
            checkboxInput: "Multiple Choice (Multiple Select)",
            dateInput: "Date Picker",
            longtextInput: "Long Text Input",
            starsInput: "Star Rating",
            uploadImage: "Upload Image", // NEW key
            requiredLabel: "Required",
            compackLabel: "Compact",
            optionsLabel: "Options",
            addOption: "Add Option",
            removeOption: "Remove",
            questionPlaceholder: "Question #",
            deleteMsg: "Question deleted",
            deleteButton: "Delete",
            moveUp: "Move Up",
            moveDown: "Move Down",
            maxStarsLabel: "Max Stars",
            /* Groups */
            groupTitleLabel: "Group Title",
            anchorQuestionLabel: "Anchor Question (Show This Group When...)",
            anchorValuesLabel: "If anchor question answer is in:",
            groupPlaceholder: "Group #",
            deleteGroupMsg: "Group deleted",
            anchorNoQuestion: "No anchor set",
            pleaseSelectSurvey: "Please select a survey",
            surveyTitleLabel: "Survey Title:",
            processingText: "Processing, please wait ...",
            menuTooltip: "Menu",
            selectStoreTitle: "Select Store",
            confirm: "Confirm",
            cancel: "Cancel",
            settingsTitle: "Settings",
            languageLabel: "Language",
            endpointUrlLabel: "Endpoint URL",
            logout: "Logout",
            close: "Close",
            surveyLinkTitle: "Survey Link",
            copy: "Copy",
            goToSurvey: "Go to Survey",
            selectSurveyTitle: "Select Survey",
            importSurvey: "Import Survey",
            enterSurveyTitle: "Please enter survey title",
            copiedToClipboard: "Copied to clipboard",
            unsavedChangesPrompt: "You have unsaved changes. Do you want to save the current survey?",
            logoutConfirm: "Are you sure you want to logout?",
            importSurveySuccess: "Survey imported successfully",
            importSurveyFail: "Failed to parse the file",
            newSurvey: "New Survey",
            surveyIdLabel: "Survey ID:",
            createNewSurvey: "Create New Survey",
            surveyIdPrefix: "ID:",
            importSurveyTitle: "Import Survey",
            importModeFile: "File",
            importModeUrl: "URL",
            importModeText: "Text",
            chooseFile: "Choose File",
            enterUrlPlaceholder: "Enter URL to JSON",
            pasteJsonPlaceholder: "Paste JSON here",
            importText: "Import",
            invalidJsonFile: "Please select a valid JSON file",
            fileParseError: "Failed to parse JSON file",
            enterUrl: "Please enter a URL",
            importSurveyUrlFail: "Failed to import survey from URL",
            pasteJsonText: "Please paste JSON text",
            parseJsonTextError: "Failed to parse JSON text",
            importSurveyFailed: "Failed to import survey",
            endpointUrlPlaceholder: "https://your-api-endpoint.com/survey",
            noOptionsAvailable: "No options available",
            importReplaceConfirmation: "Importing a new survey will replace the current survey. Do you want to continue?",
            convertToGroup: "Convert to Group",
            unpackToStandalone: "Unpack to Standalone",
            bannerImageUrl: "Banner Image URL:",
            bannerImagePlaceholder: "Enter URL for banner image",
            extraText: "Extra Text",
            fetchDataText: "Survey Data",
            surveyDataSummaryTitle: "Survey Data Summary",
            textAnswerSummaryNote: "Text answers are not summarized statistically.",
            confirmDeleteSurvey: "Are you sure you want to delete this survey?",
            surveyDeletedSuccessfully: "Survey deleted successfully",
            failedToDeleteSurvey: "Failed to delete survey",
            triggerTypeLabel: "Type: ",
            deleteTriggerButton: "Delete",
            editTriggerButton: "Edit",
            saveTriggerButton: "Save",
            cancelTriggerButton: "Cancel",
            starThresholdLabel: "Threshold (stars)",
            starCountLabel: "Required Count",
            targetQuestionLabel: "Question",
            expectedAnswerLabel: "Expected Answer(s)",
            timeWindowLabel: "Time Window (hours)",
            minimumCountLabel: "Minimum Count",
            // For trigger script translations, we will use different versions below.
            // (These are handled separately in the trigger functions.)
            eventTriggersTitle: "Event Triggers",
            addNewTrigger: "Add New Trigger",
            saveTriggerButton: "Save Trigger",
            cancelTriggerButton: "Cancel Trigger",
            selectTriggerType: "Select Trigger Type",
            starThreshold: "Star Rating Threshold",
            answerMatch: "Specific Answer",
            timeBased: "Time-based Condition",
            selectQuestion: "Select a question",
            triggerDescription_starThreshold: "Set a star rating threshold and the required count. The trigger activates if at least the specified number of responses have a rating below the threshold.",
            triggerDescription_answerMatch: "Select a target question and choose one or more expected answers. The trigger activates if the target question’s answer contains any of the selected options.",
            triggerDescription_timeBased: "Specify a time window (in hours) and a minimum count. The trigger activates if the number of responses within the time window meets or exceeds the minimum count.",
            validation_starThreshold: "Please fill in valid numbers for star threshold and count.",
            validation_targetQuestion: "Please select a target question.",
            validation_expectedAnswer: "Please select at least one expected answer.",
            validation_timeBased: "Please provide valid numbers for time window and minimum count.",
            validation_invalidTrigger: "Invalid trigger type selected.",
            triggerName_starThreshold: "Star Threshold: Threshold {threshold}, Count {count}",
            triggerName_answerMatch: "Answer Match: '{question}' matches [{answers}]",
			triggerName_timeBased_template: "In the past {timeWindow}{unit}, question (id:{questionId}) '{questionTitle}' {metric} {operator} {threshold}",
            deleteAccountTitle: "Delete Account",
            deleteEmailLabel: "Enter Email:",
            deleteEmailPlaceholder: "Your email",
            deletePasswordLabel: "Enter Password:",
            deletePasswordPlaceholder: "Your password",
            deleteAccountButton: "Delete Account",
            deleteAccountButtonConfirm: "Confirm Delete Account", // after first click,
			exportSurvey: "Export Survey",
			exportFileName: "Survey Export - {date}",
			exportSurveyMessage: "Survey exported successfully to",
			timeWindowLabel: "Time Window Value",
			timeWindowUnitLabel: "Time Unit",
			hoursLabel: "Hours",
			daysLabel: "Days",
			targetQuestionLabel: "Select Question",
			metricLabel: "Metric",
			metricSumLabel: "Sum",
			metricAvgLabel: "Average",
			metricMedianLabel: "Median",
			metricCountLabel: "Count",
			metricMaxLabel: "Max",
			metricMinLabel: "Min",
			operatorLabel: "Operator",
			operatorGreaterThan: "Greater Than",
			operatorGreaterEqual: "Greater Than or Equal",
			operatorLessThan: "Less Than",
			operatorLessEqual: "Less Than or Equal",
			operatorEqual: "Equal",
			thresholdLabel: "Threshold"
        },
        "zh-TW": {
            navTitle: "問卷管理",
            subtitle: "創建或編輯您的問卷",
            addQuestion: "新增問題",
            addGroup: "新增群組",
            undo: "復原",
            redo: "重做",
			preview: "預覽",
            generate: "產生問卷",
            questionTextLabel: "問題內容",
            questionTypeLabel: "問題類型",
            textInput: "文字輸入",
            radioInput: "單選題",
            checkboxInput: "多選題",
            dateInput: "日期選擇",
            longtextInput: "長文本輸入",
            starsInput: "星級評分",
            uploadImage: "上傳圖片",
            requiredLabel: "必填",
            compackLabel: "壓縮顯示",
            optionsLabel: "選項",
            addOption: "新增選項",
            removeOption: "刪除",
            questionPlaceholder: "問題 #",
            deleteMsg: "已刪除問題",
            deleteButton: "刪除",
            moveUp: "上移",
            moveDown: "下移",
            maxStarsLabel: "最大星數",
            /* Groups */
            groupTitleLabel: "群組標題",
            anchorQuestionLabel: "控制顯示問題 (當此問題的答案...)",
            anchorValuesLabel: "等於下列選項時顯示此群組:",
            groupPlaceholder: "群組 #",
            deleteGroupMsg: "已刪除群組",
            anchorNoQuestion: "未設定控制問題",
            pleaseSelectSurvey: "請選擇一個問卷",
            surveyTitleLabel: "問卷標題:",
            processingText: "處理中，請稍候 ...",
            menuTooltip: "選單",
            selectStoreTitle: "選擇商店",
            confirm: "確認",
            cancel: "取消",
            settingsTitle: "設定",
            languageLabel: "語言",
            endpointUrlLabel: "端點 URL",
            logout: "登出",
            close: "關閉",
            surveyLinkTitle: "問卷連結",
            copy: "複製",
            goToSurvey: "前往問卷",
            selectSurveyTitle: "選擇問卷",
            importSurvey: "匯入問卷",
            enterSurveyTitle: "請輸入問卷標題",
            copiedToClipboard: "已複製到剪貼簿",
            unsavedChangesPrompt: "您有未儲存的變更。是否要儲存當前問卷？",
            logoutConfirm: "您確定要登出嗎？",
            importSurveySuccess: "匯入問卷成功",
            importSurveyFail: "檔案解析失敗",
            newSurvey: "新問卷",
            surveyIdLabel: "問卷 ID:",
            createNewSurvey: "建立新問卷",
            surveyIdPrefix: "編號:",
            importSurveyTitle: "匯入問卷",
            importModeFile: "檔案",
            importModeUrl: "URL",
            importModeText: "文字",
            chooseFile: "選擇檔案",
            enterUrlPlaceholder: "輸入 JSON 的 URL",
            pasteJsonPlaceholder: "貼上 JSON 內容",
            importText: "匯入",
            invalidJsonFile: "請選擇有效的 JSON 檔案",
            fileParseError: "解析 JSON 檔案失敗",
            enterUrl: "請輸入 URL",
            importSurveyUrlFail: "從 URL 匯入問卷失敗",
            pasteJsonText: "請貼上 JSON 文字",
            parseJsonTextError: "解析 JSON 文字失敗",
            importSurveyFailed: "匯入問卷失敗",
            endpointUrlPlaceholder: "https://your-api-endpoint.com/survey",
            noOptionsAvailable: "無可用選項",
            importReplaceConfirmation: "匯入新的問卷將取代目前的問卷。您確定要繼續嗎？",
            convertToGroup: "轉換為群組",
            unpackToStandalone: "拆分為獨立問題",
            bannerImageUrl: "橫幅圖片網址:",
            bannerImagePlaceholder: "輸入橫幅圖片的網址",
            extraText: "選此選項可以新增備註",
            fetchDataText: "問卷分析",
            surveyDataSummaryTitle: "問卷資料摘要",
            textAnswerSummaryNote: "文字回答不進行統計摘要。",
            confirmDeleteSurvey: "您確定要刪除此問卷嗎？",
            surveyDeletedSuccessfully: "問卷刪除成功",
            failedToDeleteSurvey: "刪除問卷失敗",
            triggerTypeLabel: "類型: ",
            deleteTriggerButton: "刪除",
            editTriggerButton: "編輯",
            saveTriggerButton: "儲存",
            cancelTriggerButton: "取消",
            starThresholdLabel: "閾值 (星級)",
            starCountLabel: "所需數量",
            targetQuestionLabel: "問題",
            expectedAnswerLabel: "預期答案",
            timeWindowLabel: "時間範圍 (小時)",
            minimumCountLabel: "最小數量",
            eventTriggersTitle: "事件觸發",
            addNewTrigger: "新增觸發",
            saveTriggerButton: "儲存觸發",
            cancelTriggerButton: "取消觸發",
            selectTriggerType: "選擇觸發器類型",
            starThreshold: "星級評分閾值",
            answerMatch: "特定答案",
            timeBased: "基於時間的條件",
            selectQuestion: "選擇一個問題",
            triggerDescription_starThreshold: "設定一個星級評分閾值以及所需的次數。當至少有指定數量的回答的評分低於此閾值時，觸發器便會啟動。",
            triggerDescription_answerMatch: "請選擇目標問題並選取一個或多個預期答案。當目標問題的回答包含任何選定的選項時，觸發器便會啟動。",
            triggerDescription_timeBased: "請指定一個時間範圍（以小時計）和一個最小計數。當在該時間範圍內的回答數量達到或超過最小計數時，觸發器將會啟動。",
            validation_starThreshold: "請填寫有效的星級閾值和數量。",
            validation_targetQuestion: "請選擇一個目標問題。",
            validation_expectedAnswer: "請至少選取一個預期答案。",
            validation_timeBased: "請提供有效的時間範圍和最小計數。",
            validation_invalidTrigger: "所選觸發器類型無效。",
            triggerName_starThreshold: "星級閾值：閾值 {threshold}，數量 {count}",
            triggerName_answerMatch: "特定答案：『{question}』包含 [{answers}]",
			triggerName_timeBased_template: "過去 {timeWindow}{unit}，題目 id:{questionId} 『{questionTitle}』 的 {metric} {operator} {threshold}",
            deleteAccountTitle: "刪除帳戶",
            deleteEmailLabel: "輸入電子郵件：",
            deleteEmailPlaceholder: "您的電子郵件",
            deletePasswordLabel: "輸入密碼：",
            deletePasswordPlaceholder: "您的密碼",
            deleteAccountButton: "刪除帳戶",
            deleteAccountButtonConfirm: "確認刪除帳戶",
			exportSurvey: "匯出問卷",
			exportFileName: "問卷匯出 - {date}",
			exportSurveyMessage: "問卷已成功匯出至",
			timeWindowLabel: "回溯時間數值",
			timeWindowUnitLabel: "時間單位",
			hoursLabel: "小時",
			daysLabel: "天",
			targetQuestionLabel: "選擇題目",
			metricLabel: "統計方法",
			metricSumLabel: "總和 (Sum)",
			metricAvgLabel: "平均 (Average)",
			metricMedianLabel: "中位數 (Median)",
			metricCountLabel: "筆數 (Count)",
			metricMaxLabel: "最大值 (Max)",
			metricMinLabel: "最小值 (Min)",
			operatorLabel: "比較運算",
			operatorGreaterThan: "大於",
			operatorGreaterEqual: "大於等於",
			operatorLessThan: "小於",
			operatorLessEqual: "小於等於",
			operatorEqual: "等於",
			thresholdLabel: "閾值"
			},
        "ja-JP": {
            navTitle: "アンケート管理",
            subtitle: "アンケートを作成または編集",
            addQuestion: "新しい質問を追加",
            addGroup: "新しいグループを追加",
            undo: "元に戻す",
            redo: "やり直す",
			preview: "プレビュー",
            generate: "生成",
            questionTextLabel: "質問文",
            questionTypeLabel: "質問タイプ",
            textInput: "テキスト入力",
            radioInput: "単一選択式 (ラジオボタン)",
            checkboxInput: "複数選択式 (チェックボックス)",
            dateInput: "日付入力",
            longtextInput: "長文入力",
            starsInput: "星の評価",
            uploadImage: "画像アップロード",
            requiredLabel: "必須",
            compackLabel: "コンパクト表示",
            optionsLabel: "オプション",
            addOption: "オプションを追加",
            removeOption: "削除",
            questionPlaceholder: "質問 #",
            deleteMsg: "質問を削除しました",
            deleteButton: "削除",
            moveUp: "上へ移動",
            moveDown: "下へ移動",
            maxStarsLabel: "最大星数",
            /* Groups */
            groupTitleLabel: "グループタイトル",
            anchorQuestionLabel: "アンカー質問 (この回答によって表示...)",
            anchorValuesLabel: "アンカー質問の回答が以下の場合、表示:",
            groupPlaceholder: "グループ #",
            deleteGroupMsg: "グループを削除しました",
            anchorNoQuestion: "アンカー質問未設定",
            pleaseSelectSurvey: "アンケートを選択してください",
            surveyTitleLabel: "アンケートタイトル:",
            processingText: "処理中、しばらくお待ちください ...",
            menuTooltip: "メニュー",
            selectStoreTitle: "店舗を選択",
            confirm: "確認",
            cancel: "キャンセル",
            settingsTitle: "設定",
            languageLabel: "言語",
            endpointUrlLabel: "エンドポイント URL",
            logout: "ログアウト",
            close: "閉じる",
            surveyLinkTitle: "アンケートリンク",
            copy: "コピー",
            goToSurvey: "アンケートへ移動",
            selectSurveyTitle: "アンケートを選択",
            importSurvey: "アンケートをインポート",
            enterSurveyTitle: "アンケートタイトルを入力してください",
            copiedToClipboard: "クリップボードにコピーしました",
            unsavedChangesPrompt: "保存されていない変更があります。現在のアンケートを保存しますか？",
            logoutConfirm: "本当にログアウトしますか？",
            importSurveySuccess: "アンケートのインポートに成功しました",
            importSurveyFail: "JSONファイルの解析に失敗しました",
            newSurvey: "新規アンケート",
            surveyIdLabel: "アンケートID:",
            createNewSurvey: "新規アンケート作成",
            surveyIdPrefix: "番号:",
            importSurveyTitle: "アンケートをインポート",
            importModeFile: "ファイル",
            importModeUrl: "URL",
            importModeText: "テキスト",
            chooseFile: "ファイルを選択",
            enterUrlPlaceholder: "JSON の URL を入力",
            pasteJsonPlaceholder: "JSON を貼り付け",
            importText: "インポート",
            invalidJsonFile: "有効なJSONファイルを選択してください",
            fileParseError: "JSONファイルの解析に失敗しました",
            enterUrl: "URLを入力してください",
            importSurveyUrlFail: "URLからのアンケートインポートに失敗しました",
            pasteJsonText: "JSONテキストを貼り付けてください",
            parseJsonTextError: "JSONテキストの解析に失敗しました",
            importSurveyFailed: "アンケートのインポートに失敗しました",
            endpointUrlPlaceholder: "https://your-api-endpoint.com/survey",
            noOptionsAvailable: "利用可能なオプションはありません",
            importReplaceConfirmation: "新しいアンケートをインポートすると、現在のアンケートが置き換えられます。続行しますか？",
            convertToGroup: "グループに変換",
            unpackToStandalone: "独立に戻す",
            bannerImageUrl: "バナー画像のURL:",
            bannerImagePlaceholder: "バナー画像のURLを入力",
            extraText: "追加テキスト",
            fetchDataText: "アンケートデータ",
            surveyDataSummaryTitle: "アンケートデータサマリー",
            textAnswerSummaryNote: "テキスト回答は統計的に集計しません。",
            confirmDeleteSurvey: "このアンケートを削除してもよろしいですか？",
            surveyDeletedSuccessfully: "アンケートが正常に削除されました",
            failedToDeleteSurvey: "アンケートの削除に失敗しました",
            triggerTypeLabel: "種類: ",
            deleteTriggerButton: "削除",
            editTriggerButton: "編集",
            saveTriggerButton: "保存",
            cancelTriggerButton: "キャンセル",
            starThresholdLabel: "閾値 (星)",
            starCountLabel: "必要な数",
            targetQuestionLabel: "質問",
            expectedAnswerLabel: "予想される回答",
            timeWindowLabel: "時間枠 (時間)",
            minimumCountLabel: "最小数",
            eventTriggersTitle: "イベントトリガー",
            addNewTrigger: "新規トリガー追加",
            saveTriggerButton: "トリガー保存",
            cancelTriggerButton: "キャンセル",
            selectTriggerType: "トリガータイプを選択",
            starThreshold: "星評価の閾値",
            answerMatch: "特定の回答",
            timeBased: "時間に基づく条件",
            selectQuestion: "質問を選択",
            triggerDescription_starThreshold: "星の評価閾値と必要な数を設定してください。指定された数以上の回答が閾値未満の場合、トリガーが発動します。",
            triggerDescription_answerMatch: "ターゲットの質問を選択し、1つ以上の期待される回答を選んでください。対象の質問の回答に選択されたオプションが含まれる場合、トリガーが発動します。",
            triggerDescription_timeBased: "時間枠（時間単位）と最小数を指定してください。時間枠内の回答数が最小数に達するかそれ以上の場合、トリガーが発動します。",
            validation_starThreshold: "有効な星評価の閾値とカウントを入力してください。",
            validation_targetQuestion: "ターゲットの質問を選択してください。",
            validation_expectedAnswer: "少なくとも1つの期待される回答を選択してください。",
            validation_timeBased: "有効な時間枠と最小数を入力してください。",
            validation_invalidTrigger: "無効なトリガータイプが選択されました。",
            triggerName_starThreshold: "星評価閾値: 閾値 {threshold}、数 {count}",
            triggerName_answerMatch: "過去{timeWindow}{unit}において、質問{questionId}の{metric}が{operator}{threshold}",
            triggerName_timeBased_template: "過去 {timeWindow}{unit}、質問ID:{questionId}「{questionTitle}」の{metric}が{operator}{threshold}",
            deleteAccountTitle: "アカウントの削除",
            deleteEmailLabel: "メールアドレスを入力:",
            deleteEmailPlaceholder: "あなたのメールアドレス",
            deletePasswordLabel: "パスワードを入力:",
            deletePasswordPlaceholder: "あなたのパスワード",
            deleteAccountButton: "アカウント削除",
            deleteAccountButtonConfirm: "アカウント削除を確定",
			exportSurvey: "アンケートをエクスポート",
			exportFileName: "アンケートエクスポート - {date}",
			exportSurveyMessage: "アンケートが正常にエクスポートされました",
			timeWindowLabel: "遡る時間の値",
			timeWindowUnitLabel: "時間単位",
			hoursLabel: "時間",
			daysLabel: "日",
			targetQuestionLabel: "質問を選択",
			metricLabel: "統計方法",
			metricSumLabel: "合計",
			metricAvgLabel: "平均",
			metricMedianLabel: "中央値",
			metricCountLabel: "件数",
			metricMaxLabel: "最大値",
			metricMinLabel: "最小値",
			operatorLabel: "比較演算子",
			operatorGreaterThan: "より大きい",
			operatorGreaterEqual: "以上",
			operatorLessThan: "より小さい",
			operatorLessEqual: "以下",
			operatorEqual: "等しい",
			thresholdLabel: "しきい値"
        }
    };
    let currentLang = "en-US";

    /***********************************************
     * GLOBAL DATA
     ***********************************************/
    /*
    We'll store both questions and groups in the same array, each item has:
    {
    type: "question" | "group",
    id: number,
    ...
    }

    If type === "question", it has your existing question fields:
    questionText, questionType, options, required, compack, etc.

    If type === "group", it has:
    groupTitle,
    anchorQuestionId,      // which question controls the group
    anchorValuesToShow: [],// which answers trigger "show"
    subQuestions: [ {...}, {...} ] // array of normal question objects
    ...
     */
    let surveyItems = [];
    let undoStack = [];
    let redoStack = [];
    let CurrentSurveySchemaId, CurrentSurveyTitle;

    // For mobile click-outside to close the sidebar
    let mobileClickOutsideHandler = null;

    window.onload = function () {

        console.log("window loaded");

    }

	window.originalGeneratedSurvey = null;


	function isSurveyDataChanged(currentGenerated) {
	  if (!currentGenerated) return false;
	  if (!window.originalGeneratedSurvey) {
		return true;
	  }
	  const orig = window.originalGeneratedSurvey;
	  const curr = currentGenerated;

	  // 逐 key 比對
	  for (const key of Object.keys(curr)) {
		// 如果原先沒這個 key，或值不一樣，就判定為「已改動」
		if (!(key in orig)) return true;

		// 如果是物件／陣列，要做深度比較 (可用 JSON.stringify)
		const origVal = orig[key];
		const currVal = curr[key];
		const origJson = JSON.stringify(origVal);
		const currJson = JSON.stringify(currVal);
		if (origJson !== currJson) return true;
	  }
	  return false;
	}

	window.addEventListener("beforeunload", async function (e) {
	  // 因為 generateSurvey(true) 是 async，要先 await 拿到 current 物件
	  const currentGenerated = await generateSurvey(true);
	  if (isSurveyDataChanged(currentGenerated)) {
		const msg = "您有尚未儲存的變更，確定要離開或重新整理嗎？";
		(e || window.event).returnValue = msg;
		return msg;
	  }
	  // 否則回傳 undefined，允許正常關閉
	});

    /***********************************************
     * INITIALIZATION
     ***********************************************/
    document.addEventListener("DOMContentLoaded", async function () {
        // Load existing data from localStorage
        // const existingData = localStorage.getItem("surveyQuestions");


        surveys = await fetchSurvey(null);

        // here we should select a survey to continue, or new one
        let existingData = null;
        if (!surveys || surveys.length === 0) {
            // No surveys exist—prompt the user to import one.
            await openImportSurveyModal();
        } else if (surveys && surveys.length > 0) {
            if (surveys.length === 1) {
                CurrentSurveySchemaId = surveys[0]._id;

            } else {
                // If more than one survey exists, force the user to select one.
                let selection;
                selection = localStorage.CurrentSurveySchemaId || await showSelectSurveyModal(surveys);
                if (selection == 'create new')
                    selection = undefined;
                CurrentSurveySchemaId = selection;

            }
        }
 
        await fetchChannelList();

        if (CurrentSurveySchemaId === "create_new") {
            CurrentSurveySchemaId = undefined;
        } else if (CurrentSurveySchemaId) {
            let tmp = await fetchSurvey(CurrentSurveySchemaId);
            existingData = tmp;
        } else {}

        if (existingData) {
            // For backward-compatibility, older code might store only questions.
            // We'll interpret them as "type=question" items if not present:
            const parsed = (typeof existingData == "string") ? JSON.parse(existingData) : existingData;
            let items = parsed.surveyItems;
			
			normalizeSurveyItems(items);  // make sure the format is correct
			
            surveyItems = items.map((item) => {
                if (!item.type) {
                    return {
                        type: "question",
                        ...item
                    };
                }
                return item;
            });
			
			initNextId();
			
            // *** Set the survey title input if one exists ***
            if (parsed.surveyTitle) {
                document.getElementById("survey-title-input").value = parsed.surveyTitle;
				CurrentSurveyTitle = parsed.surveyTitle || "";
            }
            // *** Set the banner image URL if exists ***
            if (parsed.bannerImage) {
                document.getElementById("survey-banner-input").value = parsed.bannerImage;
            }

            if (parsed._channelId) {
                // Save the channel ID in a global variable (if needed later)
                window.preSelectedChannel = parsed._channelId;
                // Set the dropdown's value and refresh the Materialize UI
                const channelSelect = document.getElementById("channel-select");
                if (channelSelect) {
                    channelSelect.value = parsed._channelId;
                    M.FormSelect.init(channelSelect);
                }
            }

        } else {
            surveyItems = [];
			initNextId();
        }

		       
		updateNavTitle();


        // Set default language from localStorage or fallback
        const storedLang = localStorage.getItem("preferredLanguage");
        if (storedLang) {
            currentLang = storedLang;
        } else {
            currentLang = "zh-TW"; // or "en-US"
        }

        // Update the <select> UI
        const languageSelect = document.getElementById("language-select");
        if (languageSelect) {
            languageSelect.value = currentLang;
        }

        // Apply language
        setLanguage(currentLang);
        setupUndoRedoButtons();
        renderAllItems();
		
		
		const baseline = await generateSurvey(true);
		window.originalGeneratedSurvey = JSON.parse(JSON.stringify(baseline));
		

        // openai call to llm user request
        document.getElementById("generate-survey-schema-btn").onclick = async() => {
            const descriptionInput = document.getElementById("survey-description-input");
            const description = descriptionInput.value.trim();

            // If description is empty, show toast and exit
            if (!description) {
                M.toast({
                    html: "Please enter a survey description",
                    displayLength: 2000
                });
                return;
            }

            // Disable the button and show the spinner
            const genBtn = document.getElementById("generate-survey-schema-btn");
            genBtn.disabled = true;
            document.getElementById("loadingSpinner").style.display = "flex";

            try {
                const response = await fetch(`${BASE_URL}/api/generateSurveySchema`, {
                    method: 'POST',
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + currentUserToken,
                        "X-User-Id": currentUserId
                    },
                    body: JSON.stringify({
                        description
                    })
                });
                const data = await response.json();
                if (data.schema) {
                    const schemaString = typeof data.schema === 'object' ? JSON.stringify(data.schema, null, 2) : data.schema;
                    const textArea = document.getElementById("popupImportSurveyText");
                    textArea.value = schemaString;
                    textArea.dispatchEvent(new Event("input", {
                            bubbles: true,
                            cancelable: true
                        }));

                    M.toast({
                        html: "Survey schema generated successfully",
                        displayLength: 2000
                    });
                } else {
                    M.toast({
                        html: "Failed to generate survey schema",
                        displayLength: 2000
                    });
                }
            } catch (error) {
                console.error(error);
                M.toast({
                    html: "Error generating survey schema",
                    displayLength: 2000
                });
            } finally {
                // Re-enable the button and hide the spinner regardless of outcome
                // genBtn.disabled = false;
                document.getElementById("loadingSpinner").style.display = "none";
            }
        };
        // enable/disable the description text area
        document.getElementById("survey-description-input").addEventListener("input", function () {
            const generateBtn = document.getElementById("generate-survey-schema-btn");
            // Disable the button if the text area is empty (ignoring whitespace)
            generateBtn.disabled = this.value.trim() === "";
        });

        /***********************************
         * import modal listener
         * *********************************/
        document.querySelectorAll('input[name="importMode"]').forEach(radio => {
            radio.addEventListener("change", function () {
                localStorage.setItem("importMode", this.value);
                updateImportModePopup(); // make sure the UI updates accordingly
            });
        });
        const jsonTextArea = document.getElementById("popupImportSurveyText");
        const finalImportBtn = document.getElementById("finalImportBtn");

        // Initially disable if text area is empty:
        if (jsonTextArea.value.trim() === "") {
            finalImportBtn.classList.add("disabled");
        } else {
            finalImportBtn.classList.remove("disabled");
        }

        // Update button state on input change:
        jsonTextArea.addEventListener("input", function () {
            if (this.value.trim() === "") {
                finalImportBtn.classList.add("disabled");
            } else {
                finalImportBtn.classList.remove("disabled");
            }
        });

        // Handle responsive sidebar on load & resize
        const sidebar = document.getElementById("sidebar");
        const mainContent = document.getElementById("main-content");

        if (window.innerWidth < 992) {
            sidebar.classList.add('collapsed');
            mainContent.classList.add('no-sidebar');
        }

        function checkScreenSize() {
            if (window.innerWidth < 992) {
                // Mobile: sidebar is collapsed and should only toggle via the button
                // sidebar.classList.add("collapsed");
                // mainContent.classList.add("no-sidebar");
                enableMobileClickOutsideToCloseSidebar();
            } else {
                // On desktop, show sidebar
                sidebar.classList.remove("collapsed");
                mainContent.classList.remove("no-sidebar");
                disableMobileClickOutsideToCloseSidebar();
            }
        }

        const modalElem = document.getElementById('eventTriggersModal');
        M.Modal.init(modalElem, {
            onOpenStart: () => {
                // Reset select & config
                const typeSelect = document.getElementById('triggerType');
                if (typeSelect) {
                    typeSelect.selectedIndex = 0;
                    M.FormSelect.init(typeSelect);
                }
                // Now rebuild the config panels
                loadTriggerConfig();
            },
            onOpenEnd: () => {
                // Same reset in case Materialize re-renders selects on end
                const typeSelect = document.getElementById('triggerType');
                if (typeSelect) {
                    typeSelect.selectedIndex = 0;
                    M.FormSelect.init(typeSelect);
                }
                loadTriggerConfig();
            }
        });


        document.getElementById('delete-account-btn').addEventListener('click', function () {
            const fields = document.getElementById('delete-account-fields');
            if (fields.style.display === "none") {
                // First click: reveal the fields and change the button text.
                fields.style.display = "block";
                this.textContent = i18n_local[currentLang].deleteAccountButtonConfirm;
                document.getElementById('cancel-delete-account-btn').style.display = "block";
            } else {
                // Second click: trigger the delete account process.
                // For example, call your deleteAccount function.
                deleteAccount();
            }
        });
        document.getElementById('cancel-delete-account-btn').addEventListener('click', function () {
            const fields = document.getElementById('delete-account-fields');
            document.getElementById('delete-account-btn').textContent = i18n_local[currentLang].deleteAccountButton;
            fields.style.display = "none";
            this.style.display = "none";
        });

        document.getElementById('more-actions-select').addEventListener('change', function () {
            var action = this.value;
            switch (action) {
            case 'survey-data':
                fetchSurveyData();
                break;
            case 'event-triggers':
                showEventTriggers();
                break;
            case 'generate-survey':
                generateSurvey();
                break;
            }
            // Reset select to the default "More" option after selection
            this.selectedIndex = 0;
        });

        const rootList = document.getElementById('questions-list');
        // 1. 根列表：只处理顶层项目
		Sortable.create(rootList, {
		  animation: 150,
		  delay: 150,
		  delayOnTouchOnly: true,
		  fallbackTolerance: 5,
		  handle: '.drag-handle',
		  draggable: 'li.collection-item',      // allow both top and sub items
		  group: {
			name: 'shared',
			pull: true,                          // let roots pull out items
			put: true                            // let roots accept items
		  },
		  onMove: function(evt) {
			// Prevent groups from being moved into sub-lists
			const isGroup = evt.dragged.classList.contains('is-group-item');
			const isNesting = evt.to.closest('[data-group-index]');
			return !(isGroup && isNesting);
		  },
		  onAdd(evt) {
			// A sub-question was dragged out of a group into root
			const oldParent = evt.from;
			const oldIdx    = evt.oldDraggableIndex;
			const newIdx    = evt.newDraggableIndex;
			let moved;
			if (evt.to !== rootList) return;
			if (oldParent !== rootList) {
			  // it came from a sub-list: remove from that group's subQuestions
			  const groupIndex = parseInt(oldParent.dataset.groupIndex, 10);
			  moved = surveyItems[groupIndex].subQuestions.splice(oldIdx, 1)[0];
			} else {
			  // it came from root → unlikely here, but handle generically:
			  moved = surveyItems.splice(oldIdx, 1)[0];
			}
			// insert into top-level surveyItems
			surveyItems.splice(newIdx, 0, moved);
			renderAllItems();
		  },
		  onEnd(evt) {
			// Reorder within root list
			if (evt.from === rootList && evt.to === rootList) {
			  const [moved] = surveyItems.splice(evt.oldDraggableIndex, 1);
			  surveyItems.splice(evt.newDraggableIndex, 0, moved);
			  renderAllItems();
			}
		  }
		});

        window.addEventListener("resize", checkScreenSize);
        checkScreenSize();
    });

    async function deleteAccount() {
        const email = document.getElementById("delete-email").value.trim();
        const password = document.getElementById("delete-password").value;
        if (!email || !password) {
            M.toast({
                html: "Email and password are required",
                displayLength: 2000
            });
            return;
        }
        try {
            // Verify credentials via the login API
            const loginResponse = await fetch(`${BASE_URL}/api/login`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    email,
                    password
                })
            });
            const loginData = await loginResponse.json();
            if (!loginResponse.ok) {
                M.toast({
                    html: loginData.error || "Invalid credentials",
                    displayLength: 2000
                });
                return;
            }
            // Ensure the loginData user matches the currently logged-in user.
            if (loginData.userId !== localStorage.getItem("userId")) {
                M.toast({
                    html: "Provided credentials do not match the current account",
                    displayLength: 2000
                });
                return;
            }
            // If verified, prompt user to type "cancel" for confirmation
            const confirmation = prompt("Type 'cancel' to confirm account deletion:");
            if (confirmation !== "cancel") {
                M.toast({
                    html: "Account deletion cancelled",
                    displayLength: 2000
                });
                return;
            }
            // Call the delete user API
            const deleteResponse = await fetch(`${BASE_URL}/api/user/${currentUserId}`, {
                method: "DELETE",
                headers: {
                    Authorization: "Bearer " + currentUserToken,
                    "X-User-Id": currentUserId
                },
            });
            const deleteData = await deleteResponse.json();
            if (deleteResponse.ok) {
                M.toast({
                    html: "User account deleted successfully",
                    displayLength: 2000
                });
                // Clear local storage and redirect to login page
                localStorage.removeItem("userId");
                localStorage.removeItem("userToken");
                window.location.href = "login.html";
            } else {
                M.toast({
                    html: deleteData.error || "Failed to delete account",
                    displayLength: 2000
                });
            }
        } catch (err) {
            console.error(err);
            M.toast({
                html: "Error deleting account",
                displayLength: 2000
            });
        }
    };

    /***********************************************
     * MOBILE CLICK-OUTSIDE-TO-CLOSE SIDEBAR
     ***********************************************/
    function enableMobileClickOutsideToCloseSidebar() {
        // Only attach once
        if (!mobileClickOutsideHandler) {
            mobileClickOutsideHandler = function (e) {
                const sidebar = document.getElementById("sidebar");
                const toggleElements = document.querySelectorAll('[onclick="toggleSidebar()"]');
                // If it's not collapsed already and user clicks outside it => close
                if (!sidebar.classList.contains("collapsed")) {
                    if (!sidebar.contains(e.target) && !toggleElements[0].contains(e.target)) {
                        toggleSidebar();
                    }
                }
            };
            document.addEventListener("click", mobileClickOutsideHandler);
        }
    }

    function disableMobileClickOutsideToCloseSidebar() {
        if (mobileClickOutsideHandler) {
            document.removeEventListener("click", mobileClickOutsideHandler);
            mobileClickOutsideHandler = null;
        }
    }

    /***********************************************
     * SIDEBAR TOGGLE
     ***********************************************/
    function toggleSidebar() {
        const sidebar = document.getElementById("sidebar");
        const mainContent = document.getElementById("main-content");
        sidebar.classList.toggle("collapsed");
        if (sidebar.classList.contains("collapsed")) {
            mainContent.classList.add("no-sidebar");
        } else {
            mainContent.classList.remove("no-sidebar");
        }
    }

    /***********************************************
     * LANGUAGE SELECTION
     ***********************************************/
    document.addEventListener("DOMContentLoaded", function () {
        // Initialize Materialize modal
        const modalElems = document.querySelectorAll(".modal");
        M.Modal.init(modalElems, {
            onCloseEnd: function () {
                // Save the current settings when the modal closes
                const selectedLang = document.getElementById("language-select").value;
                const endpointUrl = document.getElementById("endpoint-url").value;

                localStorage.setItem("preferredLanguage", selectedLang);
                localStorage.setItem("surveyEndpoint", endpointUrl);

            },
        });

        // Get the language select element (make sure it's declared here)
        const langSelect = document.getElementById("language-select");
        // Detect iOS device
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        if (!isIOS) {
            // Only initialize Materialize's custom select on non-iOS devices.
            var elems = document.querySelectorAll("select");
            M.FormSelect.init(elems);
        } else {
            // For iOS, force the native select control to show by adding browser-default
            if (langSelect) {
                langSelect.classList.add("browser-default");
            }
        }

        // Load stored settings for language and endpoint URL
        let storedLang = localStorage.getItem("preferredLanguage") || "zh-TW";
        if (!i18n_local[storedLang]) {
            storedLang = "zh-TW";
        }

        document.getElementById("language-select").value = storedLang;
        setLanguage(storedLang);

        const storedEndpoint = localStorage.getItem("surveyEndpoint") || "";
        document.getElementById("endpoint-url").value = storedEndpoint;

    });
    function openSettingsModal() {
        const modal = M.Modal.getInstance(
                document.getElementById("settings-modal"));
        modal.open();
    }

    function setLanguage(lang) {
        localStorage.setItem("preferredLanguage", lang);
        currentLang = lang;

        // Update dropdown value
        const languageSelect = document.getElementById("language-select");
        if (languageSelect) {
            languageSelect.value = lang;
        }
        // Update UI text using i18n_local values...
        // document.getElementById("page-subtitle").textContent = i18n_local[currentLang].subtitle;
        document.getElementById("survey-title-label").textContent = i18n_local[lang].surveyTitleLabel;
        document.getElementById("add-question-text").textContent = i18n_local[currentLang].addQuestion;
        document.getElementById("add-group-text").textContent = i18n_local[currentLang].addGroup;
        document.getElementById("undo-text").textContent = i18n_local[currentLang].undo;
        document.getElementById("redo-text").textContent = i18n_local[currentLang].redo;
		document.getElementById("preview-text").textContent = i18n_local[currentLang].preview;
        document.getElementById("generate-text").textContent = i18n_local[currentLang].generate;
        document.getElementById("event-trigger-text").textContent = i18n_local[currentLang].eventTriggersTitle;
        document.getElementById("add-new-trigger-text").textContent = i18n_local[currentLang].addNewTrigger;
        document.getElementById("survey-title-label").textContent = i18n_local[currentLang].surveyTitleLabel;
        const bannerLabel = document.getElementById("survey-banner-label");
        if (bannerLabel) {
            bannerLabel.textContent = i18n_local[currentLang].bannerImageUrl;
        }
        const bannerInput = document.getElementById("survey-banner-input");
        if (bannerInput) {
            bannerInput.setAttribute("placeholder", i18n_local[currentLang].bannerImagePlaceholder);
        }
        document.getElementById("fetch-data-text").textContent = i18n_local[currentLang].fetchDataText;
        document.getElementById("add-question-text").textContent = i18n_local[lang].addQuestion;

        // Update Delete Account section texts concisely:
        document.querySelector('.delete-account-title').textContent = i18n_local[currentLang].deleteAccountTitle;
        document.querySelector('label[for="delete-email"]').textContent = i18n_local[currentLang].deleteEmailLabel;
        document.getElementById("delete-email").placeholder = i18n_local[currentLang].deleteEmailPlaceholder;
        document.querySelector('label[for="delete-password"]').textContent = i18n_local[currentLang].deletePasswordLabel;
        document.getElementById("delete-password").placeholder = i18n_local[currentLang].deletePasswordPlaceholder;
        document.getElementById("delete-account-btn").textContent = i18n_local[currentLang].deleteAccountButton;

        // Update spinner text
        const loadingTextEl = document.querySelector('.loading-text');
        if (loadingTextEl) {
            loadingTextEl.textContent = i18n_local[lang].processingText;
        }

        // Update tooltip for Menu button
        const menuBtn = document.querySelector('[onclick="toggleSidebar()"]');
        if (menuBtn) {
            menuBtn.setAttribute("data-tooltip", i18n_local[lang].menuTooltip);
        }

        // Update store button text if not already set by store selection
        const storeBtn = document.getElementById("storeButton");
        if (storeBtn && (!storeBtn.textContent || storeBtn.textContent.trim() === "選擇商店")) {
            storeBtn.textContent = i18n_local[lang].selectStoreTitle;
        }

        // Update Settings modal texts
        const settingsTitleEl = document.querySelector("#settings-modal h5");
        if (settingsTitleEl) {
            settingsTitleEl.textContent = i18n_local[lang].settingsTitle;
        }
        const langLabel = document.querySelector("#settings-modal label[for='language-select']");
        if (langLabel) {
            langLabel.textContent = i18n_local[lang].languageLabel;
        }
        const endpointLabel = document.querySelector("#settings-modal label[for='endpoint-url']");
        if (endpointLabel) {
            endpointLabel.textContent = i18n_local[lang].endpointUrlLabel;
        }
        const settingsFooterButtons = document.querySelectorAll("#settings-modal .modal-footer button");
        if (settingsFooterButtons.length >= 2) {
            settingsFooterButtons[0].textContent = i18n_local[lang].logout;
            settingsFooterButtons[1].textContent = i18n_local[lang].close;
        }

        // Update Survey Link modal texts
        const surveyLinkTitleEl = document.querySelector("#surveyLinkModal h4");
        if (surveyLinkTitleEl) {
            surveyLinkTitleEl.textContent = i18n_local[lang].surveyLinkTitle;
        }
        const copyBtn = document.getElementById("copyBtn");
        if (copyBtn) {
            copyBtn.innerHTML = '<i class="material-icons left">content_copy</i>' + i18n_local[lang].copy;
        }
        const goBtn = document.getElementById("goBtn");
        if (goBtn) {
            goBtn.innerHTML = '<i class="material-icons left">send</i>' + i18n_local[lang].goToSurvey;
        }
        const surveyLinkClose = document.querySelector("#surveyLinkModal .modal-footer a");
        if (surveyLinkClose) {
            surveyLinkClose.textContent = i18n_local[lang].close;
        }

        // Update Select Survey modal texts
        const selectSurveyTitleEl = document.querySelector("#selectSurveyModal h4");
        if (selectSurveyTitleEl) {
            selectSurveyTitleEl.textContent = i18n_local[lang].selectSurveyTitle;
        }
        // Update Import Survey button text in Select Survey modal footer
        const importSurveyBtn = document.getElementById("importSurveyBtn");
        if (importSurveyBtn) {
            importSurveyBtn.innerHTML = '<i class="material-icons left">download</i>' + i18n_local[lang].importSurvey;
        }
		const exportSurveyBtn = document.getElementById("exportSurveyBtn");
        if (exportSurveyBtn) {
            exportSurveyBtn.innerHTML = '<i class="material-icons left">upload</i>' + i18n_local[lang].exportSurvey;
        }		
        const confirmSurveyBtn = document.getElementById("confirmSurveyBtn");
        if (confirmSurveyBtn) {
            confirmSurveyBtn.textContent = i18n_local[lang].confirm;
        }

        // Update text for select store modal buttons
        const selectStoreModal = document.getElementById("selectStore");
        if (selectStoreModal) {
            const storeConfirm = selectStoreModal.querySelector(".modal-footer a:nth-child(1)");
            const storeCancel = selectStoreModal.querySelector(".modal-footer a:nth-child(2)");
            if (storeConfirm)
                storeConfirm.textContent = i18n_local[currentLang].confirm;
            if (storeCancel)
                storeCancel.textContent = i18n_local[currentLang].cancel;
        }

        // Update endpoint URL placeholder in settings modal
        const endpointInput = document.getElementById("endpoint-url");
        if (endpointInput) {
            endpointInput.setAttribute("placeholder", i18n_local[lang].endpointUrlPlaceholder);
        }

        // Update Import Survey modal texts
        const importSurveyTitleEl = document.querySelector("#importSurveyModal h4");
        if (importSurveyTitleEl) {
            importSurveyTitleEl.textContent = i18n_local[lang].importSurveyTitle;
        }

        // Update radio button labels in Import Survey modal
        const importModeFileLabel = document.getElementById("importModeFileLabel");
        if (importModeFileLabel) {
            importModeFileLabel.textContent = i18n_local[lang].importModeFile;
        }
        const importModeUrlLabel = document.getElementById("importModeUrlLabel");
        if (importModeUrlLabel) {
            importModeUrlLabel.textContent = i18n_local[lang].importModeUrl;
        }
        const importModeTextLabel = document.getElementById("importModeTextLabel");
        if (importModeTextLabel) {
            importModeTextLabel.textContent = i18n_local[lang].importModeText;
        }

        // Update Choose File button text
        const chooseFileBtn = document.getElementById("chooseFileBtn");
        if (chooseFileBtn) {
            chooseFileBtn.innerHTML = '<i class="material-icons left">download</i>' + i18n_local[lang].chooseFile;
        }

        // Update placeholder for URL import option
        const importUrlInput = document.getElementById("popupImportSurveyUrl");
        if (importUrlInput) {
            importUrlInput.setAttribute("placeholder", i18n_local[lang].enterUrlPlaceholder);
        }

        // Update placeholder for Text import option
        const importTextArea = document.getElementById("popupImportSurveyText");
        if (importTextArea) {
            importTextArea.setAttribute("placeholder", i18n_local[lang].pasteJsonPlaceholder);
        }

        // Update Import Survey modal footer buttons text
        const importModalFooterButtons = document.querySelectorAll("#importSurveyModal .modal-footer a");
        if (importModalFooterButtons.length >= 2) {
            importModalFooterButtons[0].textContent = i18n_local[lang].cancel;
            importModalFooterButtons[1].textContent = i18n_local[lang].importText;
        }

        document.getElementById("fetch-data-text").textContent = i18n_local[lang].fetchDataText;
        document.getElementById("surveyDataCloseBtn").textContent = i18n_local[lang].close;
        document.getElementById("surveyDataTitle").textContent = i18n_local[lang].surveyDataSummaryTitle;

        translateUI(lang, ["button", ".translate", "h4", "option"]);

        // Re-render items if necessary
        renderAllItems();
    }

	
	function translateTextNode(node, dict) {
	  const raw = node.textContent.trim();
	  if (!raw) return;

	  // 先直接比對
	  if (dict.hasOwnProperty(raw)) {
		node.textContent = dict[raw];
		return;
	  }

	  // 再處理 A++B++C 串接
	  if (raw.includes("++")) {
		const parts = raw.split("++").map(p => p.trim());
		node.textContent = parts.map(p => dict[p] ?? p).join(""); // 找不到就保留原字
	  }
	}

	
	function translateUI(lang, selectors) {
	  const dict = i18n_local[lang];
	  if (!dict) return;
	  selectors.forEach(sel => {
		document.querySelectorAll(sel).forEach(el => translateTextNode(el, dict));
	  });
	}

    /***********************************************
     * RENDER MASTER
     ***********************************************/
    function renderAllItems() {
        const container = document.getElementById("questions-and-groups");
        container.innerHTML = "";

        // Render each item: question or group
        surveyItems.forEach((item, index) => {
            if (item.type === "question") {
                container.appendChild(renderQuestionCard(item, index));
            } else if (item.type === "group") {
                container.appendChild(renderGroupCard(item, index));
            }
        });

        // Also re-render sidebar
        renderSidebarList();
    }

    /***********************************************
     * RENDER QUESTION CARD (for standalone and sub‐questions)
     ***********************************************/
    function renderQuestionCard(questionObj, index, {
        isSubQuestion = false,
        groupIndex = null
    } = {}) {
        // questionObj = { type: 'question', questionText, questionType, ... }
        const card = document.createElement("div");
        card.className = isSubQuestion ? "card question-card sub-question" : "card question-card";
        // For sub‐questions, include the group index in the ID
        card.id = isSubQuestion ? `question-card-${groupIndex}-${index}-sub` : `question-card-${index}`;
		card.dataset.itemIndex = isSubQuestion ? `${groupIndex}-${index}` : index.toString();

		card.addEventListener('mouseenter', handleCardFocus);
		card.addEventListener('mouseleave', handleCardBlur);
		card.addEventListener('click', handleCardFocus);
	

        const cardContent = document.createElement("div");
        cardContent.className = "card-content";



  


		// —— 修改開始：用一個 flex row 讓「問題內容」跟「問題編號」同一行 ——  
		const headerRow = document.createElement("div");
		headerRow.style.display = "flex";
		headerRow.style.justifyContent = "space-between";
		// align-items 用 flex-start 或 baseline 都可以，但建議用 flex-start 讓 Label 的頂端對齊
		headerRow.style.alignItems = "baseline";
		headerRow.style.marginBottom = "4px";    // headerRow 與下方 "問題文字" 之間留一些縱向間距
		// 如果擔心換行，可以整行一次設定
		headerRow.style.whiteSpace = "nowrap";

		// 1) 左側：問題內容 Label
		const questionLabel = document.createElement("label");
		questionLabel.textContent = i18n_local[currentLang].questionTextLabel; // "問題內容"
		// 確保不被放大撐滿：  
		questionLabel.style.flex = "0 0 auto";
		// （可加上字體大小或粗細，看你 UI 需求）
		// questionLabel.style.fontWeight = "bold";
		// questionLabel.style.fontSize = "1rem";

		// 2) 右側：問題編號 (ID) + disabled input
		const idContainer = document.createElement("div");
		idContainer.style.display = "flex";
		// 這裡用 baseline 會讓 label 和 input 的文字基線對齊，看起來更工整
		idContainer.style.alignItems = "baseline";
		idContainer.style.flex = "0 0 auto";
		idContainer.style.gap = "4px";            // Label 與 input 之間留點間距
		idContainer.style.whiteSpace = "nowrap";   // 不要自動換行

		const idLabel = document.createElement("label");
		idLabel.textContent = "問題編號 (ID):";
		// 同樣避免自動撐滿
		idLabel.style.flex = "0 0 auto";
		// 你也可以微調文字顏色或大小
		// idLabel.style.fontSize = "0.9rem";
		// idLabel.style.color = "#777";

		const idField = document.createElement("input");
		idField.type = "text";
		idField.className = "input-field";
		idField.value = questionObj.id;   // 把 ID 填進去
		idField.disabled = true;
		// 重點：把 input 改成 inline-block，並限制寬度，絕對不要讓它撐滿 100%  
		idField.style.display = "inline-block";
		idField.style.width = "60px";   // 依照你的 ID 長度自由調整（例：60px、80px…）

		idField.style.padding = "3px 4px"; // 上下改為 0px、左右保留 4px
		idField.style.lineHeight = "1.2"; // 確保文字與底線之間間距更緊湊
		idField.style.height = "auto"; // 取消 input 預設高度，讓 inner text 緊貼底線
		// 將 margin 歸零，避免預設的上下 margin 造成額外換行
		idField.style.margin = "0";

		// 把 label + input 都放到 idContainer 裡
		idContainer.appendChild(idLabel);
		idContainer.appendChild(idField);

		// 完成 headerRow：左放 questionLabel，右放 idContainer
		headerRow.appendChild(questionLabel);
		headerRow.appendChild(idContainer);

		// 把整個 headerRow 加回 cardContent
		cardContent.appendChild(headerRow);
		// —— 修改結束 ——  


        const inputText = document.createElement("input");
        inputText.type = "text";
        inputText.className = "input-field";
        inputText.value = questionObj.questionText || "";
        inputText.oninput = (e) => {
            questionObj.questionText = e.target.value;
            renderSidebarList();
        };
        cardContent.appendChild(inputText);

        // QUESTION TYPE
        const typeLabel = document.createElement("label");
        typeLabel.textContent = i18n_local[currentLang].questionTypeLabel;
        cardContent.appendChild(typeLabel);

        const selectType = document.createElement("select");
        selectType.className = "browser-default question-type-select";
        selectType.onchange = (e) => {
            questionObj.questionType = e.target.value;
            // Clear specialized fields if switching
            if (
                e.target.value === "text" ||
                e.target.value === "date" ||
                e.target.value === "longtext") {
                questionObj.options = [];
                delete questionObj.maxStars;
                delete questionObj.answer;
            }
            if (e.target.value === "radio" || e.target.value === "checkbox") {
                questionObj.options = questionObj.options || [];
                delete questionObj.maxStars;
                delete questionObj.answer;
            }
            if (e.target.value === "stars") {
                questionObj.maxStars = questionObj.maxStars || 5;
                questionObj.options = [];
                delete questionObj.answer;
            }
            if (e.target.value === "uploadImage") {
                // For image upload, initialize answer as empty.
                questionObj.answer = questionObj.answer || "";
                questionObj.options = [];
                delete questionObj.maxStars;
            }
            renderAllItems();
        };

        const typeOptions = [{
                value: "text",
                label: i18n_local[currentLang].textInput
            }, {
                value: "radio",
                label: i18n_local[currentLang].radioInput
            }, {
                value: "checkbox",
                label: i18n_local[currentLang].checkboxInput
            }, {
                value: "date",
                label: i18n_local[currentLang].dateInput
            }, {
                value: "longtext",
                label: i18n_local[currentLang].longtextInput
            }, {
                value: "stars",
                label: i18n_local[currentLang].starsInput
            }, {
                value: "uploadImage",
                label: i18n_local[currentLang].uploadImage
            }
        ];
        typeOptions.forEach((opt) => {
            const optEl = document.createElement("option");
            optEl.value = opt.value;
            optEl.text = opt.label;
            selectType.appendChild(optEl);
        });
        selectType.value = questionObj.questionType || "text";
        cardContent.appendChild(selectType);

        // REQUIRED + COMPACT row
        const switchesRow = document.createElement("div");
        switchesRow.style.display = "flex";
        switchesRow.style.gap = "1.5em";
        switchesRow.style.margin = "10px 0";

        // REQUIRED SWITCH
        const requiredSwitchContainer = document.createElement("div");
        requiredSwitchContainer.className = "switch required-switch";
        requiredSwitchContainer.innerHTML = `
          <label>
            <input type="checkbox" ${questionObj.required ? "checked" : ""}/>
            <span class="lever"></span>
            ${i18n_local[currentLang].requiredLabel}
          </label>
        `;
        requiredSwitchContainer.querySelector("input").addEventListener("change", (e) => {
            questionObj.required = e.target.checked;
        });
        switchesRow.appendChild(requiredSwitchContainer);

        // COMPACT SWITCH (radio/checkbox only)
        if (questionObj.questionType === "radio" || questionObj.questionType === "checkbox") {
            const compackSwitchContainer = document.createElement("div");
            compackSwitchContainer.className = "switch compack-switch";
            compackSwitchContainer.innerHTML = `
            <label>
              <input type="checkbox" ${questionObj.compack ? "checked" : ""}/>
              <span class="lever"></span>
              ${i18n_local[currentLang].compackLabel}
            </label>
          `;
            compackSwitchContainer
            .querySelector("input")
            .addEventListener("change", (e) => {
                questionObj.compack = e.target.checked;
            });
            switchesRow.appendChild(compackSwitchContainer);
        } else {
            questionObj.compack = false;
        }
        cardContent.appendChild(switchesRow);

        // OPTIONS (for radio/checkbox)
        if (questionObj.questionType === "radio" || questionObj.questionType === "checkbox") {
            const optionsLabel = document.createElement("label");
            optionsLabel.textContent = i18n_local[currentLang].optionsLabel;
            cardContent.appendChild(optionsLabel);

            questionObj.options = questionObj.options || [];
            questionObj.options.forEach((opt, optIndex) => {
                // Convert plain string to object if necessary.
                if (typeof opt !== "object") {
                    questionObj.options[optIndex] = {
                        text: opt,
                        hasTextInput: false
                    };
                    opt = questionObj.options[optIndex];
                }

                // Create a container row.
                const rowDiv = document.createElement("div");
                rowDiv.className = "row";

                // --- Option Text Input Column ---
                const colInputDiv = document.createElement("div");
                colInputDiv.className = "col s8";
                const optionInput = document.createElement("input");
                optionInput.type = "text";
                optionInput.className = "input-field";
                optionInput.value = opt.text;
                optionInput.oninput = (e) => {
                    questionObj.options[optIndex].text = e.target.value;
                };
                colInputDiv.appendChild(optionInput);
                rowDiv.appendChild(colInputDiv);

                // --- "Require Extra Text" Toggle Column ---
                
				
// 原本範例位置（參考：renderQuestionCard 內針對 checkbox 額外文字的程式）
// 【…】略
const colToggleDiv = document.createElement("div");
colToggleDiv.className = "col s2";  // 佔 2/12 寬度

// 建立 label 容器
const extraLabel = document.createElement("label");
// 隱藏文字，只顯示 icon
extraLabel.style.fontSize = "0";

// 1) 建立勾選框
const extraCheckbox = document.createElement("input");
extraCheckbox.type = "checkbox";
extraCheckbox.classList.add("filled-in");
extraCheckbox.checked = opt.hasTextInput;
extraCheckbox.onchange = (e) => {
  questionObj.options[optIndex].hasTextInput = e.target.checked;
};
extraLabel.appendChild(extraCheckbox);

// 2) 建立 icon，用於代表「補充文字」功能
const extraIconSpan = document.createElement("span");
extraIconSpan.classList.add("material-icons");
// 這裡使用 text_fields 作為示意 icon，你也可以改為其他較直覺的圖示
extraIconSpan.textContent = "notes";
// 把本地化的「補充文字」放到 data-tooltip，供 Tooltip 顯示
extraIconSpan.setAttribute("data-tooltip", i18n_local[currentLang].extraText);
extraIconSpan.classList.add("tooltipped");
extraIconSpan.style.paddingLeft = "1.6em";

// 初始化 Materialize 的 Tooltip
M.Tooltip.init(extraIconSpan, {enterDelay: 300});

extraLabel.appendChild(extraIconSpan);
colToggleDiv.appendChild(extraLabel);
rowDiv.appendChild(colToggleDiv);

				
				

                // --- Remove Option Button Column ---
                const colButtonDiv = document.createElement("div");
                colButtonDiv.className = "col s2 right-align";
                const removeBtn = document.createElement("button");
                removeBtn.className = "btn-small red waves-effect waves-light";
                removeBtn.textContent = i18n_local[currentLang].removeOption;
                removeBtn.onclick = () => {
                    pushUndo({
                        type: "delete-option",
                        parentIndex: index,
                        parentType: isSubQuestion ? "group-sub" : "main",
                        optionIndex: optIndex,
                        deletedOption: opt,
                    });
                    questionObj.options.splice(optIndex, 1);
                    renderAllItems();
                };
                colButtonDiv.appendChild(removeBtn);
                rowDiv.appendChild(colButtonDiv);

                // Append the constructed row to the card content.
                cardContent.appendChild(rowDiv);
            });

            // ADD OPTION BUTTON
            const addOptionBtn = document.createElement("button");
            addOptionBtn.className = "btn grey darken-2 waves-effect waves-light";
            addOptionBtn.style.marginTop = "10px";
            addOptionBtn.style.marginLeft = "10px";
            addOptionBtn.innerHTML = `
            <i class="material-icons left">add</i>${i18n_local[currentLang].addOption}
          `;
            addOptionBtn.onclick = () => {
                questionObj.options.push("");
                renderAllItems();
            };
            cardContent.appendChild(addOptionBtn);
        }

        // STAR RATING
        if (questionObj.questionType === "stars") {
            const maxStarsLabel = document.createElement("label");
            maxStarsLabel.textContent = i18n_local[currentLang].maxStarsLabel;
            cardContent.appendChild(maxStarsLabel);
            const maxStarsInput = document.createElement("input");
            maxStarsInput.type = "number";
            maxStarsInput.value = questionObj.maxStars || 5;
            maxStarsInput.min = "1";
            maxStarsInput.oninput = (e) => {
                questionObj.maxStars = parseInt(e.target.value, 10);
            };
            cardContent.appendChild(maxStarsInput);
        }

        // NEW: UPLOAD IMAGE QUESTION HANDLER
        if (questionObj.questionType === "uploadImage") {
            /*
            const uploadLabel = document.createElement("label");
            uploadLabel.textContent = i18n_local[currentLang].uploadImage;
            cardContent.appendChild(uploadLabel);

            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.accept = "image/*";
            fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
            const reader = new FileReader();
            reader.onload = function(evt) {
            questionObj.answer = evt.target.result;
            previewImg.style.display = "block";
            previewImg.src = evt.target.result;
            };
            reader.readAsDataURL(file);
            }
            };
            cardContent.appendChild(fileInput);

            // Preview image element:
            const previewImg = document.createElement("img");
            previewImg.style.maxWidth = "100%";
            previewImg.style.marginTop = "10px";
            previewImg.style.display = questionObj.answer ? "block" : "none";
            if (questionObj.answer) {
            previewImg.src = questionObj.answer;
            }
            cardContent.appendChild(previewImg);
             */
        }

        /********* ACTION BUTTONS *********/
        const cardAction = document.createElement("div");
        cardAction.className = "card-action question-actions";

        // Move up button
        const moveUpBtn = document.createElement("button");
        moveUpBtn.className = "btn-small grey waves-effect waves-light";
        moveUpBtn.innerHTML = `<i class="material-icons">arrow_upward</i>`;
        moveUpBtn.style.marginRight = "5px";
        moveUpBtn.title = i18n_local[currentLang].moveUp;

        // Move down button
        const moveDownBtn = document.createElement("button");
        moveDownBtn.className = "btn-small grey waves-effect waves-light";
        moveDownBtn.innerHTML = `<i class="material-icons">arrow_downward</i>`;
        moveDownBtn.style.marginRight = "5px";
        moveDownBtn.title = i18n_local[currentLang].moveDown;

        // Delete button
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn-small red waves-effect waves-light";
        deleteBtn.innerHTML = `<i class="material-icons">delete</i>`;
        deleteBtn.title = i18n_local[currentLang].deleteButton;

        if (!isSubQuestion) {
            // For standalone questions, attach standard actions…
            moveUpBtn.onclick = () => moveItemUp(index);
            moveDownBtn.onclick = () => moveItemDown(index);
            deleteBtn.onclick = () => deleteQuestion(index);
            // ...and add a **Group** button to convert the question into a group.
            const groupBtn = document.createElement("button");
            groupBtn.className = "btn-small blue waves-effect waves-light";
            groupBtn.innerHTML = `<i class="material-icons">group</i>`;
            groupBtn.title = i18n_local[currentLang].convertToGroup;
            groupBtn.onclick = () => convertQuestionToGroup(index);
            cardAction.appendChild(groupBtn);
        } else {
            // For sub‐questions, attach sub‐question actions…
            moveUpBtn.onclick = () => moveSubQuestionUp(groupIndex, index);
            moveDownBtn.onclick = () => moveSubQuestionDown(groupIndex, index);
            deleteBtn.onclick = () => deleteSubQuestion(groupIndex, index);
            // ...and add an **Unpack** button to remove it from the group.
            const unpackBtn = document.createElement("button");
            unpackBtn.className = "btn-small orange waves-effect waves-light";
            unpackBtn.innerHTML = `<i class="material-icons">call_split</i>`;
            unpackBtn.title = i18n_local[currentLang].unpackToStandalone;
            unpackBtn.onclick = () => unpackSubQuestion(groupIndex, index);
            cardAction.appendChild(unpackBtn);
        }

        // Append the common action buttons
        cardAction.appendChild(moveUpBtn);
        cardAction.appendChild(moveDownBtn);
        cardAction.appendChild(deleteBtn);

        card.appendChild(cardContent);
        card.appendChild(cardAction);
        return card;
    }

	function handleCardFocus(event) {
	  const card = event.currentTarget;
	  const isGroup = card.classList.contains('group-card');
	  const selector = isGroup ? `[data-group-index="${card.dataset.groupIndex}"]` 
							 : `[data-item-index="${card.dataset.itemIndex}"]`;
	  
	  document.querySelectorAll('#questions-list .highlighted').forEach(el => {
		el.classList.remove('highlighted');
	  });
	  
	  const listItem = document.querySelector(`#questions-list ${selector}`);
	  if (listItem) {
		listItem.classList.add('highlighted');
		// Smooth scroll sidebar to show the item
		listItem.scrollIntoView({
		  behavior: 'smooth',
		  block: 'nearest'
		});
	  }
	}

	function handleCardBlur() {
	  // Optional: Remove highlight after delay if needed
	  setTimeout(() => {
		document.querySelectorAll('#questions-list .highlighted').forEach(el => {
		  el.classList.remove('highlighted');
		});
	  }, 2000);
	}
    /***********************************************
     * NEW FUNCTIONS: CONVERT & UNPACK
     ***********************************************/
    function convertQuestionToGroup(index) {
        // Take a standalone question and convert it to a group.
        // Here we “wrap” the question inside a group so that it now has sub‐questions.
        const question = surveyItems[index];
        const group = {
            type: "group",
            id: question.id, // reuse the question id or generate a new one as desired
            groupTitle: question.questionText || "",
            anchorQuestionId: null,
            anchorValuesToShow: [],
            // Place the original question as the first sub‐question:
            subQuestions: [question]
        };
        surveyItems[index] = group;
        renderAllItems();
    }

    function unpackSubQuestion(groupIndex, subIndex) {
		// 1) Remove the question from the group’s subQuestions
		const groupItem = surveyItems[groupIndex];
		const question = groupItem.subQuestions.splice(subIndex, 1)[0];

		// 2) Insert it into surveyItems immediately after the group
		surveyItems.splice(groupIndex + 1, 0, question);
        renderAllItems();
    }

    /***********************************************
     * UPDATE GROUP CARD RENDERING
     * Add a drop zone so that standalone questions can be dragged into a group.
     ***********************************************/
    function renderGroupCard(groupObj, index) {
        const card = document.createElement("div");
        card.className = "card group-card";
        card.id = `group-card-${index}`;
		card.dataset.groupIndex = index.toString();
		
		
		card.addEventListener('mouseenter', handleCardFocus);
		card.addEventListener('mouseleave', handleCardBlur);
		card.addEventListener('click', handleCardFocus);

        const cardContent = document.createElement("div");
        cardContent.className = "card-content";

        // GROUP TITLE
		const groupTitleContainer = document.createElement("div");
		groupTitleContainer.className = "group-title-header";

		const groupTitleLabel = document.createElement("label");
		groupTitleLabel.textContent = i18n_local[currentLang].groupTitleLabel;
		groupTitleLabel.style.fontWeight = "bold";
        const groupTitleInput = document.createElement("input");
        groupTitleInput.type = "text";
        groupTitleInput.value = groupObj.groupTitle || "";
        groupTitleInput.oninput = (e) => {
            groupObj.groupTitle = e.target.value;
            renderSidebarList();
        };
		groupTitleContainer.appendChild(groupTitleLabel);
		groupTitleContainer.appendChild(groupTitleInput);
		cardContent.appendChild(groupTitleContainer);

        // ANCHOR QUESTION SELECT
        const anchorLabel = document.createElement("label");
        anchorLabel.textContent = i18n_local[currentLang].anchorQuestionLabel;
        cardContent.appendChild(anchorLabel);

        const anchorSelect = document.createElement("select");
        anchorSelect.className = "browser-default";
        const allQuestions = surveyItems.filter(item => item.type === "question");
        // Option: no anchor
        {
            const optNone = document.createElement("option");
            optNone.value = "";
            optNone.text = `-- ${i18n_local[currentLang].anchorNoQuestion} --`;
            anchorSelect.appendChild(optNone);
        }
        // All question items
        allQuestions.forEach((qItem) => {
            const opt = document.createElement("option");
            opt.value = qItem.id;
            opt.text = qItem.questionText
                 ? qItem.questionText.substring(0, 40)
                 : `Q# ${qItem.id}`;
            anchorSelect.appendChild(opt);
        });
        anchorSelect.value = groupObj.anchorQuestionId || "";
        anchorSelect.onchange = (e) => {
            groupObj.anchorQuestionId = e.target.value ? parseInt(e.target.value, 10) : null;
            renderAllItems(); // re-render to update the anchor values dropdown immediately
        };
        cardContent.appendChild(anchorSelect);

        // ANCHOR VALUES (Replace text input with multiple select)
        const anchorValuesLabel = document.createElement("label");
        anchorValuesLabel.textContent = i18n_local[currentLang].anchorValuesLabel;
        cardContent.appendChild(anchorValuesLabel);

        // Create a multiple select element
        const anchorValuesSelect = document.createElement("select");
        anchorValuesSelect.multiple = true;
        anchorValuesSelect.style.height = "auto"; // adjust as needed

        // Find the anchor question from surveyItems using groupObj.anchorQuestionId
        let anchorQuestionOptions = [];
        if (groupObj.anchorQuestionId) {
            const anchorQuestion = surveyItems.find(q => q.type === "question" && q.id == groupObj.anchorQuestionId);
            if (anchorQuestion) {
                if (anchorQuestion.questionType === "radio" || anchorQuestion.questionType === "checkbox") {
                    anchorQuestionOptions = anchorQuestion.options || [];
                } else if (anchorQuestion.questionType === "stars") {
                    // Generate options from 1 to the star count
                    const maxStars = anchorQuestion.maxStars || 5;
                    anchorQuestionOptions = [];
                    for (let i = 1; i <= maxStars; i++) {
                        anchorQuestionOptions.push(i.toString());
                    }
                }
            }
        }

        // Populate the select element with options
        if (anchorQuestionOptions.length === 0) {
            // Add a default option if there are no choices
            const defaultOpt = document.createElement("option");
            defaultOpt.value = "";
            defaultOpt.text = i18n_local[currentLang].noOptionsAvailable;
            anchorValuesSelect.appendChild(defaultOpt);
        } else {
            anchorQuestionOptions.forEach(option => {
                const optEl = document.createElement("option");
                // If the option is an object, use its "text" property; otherwise, use the option directly.
                const optionText = typeof option === 'object' ? option.text : option;
                optEl.value = optionText;
                optEl.text = optionText;
                // Mark the option as selected if it is already in groupObj.anchorValuesToShow
                if (groupObj.anchorValuesToShow && groupObj.anchorValuesToShow.includes(optionText)) {
                    optEl.selected = true;
                }
                anchorValuesSelect.appendChild(optEl);
            });
        }

        // Update groupObj.anchorValuesToShow when selection changes
        anchorValuesSelect.onchange = (e) => {
            const selectedOptions = Array.from(e.target.selectedOptions).map(opt => opt.value);
            groupObj.anchorValuesToShow = selectedOptions;
        };

        cardContent.appendChild(anchorValuesSelect);
        // Delay initialization to ensure the element is attached
        setTimeout(() => {
            M.FormSelect.init(document.querySelectorAll('select[multiple]'));
        }, 0);

        // SUB–QUESTIONS CONTAINER
        const subQuestionsContainer = document.createElement("div");
        subQuestionsContainer.style.marginTop = "20px";
        groupObj.subQuestions = groupObj.subQuestions || [];

        groupObj.subQuestions.forEach((sq, sqIndex) => {
            const subQCard = renderQuestionCard(sq, sqIndex, {
                isSubQuestion: true,
                groupIndex: index
            });
            subQuestionsContainer.appendChild(subQCard);
        });

        // ADD BUTTON: To add a new sub–question manually.
        const addSubQuestionBtn = document.createElement("button");
        addSubQuestionBtn.className = "btn green waves-effect waves-light";
        addSubQuestionBtn.style.marginTop = "10px";
        addSubQuestionBtn.innerHTML = `<i class="material-icons left">add</i>${i18n_local[currentLang].addQuestion}`;
        addSubQuestionBtn.onclick = () => {
            const newQ = {
                type: "question",
                id: getUniqueId(),
                questionText: "",
                questionType: "text",
                required: false,
                compack: false,
                options: [],
            };
            groupObj.subQuestions.push(newQ);
            renderAllItems();
            // Optionally scroll to the new sub–question
            setTimeout(() => {
                const subIndex = groupObj.subQuestions.length - 1;
                const newCard = document.getElementById(`question-card-${index}-${subIndex}-sub`);
                if (newCard) {
                    newCard.scrollIntoView({
                        behavior: "smooth"
                    });
                }
            }, 0);
        };
        subQuestionsContainer.appendChild(addSubQuestionBtn);

        cardContent.appendChild(subQuestionsContainer);

        // GROUP CARD ACTIONS (move up, move down, delete group)
        const cardAction = document.createElement("div");
        cardAction.className = "card-action group-actions";

        const moveUpBtn = document.createElement("button");
        moveUpBtn.className = "btn-small grey waves-effect waves-light";
        moveUpBtn.innerHTML = `<i class="material-icons">arrow_upward</i>`;
        moveUpBtn.style.marginRight = "5px";
        moveUpBtn.title = i18n_local[currentLang].moveUp;
        moveUpBtn.onclick = () => moveItemUp(index);

        const moveDownBtn = document.createElement("button");
        moveDownBtn.className = "btn-small grey waves-effect waves-light";
        moveDownBtn.innerHTML = `<i class="material-icons">arrow_downward</i>`;
        moveDownBtn.style.marginRight = "5px";
        moveDownBtn.title = i18n_local[currentLang].moveDown;
        moveDownBtn.onclick = () => moveItemDown(index);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn-small red waves-effect waves-light";
        deleteBtn.innerHTML = `<i class="material-icons">delete</i>`;
        deleteBtn.title = i18n_local[currentLang].deleteButton;
        deleteBtn.onclick = () => deleteGroup(index);

        cardAction.appendChild(moveUpBtn);
        cardAction.appendChild(moveDownBtn);
        cardAction.appendChild(deleteBtn);

        card.appendChild(cardContent);
        card.appendChild(cardAction);
        return card;
    }

    /***********************************************
     * RENDER SIDEBAR
     ***********************************************/
	 
	function highlightCorrespondingCard(card) {
	  // Clear all card highlights
	  document.querySelectorAll('.question-card.highlighted, .group-card.highlighted').forEach(el => {
		el.classList.remove('highlighted');
	  });

	  card.classList.add('highlighted');


	}
	 
    function renderSidebarList() {
        const listContainer = document.getElementById("questions-list");
        listContainer.innerHTML = "";

        surveyItems.forEach((item, index) => {
            if (item.type === "question") {
                // Render top-level standalone question
                const listItem = document.createElement("li");
                listItem.className = "collection-item";
                listItem.dataset.type = "top";
                listItem.dataset.index = index;
				listItem.dataset.itemIndex = index;


                // Display index circle and text
                const indexCircle = document.createElement("span");
                indexCircle.className = "list-index-circle";
                indexCircle.textContent = index + 1;
                listItem.appendChild(indexCircle);

                const textSpan = document.createElement("span");
                textSpan.textContent = item.questionText
                     ? item.questionText.substring(0, 40) + (item.questionText.length > 40 ? "..." : "")
                     : i18n_local[currentLang].questionPlaceholder + (index + 1);
                listItem.appendChild(textSpan);

                // drag-and-drop handle
                const handleSpan = document.createElement("span");
                handleSpan.className = "drag-handle material-icons";
                handleSpan.textContent = "drag_indicator";

                listItem.appendChild(handleSpan);

                // On click, scroll to question card
                listItem.onclick = () => {
                    const cardId = `question-card-${index}`;
                    const targetCard = document.getElementById(cardId);
                    if (targetCard) {
                        const elementPosition = targetCard.getBoundingClientRect().top;
                        const offsetPosition = elementPosition + window.pageYOffset - 100;
                        window.scrollTo({
                            top: offsetPosition,
                            behavior: "smooth"
                        });
						highlightCorrespondingCard(targetCard);
                    }
                };
                addContextMenuAndSwipeForStandalone(listItem, index);
                listContainer.appendChild(listItem);
            } else if (item.type === "group") {
                // Render group header
                const groupItem = document.createElement("li");
                groupItem.className = "collection-item is-group-item";
                groupItem.dataset.type = "top";
                groupItem.dataset.index = index;
				groupItem.dataset.groupIndex = index;

                const indexCircle = document.createElement("span");
                indexCircle.className = "list-index-circle group-index-circle";
                indexCircle.textContent = index + 1;
                groupItem.appendChild(indexCircle);

                const textSpan = document.createElement("span");
                textSpan.textContent = item.groupTitle
                     ? item.groupTitle.substring(0, 40) + (item.groupTitle.length > 40 ? "..." : "")
                     : i18n_local[currentLang].groupPlaceholder + (index + 1);
                groupItem.appendChild(textSpan);

                // Drag handle for group
                const handleSpan = document.createElement("span");
                handleSpan.className = "drag-handle material-icons";
                handleSpan.textContent = "drag_indicator";
                groupItem.appendChild(handleSpan);

                groupItem.onclick = () => {
                    const cardId = `group-card-${index}`;
                    const targetCard = document.getElementById(cardId);
                    if (targetCard) {
                        const elementPosition = targetCard.getBoundingClientRect().top;
                        const offsetPosition = elementPosition + window.pageYOffset - 100;
                        window.scrollTo({
                            top: offsetPosition,
                            behavior: "smooth"
                        });
                    }
                };

                listContainer.appendChild(groupItem);
				
				
				// 1) Always create a UL for the group, *before* checking length:
				const subList = document.createElement("ul");
				subList.dataset.groupIndex = index;
				subList.style.listStyle    = "none";
				subList.style.paddingLeft  = "5px";
				

				// 2) If there *are* subQuestions, render them:
				if (item.subQuestions && item.subQuestions.length > 0) {
                    // For each sub–question, create an LI with its own drop handler.
					if (item.subQuestions && item.subQuestions.length > 0) {
					    item.subQuestions.forEach((subItem, subIndex) => {
					        const subListItem = document.createElement("li");
					        subListItem.className = "collection-item";
					        subListItem.dataset.type = "sub";
					        subListItem.dataset.groupIndex = index;
					        subListItem.dataset.subIndex = subIndex;
					        subListItem.dataset.itemIndex = `${index}-${subIndex}`;

					        // Display text for the sub–question
					        let subDisplayText = "";
					        if (subItem.questionText) {
					            subDisplayText = subItem.questionText.substring(0, 40) + (subItem.questionText.length > 40 ? "..." : "");
					        } else {
					            subDisplayText = i18n_local[currentLang].questionPlaceholder + (subIndex + 1);
					        }
					        const subTextSpan = document.createElement("span");
					        subTextSpan.textContent = subDisplayText;
					        subListItem.appendChild(subTextSpan);

					        // Drag handle for subitem
					        const subHandleSpan = document.createElement("span");
					        subHandleSpan.className = "drag-handle material-icons";
					        subHandleSpan.textContent = "drag_indicator";
					        subListItem.appendChild(subHandleSpan);

					        // On click, scroll to sub–question card.
					        subListItem.onclick = () => {
					            const targetCard = document.getElementById(`question-card-${index}-${subIndex}-sub`);
					            if (targetCard) {
					                const elementPosition = targetCard.getBoundingClientRect().top;
					                const offsetPosition = elementPosition + window.pageYOffset - 100;
					                window.scrollTo({
					                    top: offsetPosition,
					                    behavior: "smooth"
					                });
					                highlightCorrespondingCard(targetCard);
					            }
					        };
					        addContextMenuAndSwipeForSub(subListItem, index, subIndex);
					        subList.appendChild(subListItem);
					    });
					}
				
				}
				
				
				// Always create the placeholder but hide if subQuestions exist
				const placeholder = document.createElement("li");
				placeholder.className = "collection-placeholder";
				placeholder.style.display = item.subQuestions?.length ? "none" : "block"; // Add this line
				// ...rest of placeholder setup...

				subList.appendChild(placeholder);
				
				listContainer.appendChild(subList);


            }
        });

        // 2. 子列表：每个组内部子问题可拖拽，禁止跨组
		function initNestedSortables() {
			const rootList = document.getElementById('questions-list');  
		  document
			.querySelectorAll('#questions-list ul[data-group-index]')
			.forEach(subList => {
			  const groupIndex = parseInt(subList.dataset.groupIndex, 10);
			  Sortable.create(subList, {
				animation: 150,
				delay: 150,
				delayOnTouchOnly: true,
				fallbackTolerance: 5,
				handle: '.drag-handle',
				draggable: 'li:not(.collection-placeholder)',
				emptyInsertThreshold: 30,
				group: {
				  name: 'shared',
				  pull: true,    // allow dragging out of this group
				  put: true
				},
				onMove: function(evt) {
					// Explicitly reject groups in sub-lists
					return !evt.dragged.classList.contains('is-group-item');
				  },
				onAdd(evt) {
					const oldParent = evt.from;
					const newParent = evt.to;
					const oldIdx    = evt.oldDraggableIndex;
					const newIdx    = evt.newDraggableIndex;

					// Remove placeholder if exists (new important logic)
					const placeholder = newParent.querySelector('.collection-placeholder');
					if (placeholder) {
						placeholder.style.display = "none"; // Hide placeholder
					}

					// re-compute groupIndex now that placeholder is gone
					let groupIndex = parseInt(newParent.dataset.groupIndex, 10);

					let moved;
					if (oldParent === rootList) {
					  moved = surveyItems.splice(oldIdx, 1)[0];
					  if (oldIdx < groupIndex) groupIndex -= 1;
					} else {
					  const srcGroup = parseInt(oldParent.dataset.groupIndex, 10);
					  moved = surveyItems[srcGroup].subQuestions.splice(oldIdx, 1)[0];
					}

					surveyItems[groupIndex].subQuestions.splice(newIdx, 0, moved);
					renderAllItems();
				},
				onEnd(evt) {
					if (evt.from === evt.to) {
					  const groupIndex = parseInt(evt.from.dataset.groupIndex, 10);
					  const arr = surveyItems[groupIndex].subQuestions;
					  const [moved] = arr.splice(evt.oldDraggableIndex, 1);
					  arr.splice(evt.newDraggableIndex, 0, moved);
					  renderAllItems();
					}
				}
			  });
			});
		}

        initNestedSortables();

    }

    // For standalone questions: attach right-click and swipe handlers to convert to group
    function addContextMenuAndSwipeForStandalone(listItem, index) {
        listItem.addEventListener("contextmenu", function (e) {
            e.preventDefault();
            showContextMenu(e.pageX, e.pageY, [{
                        label: i18n_local[currentLang].convertToGroup || "Convert to Group",
                        action: function () {
                            convertQuestionToGroup(index);
                        }
                    }
                ]);
            return false;
        });
        addSwipeListener(listItem, function (direction) {
            if (direction === "left") {
                showSlideAction(listItem, '<i class="material-icons">group_work</i>', function () {
                    convertQuestionToGroup(index);
                });
            }
        });
    }

    // For sub‑questions: attach right-click and swipe handlers to unpack to standalone
    function addContextMenuAndSwipeForSub(listItem, groupIndex, subIndex) {
        listItem.addEventListener("contextmenu", function (e) {
            e.preventDefault();
            showContextMenu(e.pageX, e.pageY, [{
                        label: i18n_local[currentLang].unpackToStandalone || "Unpack to Standalone",
                        action: function () {
                            unpackSubQuestion(groupIndex, subIndex);
                        }
                    }
                ]);
            return false;
        });
        addSwipeListener(listItem, function (direction) {
            if (direction === "left") {
                showSlideAction(listItem, '<i class="material-icons">call_split</i>', function () {
                    unpackSubQuestion(groupIndex, subIndex);
                });
            }
        });
    }
    // Simple swipe listener: if a left swipe is detected, call the callback with "left"
    function addSwipeListener(element, callback) {
        let touchstartX = 0;
        let touchstartY = 0;
        element.addEventListener(
            'touchstart',
            function (event) {
            touchstartX = event.changedTouches[0].screenX;
            touchstartY = event.changedTouches[0].screenY;
        }, {
            passive: true
        });
        element.addEventListener(
            'touchend',
            function (event) {
            const touchendX = event.changedTouches[0].screenX;
            const touchendY = event.changedTouches[0].screenY;
            const deltaX = touchstartX - touchendX;
            const deltaY = touchstartY - touchendY;
            // Trigger only if horizontal movement is significant and dominant
            if (Math.abs(deltaX) > 50 && Math.abs(deltaX) > Math.abs(deltaY)) {
                callback("left");
            }
        }, {
            passive: true
        });
    }

    // Display a slide-out overlay action on mobile
    function showSlideAction(element, label, action) {
        if (element.querySelector('.slide-action-overlay'))
            return;
        const overlay = document.createElement('div');
        overlay.className = 'slide-action-overlay';
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.width = '150px';
        overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
        overlay.style.color = 'white';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        overlay.style.cursor = 'pointer';
        overlay.innerHTML = label;
        element.style.position = 'relative';
        element.appendChild(overlay);
        overlay.addEventListener('click', function (e) {
            e.stopPropagation();
            action();
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        });
        setTimeout(function () {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }, 3000);
    }

    // Display a custom context menu at the specified coordinates with given items
    function showContextMenu(x, y, items) {
        let existingMenu = document.getElementById('custom-context-menu');
        if (existingMenu) {
            existingMenu.parentNode.removeChild(existingMenu);
        }
        const menu = document.createElement('div');
        menu.id = 'custom-context-menu';
        menu.style.position = 'absolute';
        menu.style.top = y + 'px';
        menu.style.left = x + 'px';
        menu.style.backgroundColor = 'white';
        menu.style.border = '1px solid #ccc';
        menu.style.boxShadow = '0 2px 5px rgba(0,0,0,0.3)';
        menu.style.zIndex = 10000;
        items.forEach(function (item) {
            const menuItem = document.createElement('div');
            menuItem.textContent = item.label;
            menuItem.style.padding = '8px 12px';
            menuItem.style.cursor = 'pointer';
            menuItem.addEventListener('click', function (e) {
                e.stopPropagation();
                item.action();
                if (menu.parentNode) {
                    menu.parentNode.removeChild(menu);
                }
            });
            menu.appendChild(menuItem);
        });
        document.body.appendChild(menu);
        document.addEventListener('click', function handler() {
            if (menu.parentNode) {
                menu.parentNode.removeChild(menu);
            }
            document.removeEventListener('click', handler);
        });
    }

    /***********************************************
     * CRUD: ADD QUESTION / ADD GROUP
     ***********************************************/
    function addQuestion() {
        const newQuestion = {
            type: "question",
            id: getUniqueId(),
            questionText: "",
            questionType: "text",
            options: [],
            required: false,
            compack: false,
        };
        surveyItems.push(newQuestion);
        renderAllItems();
        // Scroll to the last
        setTimeout(() => {
            const lastIndex = surveyItems.length - 1;
            const lastCard = document.getElementById(`question-card-${lastIndex}`);
            if (lastCard) {
                lastCard.scrollIntoView({
                    behavior: "smooth"
                });
            }
        }, 0);
    }
	function createEmptyQuestion() {
		return {
			type: "question",
			id: getUniqueId(),
			questionText: "",
			questionType: "text",
			options: [],
			required: false,
			compack: false,
		};
	}
    function addGroup() {
        const newGroup = {
            type: "group",
            id: getUniqueId(),
            groupTitle: "",
            anchorQuestionId: null,
            anchorValuesToShow: [],
            subQuestions: [createEmptyQuestion()],
        };
        surveyItems.push(newGroup);
        renderAllItems();
        // Scroll to the last
        setTimeout(() => {
            const lastIndex = surveyItems.length - 1;
            const lastCard = document.getElementById(`group-card-${lastIndex}`);
            if (lastCard) {
                lastCard.scrollIntoView({
                    behavior: "smooth"
                });
            }
        }, 0);
    }

    /***********************************************
     * CRUD: DELETE QUESTION / GROUP / SUBQUESTION
     ***********************************************/
    function deleteQuestion(index) {
        const deletedQ = surveyItems[index];
        pushUndo({
            type: "delete-question",
            index: index,
            deletedItem: deletedQ,
        });
        surveyItems.splice(index, 1);
        renderAllItems();
        M.toast({
            html: i18n_local[currentLang].deleteMsg,
            displayLength: 3000
        });
    }

    function deleteGroup(index) {
        const deletedG = surveyItems[index];
        pushUndo({
            type: "delete-group",
            index: index,
            deletedItem: deletedG,
        });
        surveyItems.splice(index, 1);
        renderAllItems();
        M.toast({
            html: i18n_local[currentLang].deleteGroupMsg,
            displayLength: 3000
        });
    }

    function deleteSubQuestion(groupIndex, subIndex) {
        const groupItem = surveyItems[groupIndex];
        const deletedQ = groupItem.subQuestions[subIndex];
        pushUndo({
            type: "delete-sub-question",
            groupIndex,
            subIndex,
            deletedItem: deletedQ,
        });
        groupItem.subQuestions.splice(subIndex, 1);
        renderAllItems();
    }

    /***********************************************
     * MOVE UP/DOWN: MAIN LEVEL
     ***********************************************/
    function moveItemUp(index) {
        if (index > 0) {
            const temp = surveyItems[index];
            surveyItems[index] = surveyItems[index - 1];
            surveyItems[index - 1] = temp;
            renderAllItems();
        }
    }

    function moveItemDown(index) {
        if (index < surveyItems.length - 1) {
            const temp = surveyItems[index];
            surveyItems[index] = surveyItems[index + 1];
            surveyItems[index + 1] = temp;
            renderAllItems();
        }
    }

    /***********************************************
     * MOVE UP/DOWN: SUB QUESTIONS
     ***********************************************/
    function moveSubQuestionUp(groupIndex, subIndex) {
        const groupItem = surveyItems[groupIndex];
        if (subIndex > 0) {
            const temp = groupItem.subQuestions[subIndex];
            groupItem.subQuestions[subIndex] = groupItem.subQuestions[subIndex - 1];
            groupItem.subQuestions[subIndex - 1] = temp;
            renderAllItems();
        }
    }

    function moveSubQuestionDown(groupIndex, subIndex) {
        const groupItem = surveyItems[groupIndex];
        if (subIndex < groupItem.subQuestions.length - 1) {
            const temp = groupItem.subQuestions[subIndex];
            groupItem.subQuestions[subIndex] = groupItem.subQuestions[subIndex + 1];
            groupItem.subQuestions[subIndex + 1] = temp;
            renderAllItems();
        }
    }

    /***********************************************
     * UNDO/REDO
     ***********************************************/
    function pushUndo(action) {
        undoStack.push(action);
        redoStack = [];
    }

    function undoAction() {
        if (undoStack.length === 0)
            return;
        const action = undoStack.pop();
        let redoActionObj = null;
        switch (action.type) {
        case "delete-question": {
                surveyItems.splice(action.index, 0, action.deletedItem);
                redoActionObj = {
                    type: "delete-question",
                    index: action.index,
                    deletedItem: action.deletedItem,
                };
                break;
            }
        case "delete-group": {
                surveyItems.splice(action.index, 0, action.deletedItem);
                redoActionObj = {
                    type: "delete-group",
                    index: action.index,
                    deletedItem: action.deletedItem,
                };
                break;
            }
        case "delete-sub-question": {
                const {
                    groupIndex,
                    subIndex,
                    deletedItem
                } = action;
                const groupItem = surveyItems[groupIndex];
                groupItem.subQuestions.splice(subIndex, 0, deletedItem);
                redoActionObj = {
                    type: "delete-sub-question",
                    groupIndex,
                    subIndex,
                    deletedItem,
                };
                break;
            }
        case "delete-option": {
                const {
                    parentIndex,
                    parentType,
                    optionIndex,
                    deletedOption
                } = action;
                if (parentType === "main") {
                    surveyItems[parentIndex].options.splice(optionIndex, 0, deletedOption);
                } else if (parentType === "group-sub") {
                    // not storing sub-question index here, so no direct approach
                    // In real usage you'd store the subIndex too for precise restore
                    // For brevity, skipping more complicated logic
                }
                redoActionObj = {
                    type: "delete-option",
                    parentIndex,
                    parentType,
                    optionIndex,
                    deletedOption
                };
                break;
            }
        default:
            break;
        }
        if (redoActionObj) {
            redoStack.push(redoActionObj);
        }
        renderAllItems();
    }

    function redoAction() {
        if (redoStack.length === 0)
            return;
        const action = redoStack.pop();
        let undoActionObj = null;
        switch (action.type) {
        case "delete-question": {
                const deletedQ = surveyItems.splice(action.index, 1)[0];
                undoActionObj = {
                    type: "delete-question",
                    index: action.index,
                    deletedItem: deletedQ,
                };
                break;
            }
        case "delete-group": {
                const deletedG = surveyItems.splice(action.index, 1)[0];
                undoActionObj = {
                    type: "delete-group",
                    index: action.index,
                    deletedItem: deletedG,
                };
                break;
            }
        case "delete-sub-question": {
                const {
                    groupIndex,
                    subIndex
                } = action;
                const groupItem = surveyItems[groupIndex];
                const deletedQ = groupItem.subQuestions.splice(subIndex, 1)[0];
                undoActionObj = {
                    type: "delete-sub-question",
                    groupIndex,
                    subIndex,
                    deletedItem: deletedQ,
                };
                break;
            }
        case "delete-option": {
                const {
                    parentIndex,
                    parentType,
                    optionIndex
                } = action;
                let deletedOpt = null;
                if (parentType === "main") {
                    deletedOpt = surveyItems[parentIndex].options.splice(optionIndex, 1)[0];
                } else if (parentType === "group-sub") {
                    // same note as above
                }
                undoActionObj = {
                    type: "delete-option",
                    parentIndex,
                    parentType,
                    optionIndex,
                    deletedOption: deletedOpt,
                };
                break;
            }
        default:
            break;
        }
        if (undoActionObj) {
            undoStack.push(undoActionObj);
        }
        renderAllItems();
    }

    function setupUndoRedoButtons() {
        const undoBtn = document.getElementById("undo-btn");
        const redoBtn = document.getElementById("redo-btn");
        undoBtn.onclick = () => undoAction();
        redoBtn.onclick = () => redoAction();
    }

    /***********************************************
     * GENERATE & GO
     ***********************************************/
	// if dryRun true, means the function will not write to the DB, and it will only generate the surveyOutput for preview 
    async function generateSurvey(dryRun) {
        // Get the survey title input value
        const surveyTitleInput = document.getElementById("survey-title-input");
        const surveyTitle = surveyTitleInput ? surveyTitleInput.value.trim() : "";

        // Validate: user must enter a title
        if (!surveyTitle) {
            M.toast({
                html: i18n_local[currentLang].enterSurveyTitle,
                displayLength: 2000
            });
            surveyTitleInput.focus();
            return; // stop the function if title is missing
        }

        // Get the endpoint URL from the settings modal input
        const endpointUrl = document.getElementById("endpoint-url").value;

        // Get the banner image URL from the new input
        const bannerImageUrl = document.getElementById("survey-banner-input").value.trim();

        const channelSelect = document.getElementById("channel-select");
        const selectedChannelId = channelSelect.value;

        const channelId = selectedChannelId.trim();

        // Create an output object that includes the survey title and banner image URL
        const surveyOutput = {
            endpointUrl: endpointUrl,
            surveyItems: surveyItems,
            surveyTitle: surveyTitle, // <-- Added field
            bannerImage: bannerImageUrl, // NEW: Banner image URL
            storeTitle: null, //@fixme, need to update
            storeId: null, //@fimxme, need to update
            _channelId: channelId,
            _userId: currentUserId
        };

        // Save the complete structure to localStorage
        localStorage.setItem("surveyQuestions", JSON.stringify(surveyOutput));
		
		if (dryRun) return surveyOutput;
		
        let result = await updateSurvey(CurrentSurveySchemaId, surveyOutput);
		
		
		window.originalGeneratedSurvey = JSON.parse(JSON.stringify(surveyOutput));
		
		
		CurrentSurveyTitle = surveyTitle;
		
        if (!CurrentSurveySchemaId) {
            CurrentSurveySchemaId = result?._id;
            localStorage.CurrentSurveySchemaId = CurrentSurveySchemaId;
        }

        // Create the URL string
        const finalURL = window.location.origin +
            window.location.pathname.replace("admin.html", "survey.html") +
            "?id=" + CurrentSurveySchemaId;

        // Set the URL text inside the modal
        document.getElementById("surveyLinkText").textContent = finalURL;

        // Set up the copy button to copy the URL to clipboard
        document.getElementById("copyBtn").onclick = function () {
            navigator.clipboard.writeText(finalURL).then(() => {
                M.toast({
                    html: i18n_local[currentLang].copiedToClipboard,
                    displayLength: 2000
                });
            });
        };

        // Set up the Go button to navigate to the URL
        document.getElementById("goBtn").onclick = function () {
            window.location.href = finalURL;
        };

        // Open the modal (initialize if necessary)
        const modalElem = document.getElementById("surveyLinkModal");
        let modalInstance = M.Modal.getInstance(modalElem);
        if (!modalInstance) {
            modalInstance = M.Modal.init(modalElem);
        }
        modalInstance.open();
    }
	
	
	
	async function previewSurvey() {

	  const surveyOutput = await generateSurvey(true);

	  // Open the modal (which contains the iframe)

	  const modalElem = document.getElementById('preview-modal');
	  let modalInstance = M.Modal.getInstance(modalElem);
	  if (!modalInstance) {
	      modalInstance = M.Modal.init(modalElem);
	  }
	  modalInstance.open();

	  // Once the iframe has loaded, postMessage our survey data
	  const iframe = document.getElementById('preview-frame');
	  
	  
	  	iframe.contentWindow.postMessage({
		  type: 'previewSurvey',
		  survey: surveyOutput
		}, '*');

	  
	}
    /***********************************************
     * fetch and update survey context
     ***********************************************/
    async function fetchSurvey(surveySchemaId, callback) {
        try {
            let url = "";
            if (surveySchemaId) {
                // Get a specific survey schema by its id.
                url = `${BASE_URL}/api/survey/${surveySchemaId}`;
            } else {
                // If no id is provided, fetch all surveys for the current user.
                url = `${BASE_URL}/api/survey?userId=${currentUserId}`;
            }
            const response = await fetch(url, {
                headers: {
                    Authorization: "Bearer " + currentUserToken,
                    "X-User-Id": currentUserId
                },
            });
            const data = await response.json();
            if (typeof callback === "function") {
                callback(null, data);
            }
            return data;
        } catch (error) {
            if (typeof callback === "function") {
                callback(error);
            }
            throw error;
        }
    }

    async function updateSurvey(surveySchemaId, content, callback) {
        try {
            let response;
            if (surveySchemaId) {
                // Update an existing survey schema.
                response = await fetch(`${BASE_URL}/api/survey/${surveySchemaId}`, {
                    method: "PUT",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + currentUserToken,
                        "X-User-Id": currentUserId
                    },
                    body: JSON.stringify(content),
                });
            } else {
                // Create a new survey schema.
                response = await fetch(`${BASE_URL}/api/survey`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + currentUserToken,
                        "X-User-Id": currentUserId
                    },
                    body: JSON.stringify(content),
                });
            }
            const data = await response.json();
            if (typeof callback === "function") {
                callback(null, data);
            }
            return data;
        } catch (error) {
            if (typeof callback === "function") {
                callback(error);
            }
            throw error;
        }
    }

    async function updateSurveyCounter(surveySchemaId, callback) {
        try {
            const response = await fetch(`${BASE_URL}/api/survey/${surveySchemaId}/counter`, {
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: "Bearer " + currentUserToken,
                    "X-User-Id": currentUserId
                },
            });
            const data = await response.json();
            if (typeof callback === "function") {
                callback(null, data);
            }
            return data;
        } catch (error) {
            if (typeof callback === "function") {
                callback(error);
            }
            throw error;
        }
    }

	function toggleDisabled(el, shouldDisable) {
	  if (typeof el == 'string') {
		el = document.getElementById(el);
	  }
	  if (shouldDisable) el.setAttribute("disabled", "true");
	  else           el.removeAttribute("disabled");
	}
    function showSelectSurveyModal(surveys, dismissible = false) {
        return new Promise((resolve) => {
            // Populate the list
            const surveyList = document.getElementById("surveyList");
            surveyList.innerHTML = ""; // clear any previous items
            const importSurveyBtn = document.getElementById("importSurveyBtn");
			
			
			toggleDisabled("exportSurveyBtn", true);
			toggleDisabled("importSurveyBtn", true);
			
            // Add existing surveys to the list
            surveys.forEach((survey) => {
                const li = document.createElement("li");
                li.className = "collection-item";
                li.style.cursor = "pointer";
				
				const title = survey.surveyTitle
				  ? `${survey.surveyTitle} (ID: ${survey._id})`
				  : `${i18n_local[currentLang].surveyIdLabel} ${survey._id}`;

				if (survey._id === CurrentSurveySchemaId) {
				  li.classList.add("teal", "white-text");
				  li.innerHTML = `${title} <i class="material-icons left">check</i>`;
				} else {
				  li.textContent = title;
				}
				
                li.dataset.surveyId = survey._id;

                // Pre-select if this survey is the current one.
                if (survey._id === localStorage.CurrentSurveySchemaId) {
                    li.classList.add("blue", "white-text");
                }
                // Highlight the clicked item
                li.onclick = function () {
					 document.querySelectorAll("#surveyList .collection-item").forEach((item) => {
						item.classList.remove("blue", "teal", "white-text");
					});

					const isCurrentSurvey = li.dataset.surveyId === CurrentSurveySchemaId;
					const isNewSurvey = li.dataset.surveyId === "create new";
					
					if (isCurrentSurvey) {
						li.classList.add("teal", "white-text");
					}
					else {
						li.classList.add("blue", "white-text");
					}
					
					
					// Enable/disable buttons
					toggleDisabled("importSurveyBtn", !(isCurrentSurvey || isNewSurvey)); 
					toggleDisabled("exportSurveyBtn", !isCurrentSurvey);
                };
                // ADD: Delete icon for survey deletion
                const deleteIcon = document.createElement("i");
                deleteIcon.className = "material-icons right";
                deleteIcon.style.cursor = "pointer";
                deleteIcon.textContent = "delete";
                deleteIcon.onclick = async(e) => {
                    e.stopPropagation();
                    if (confirm(i18n_local[currentLang].confirmDeleteSurvey)) {
                        try {
                            const response = await fetch(`${BASE_URL}/api/survey/${survey._id}`, {
                                headers: {
                                    Authorization: "Bearer " + currentUserToken,
                                    "X-User-Id": currentUserId
                                },
                                method: "DELETE"
                            });
                            const result = await response.json();
                            if (response.ok) {
                                M.toast({
                                    html: i18n_local[currentLang].surveyDeletedSuccessfully,
                                    displayLength: 2000
                                });
                                li.remove();
                            } else {
                                M.toast({
                                    html: result.error || i18n_local[currentLang].failedToDeleteSurvey,
                                    displayLength: 2000
                                });
                            }
                        } catch (error) {
                            M.toast({
                                html: "Error deleting survey",
                                displayLength: 2000
                            });
                        }
                    }
                };
                li.appendChild(deleteIcon);
                surveyList.appendChild(li);
            });

            // Add the "Create New" item at the bottom
            const createNewItem = document.createElement("li");
            createNewItem.className = "collection-item";
            createNewItem.style.cursor = "pointer";
            createNewItem.style.fontWeight = "bold";
            createNewItem.innerHTML = `${i18n_local[currentLang].newSurvey}`;	

			const createIcon = document.createElement("i");
			createIcon.className = "material-icons right";
			createIcon.style.cursor = "pointer";
			createIcon.textContent = "add";
			createIcon.onclick = async(e) => {
				// trigger click 
				const confirmBtn = document.getElementById("confirmSurveyBtn");
				if (confirmBtn) {
					confirmBtn.click(); // 觸發 click
				}
				
			};
			createNewItem.appendChild(createIcon);
			
            createNewItem.dataset.surveyId = "create new";
            createNewItem.onclick = function () {
                document.querySelectorAll("#surveyList .collection-item").forEach((item) => {
                    item.classList.remove("blue", "teal", "white-text");
                });
                createNewItem.classList.add("blue",  "white-text");
                if (createNewItem.dataset.surveyId === localStorage.CurrentSurveySchemaId) {
                    toggleDisabled(importSurveyBtn, false);
                } else {
                    toggleDisabled(importSurveyBtn, true);
                }
				toggleDisabled(exportSurveyBtn, true);
            };
            surveyList.appendChild(createNewItem);

            // Open the modal (ensuring it doesn't dismiss if nothing is selected)
            const modalElem = document.getElementById("selectSurveyModal");
            let modalInstance = M.Modal.getInstance(modalElem);
            if (modalInstance) {
                modalInstance.options.dismissible = dismissible;
            } else {
                modalInstance = M.Modal.init(modalElem, {
                    dismissible: dismissible
                });
            }
            const selectedItem = document.querySelector("#surveyList .collection-item.blue");
            if (selectedItem && selectedItem.dataset.surveyId === localStorage.CurrentSurveySchemaId) {
                toggleDisabled("importSurveyBtn", false);
                toggleDisabled("exportSurveyBtn", false);		
            } else {
				toggleDisabled("importSurveyBtn", true);
                toggleDisabled("exportSurveyBtn", true);				
            }
            modalInstance.open();

            // When user clicks "Confirm", get the selected survey ID
            const confirmBtn = document.getElementById("confirmSurveyBtn");
            confirmBtn.onclick = async function () {
			
			
			
				const currentGenerated = await generateSurvey(true);
				if (isSurveyDataChanged(currentGenerated)) {
					const ok = window.confirm("您有尚未儲存的變更，切換問卷將會捨棄目前修改，確定要切換嗎？");
					if (!ok) {
						return;
					}
				}
		
			
			
                const selectedItem = document.querySelector("#surveyList .collection-item.blue");
                if (selectedItem) {
                    const selectedId = selectedItem.dataset.surveyId;
                    modalInstance.close();
                    if (selectedId === "create new") {
                        // If "create new" is selected, pop up the import survey modal directly.
                        delete localStorage.CurrentSurveySchemaId;
                        CurrentSurveySchemaId = null;
                        openImportSurveyModal();
                    } else {
                        localStorage.CurrentSurveySchemaId = selectedId;
                    }
                    resolve(selectedId);
                } else {
                    M.toast({
                        html: i18n_local[currentLang].pleaseSelectSurvey,
                        displayLength: 2000
                    });
                }
            };
        });
    }

    let isSurveyModified;
    function handleSwitchSurvey() {
        if (isSurveyModified) {
            // Use Materialize's confirm modal or simply window.confirm.
            // Here we'll use window.confirm for simplicity.
            if (window.confirm(i18n_local[currentLang].unsavedChangesPrompt)) {
                // User wants to save changes, so call generateSurvey.
                generateSurvey().then(() => {
                    // Once saved, open the survey list modal to let user select another survey.
                    openSurveyListModal();
                });
            } else {
                // User does not want to save changes; simply open the survey list modal.
                openSurveyListModal();
            }
        } else {
            openSurveyListModal();
        }
    }

    async function openSurveyListModal() {
        // Assume 'surveys' is already available or fetch it here.
        const surveys = await fetchSurvey(); // or however you fetch the list

        // Open the survey list modal and get the selected survey ID
        let selectedId = await showSelectSurveyModal(surveys, true);

        if (selectedId) {
            // Switch survey after the user selects one.
            // You might want to store the selected survey ID and then reload the survey content.
            // For example:
            switchSurveyById(selectedId);
        }
    }

    async function switchSurveyById(surveyId) {
	
	
	
        if (surveyId === "create new") {
            // Handle creating a new survey
            surveyItems = [];
			initNextId();
			
			
            document.getElementById("survey-title-input").value = "";
            document.getElementById("survey-banner-input").value = "";
            CurrentSurveySchemaId = undefined;
            isSurveyModified = false;
            renderAllItems();
			window.originalGeneratedSurvey = null;
			
        } else {
            // Fetch the survey by its id
            let tmp = await fetchSurvey(surveyId);
            const existingData = tmp;
            if (existingData) {
                const parsed = typeof existingData === "string" ? JSON.parse(existingData) : existingData;
				
				let items = parsed.surveyItems;
			
				normalizeSurveyItems(items);  // make sure the format is correct
				
                surveyItems = items.map(item => item.type ? item : {
                    type: "question",
                    ...item
                });
				initNextId();
				
                // Set the survey title input if one exists
                if (parsed.surveyTitle) {
                    document.getElementById("survey-title-input").value = parsed.surveyTitle;
					CurrentSurveyTitle = parsed.surveyTitle || "";
                } else {
                    document.getElementById("survey-title-input").value = '';
                }
                // Set the banner image input if one exists
                if (parsed.bannerImage) {
                    document.getElementById("survey-banner-input").value = parsed.bannerImage;
                } else {
                    document.getElementById("survey-banner-input").value = '';
                }
                // Set the channel Id
                if (parsed._channelId) {
                    // Save the channel ID in a global variable (if needed later)
                    window.preSelectedChannel = parsed._channelId;
                    // Set the dropdown's value and refresh the Materialize UI
                    const channelSelect = document.getElementById("channel-select");
                    if (channelSelect) {
                        channelSelect.value = parsed._channelId;
                        M.FormSelect.init(channelSelect);
                    }
                }
                CurrentSurveySchemaId = surveyId;
                isSurveyModified = false;
                renderAllItems();
				
                const baseline = await generateSurvey(true);
                window.originalGeneratedSurvey = JSON.parse(JSON.stringify(baseline));
            }
        }
        updateNavTitle();
        window.scrollTo({
            top: 0,
            behavior: "auto"
        });
        document.querySelectorAll(".question-card, .group-card").forEach((el) => {
            el.classList.add("slide-in");
            setTimeout(() => el.classList.remove("slide-in"), 1000);
        });
    }

    async function logout() {
        let res = confirm(i18n_local[currentLang].logoutConfirm);
        if (res) {
            // clear the cookie authentication
            const response = await fetch(`${BASE_URL}/api/logout`, {
                method: 'POST',
                body: JSON.stringify({
                    userId: localStorage.userId
                }),
                credentials: "include"
            });
            const data = await response.json();
            console.log(data);
            delete localStorage.userId;
            delete localStorage.userToken;
            setTimeout(function () {
                location.reload();
            }, 1000)
        }
    }

    function updateNavTitle() {
        const navTitleEl = document.getElementById("nav-title");
        let titleText = "";
        if (!CurrentSurveySchemaId) {
            titleText = i18n_local[currentLang].importSurvey;
        } else if (CurrentSurveySchemaId === "create new") {
            titleText = i18n_local[currentLang].newSurvey;
        }
        else {
			// We think the title already show in the editor, so this title should show the id 
            //if (CurrentSurveyTitle && CurrentSurveyTitle.trim() !== "") {
            //    titleText = CurrentSurveyTitle;
            //} else {
                titleText = CurrentSurveySchemaId;
            //}
        }
        navTitleEl.innerHTML = `<span class=''><i class="material-icons left">library_add</i>${i18n_local[currentLang].surveyIdPrefix} (${titleText})</span>`;
    }

    /***********************************************
     * IMPORT SURVEY
     ***********************************************/

    // Global variable to hold imported survey JSON (from file)
    var importedSurveyDataFromFile = null;

    // Opens the Import Survey popup modal and resets its fields.
    async function openImportSurveyModal() {

        // NEW: Check if there's an existing survey loaded
        if (CurrentSurveySchemaId) {
            if (!confirm(i18n_local[currentLang].importReplaceConfirmation)) {
                // If user cancels, exit the import process.
                return;
            }
        }
		
		
        const modalElem = document.getElementById('importSurveyModal');
        let modalInstance = M.Modal.getInstance(modalElem);
        if (!modalInstance) {
            modalInstance = M.Modal.init(modalElem, {
                dismissible: true
            });
        }
        // Reset mode to "file" by default.
        const storedMode = localStorage.getItem("importMode") || "text";
        document.querySelector('input[name="importMode"][value="' + storedMode + '"]').checked = true;
        updateImportModePopup();
        // Clear any previous inputs.
        document.getElementById('popupImportSurveyFile').value = "";
        document.getElementById('popupImportSurveyUrl').value = "";
        document.getElementById('popupImportSurveyText').value = "";
        importedSurveyDataFromFile = null;
        modalInstance.open();
    }

    // Updates the popup UI based on the selected import mode.
    function updateImportModePopup() {
        const mode = document.querySelector('input[name="importMode"]:checked').value;
        document.getElementById("popupImportFileContainer").style.display = (mode === "file") ? "block" : "none";
        document.getElementById("popupImportUrlContainer").style.display = (mode === "url") ? "block" : "none";
        document.getElementById("popupImportTextContainer").style.display = (mode === "text") ? "block" : "none";
    }

    // Handles file import in the popup modal.
    // After the file is read and parsed correctly, the import process is triggered automatically.
    function handleImportSurveyFilePopup(event) {
        const file = event.target.files[0];
        if (!file)
            return;
        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                importedSurveyDataFromFile = JSON.parse(e.target.result);
                // M.toast({ html: "File loaded successfully", displayLength: 2000 });
                // Automatically trigger the import process.
                handleFinalImport();
            } catch (error) {
                M.toast({
                    html: i18n_local[currentLang].fileParseError,
                    displayLength: 2000
                });
            }
        };
        reader.readAsText(file);
    }

    // Called when the user clicks "Import" in the popup modal (or automatically for file mode).
    async function handleFinalImport() {
        const mode = document.querySelector('input[name="importMode"]:checked').value;
        let importedData;
        if (mode === "file") {
            if (!importedSurveyDataFromFile) {
                M.toast({
                    html: i18n_local[currentLang].invalidJsonFile,
                    displayLength: 3000
                });
                return;
            }
            importedData = importedSurveyDataFromFile;
        } else if (mode === "url") {
            const url = document.getElementById('popupImportSurveyUrl').value.trim();
            if (!url) {
                M.toast({
                    html: i18n_local[currentLang].enterUrl,
                    displayLength: 3000
                });
                return;
            }
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error("Network error");
                }
                importedData = await response.json();
            } catch (error) {
                M.toast({
                    html: i18n_local[currentLang].importSurveyUrlFail,
                    displayLength: 3000
                });
                return;
            }
        } else if (mode === "text") {
            const text = document.getElementById('popupImportSurveyText').value.trim();
            if (!text) {
                M.toast({
                    html: i18n_local[currentLang].pasteJsonText,
                    displayLength: 3000
                });
                return;
            }
            try {
                importedData = JSON.parse(text);
            } catch (error) {
                M.toast({
                    html: i18n_local[currentLang].parseJsonTextError,
                    displayLength: 3000
                });
                return;
            }
        }

        // Validate and process the imported data.
        try {
            if (!importedData.surveyItems) {
                throw new Error(i18n_local[currentLang].invalidSurveySchema || "Invalid survey schema: missing surveyItems");
            }

            // Update survey items and UI
            let items = importedData.surveyItems;
			
			normalizeSurveyItems(items);  // make sure the format is correct
			
			surveyItems = items.map(item => {
			    if (item.type === 'group') {
			        item.subQuestions = item.subQuestions || []
			    }
			    return item
			})
			initNextId();
			
            document.getElementById("survey-title-input").value = importedData.surveyTitle || "";
            // Update banner image if available
            document.getElementById("survey-banner-input").value = importedData.bannerImage || "";

            // Add effect for smoother UI

            renderAllItems(); // Render imported survey
			


            window.scrollTo({
                top: 0,
                behavior: "auto"
            });
            // Add highlight effect to new items
            document.querySelectorAll(".question-card, .group-card").forEach((el) => {
                el.classList.add("slide-in");
                setTimeout(() => {
                    el.classList.remove("slide-in")
                }, 1000); // Remove highlight after effect
            });

            // Show success message
            M.toast({
                html: i18n_local[currentLang].importSurveySuccess,
                displayLength: 3000
            });

            // Close import modal
            const importModalElem = document.getElementById('importSurveyModal');
            const importModalInstance = M.Modal.getInstance(importModalElem);
            if (importModalInstance)
                importModalInstance.close();

            // Close select survey modal (if open)
            const selectModalElem = document.getElementById('selectSurveyModal');
            const selectModalInstance = M.Modal.getInstance(selectModalElem);
            if (selectModalInstance)
                selectModalInstance.close();
        } catch (error) {
            M.toast({
                html: i18n_local[currentLang].importSurveyFailed,
                displayLength: 2000
            });
        }
    }

    // fetch survey data using the REST API.
    async function fetchSurveyData() {

        if (!CurrentSurveySchemaId) {
            M.toast({
                html: "surveyId is required to fetch survey data",
                displayLength: 3000
            });
            return;
        }

        // Build the API URL. In this example, we map channelId to _typeId and use _type=survey.
        const url = `${BASE_URL}/api/read-data?_typeId=${encodeURIComponent(CurrentSurveySchemaId)}&_type=survey`;
        try {
            const response = await fetch(url, {
                headers: {
                    "Content-Type": "application/json",
                    Authorization: "Bearer " + currentUserToken,
                    "X-User-Id": currentUserId
                },
            });
            const result = await response.json();
            if (result.error) {
                M.toast({
                    html: result.error,
                    displayLength: 3000
                });
                return;
            }
            // Call the summary function with the fetched data.
            summarizeSurveyData(result.data);
        } catch (err) {
            console.error("Error fetching survey data:", err);
            M.toast({
                html: "Error fetching survey data",
                displayLength: 3000
            });
        }
    }

    async function summarizeSurveyData(responses) {
        // First, fetch the survey schema
        let surveySchema = await fetchSurvey(CurrentSurveySchemaId);
        // Flatten the survey items into an ordered array of questions.
        let orderedQuestions = [];
        surveySchema.surveyItems.forEach(item => {
            if (item.type === "question") {
                orderedQuestions.push(item);
            } else if (item.type === "group" && Array.isArray(item.subQuestions)) {
                // For groups, add sub-questions in the order they appear.
                item.subQuestions.forEach(subq => {
                    orderedQuestions.push(subq);
                });
            }
        });

        // Aggregate responses by questionId.
        const summaryMap = {};
        responses.forEach(response => {
            response.forEach(item => {
                const qid = item.questionId;
                if (!summaryMap[qid]) {
                    summaryMap[qid] = {
                        question: item.question, // update to last row to reflect current text
                        type: item.questionType,
                        answers: []
                    };
                }
                // Update question and type (in case they change in later responses)
                summaryMap[qid].question = item.question;
                summaryMap[qid].type = item.questionType;
                summaryMap[qid].answers.push(item.answer);
            });
        });
        const content = document.getElementById("surveyDataContent");
        content.innerHTML = "";

        // Define color arrays for the charts.
        const backgroundColors = [
            'rgba(255, 99, 132, 0.6)',
            'rgba(54, 162, 235, 0.6)',
            'rgba(255, 206, 86, 0.6)',
            'rgba(75, 192, 192, 0.6)',
            'rgba(153, 102, 255, 0.6)',
            'rgba(255, 159, 64, 0.6)'
        ];
        const borderColors = [
            'rgba(255, 99, 132, 1)',
            'rgba(54, 162, 235, 1)',
            'rgba(255, 206, 86, 1)',
            'rgba(75, 192, 192, 1)',
            'rgba(153, 102, 255, 1)',
            'rgba(255, 159, 64, 1)'
        ];

        // Iterate over questions following the schema order.
        orderedQuestions.forEach(questionSchema => {
            // Convert question ID to string for consistency.
            const qid = questionSchema.id.toString();
            // Use responses if available; otherwise, create an empty summary.
            let summary = summaryMap[qid] || {
                question: questionSchema.questionText,
                type: questionSchema.questionType,
                answers: []
            };

            // Build summary based on the question type.
            if (questionSchema.questionType === "radio" || questionSchema.questionType === "checkbox") {
                // For radio/checkbox: use schema options to determine order and include missing options.
                const options = (questionSchema?.options.map(option => option.text)) || [];
                let freq = {};
                options.forEach(opt => {
                    freq[opt] = 0;
                });
                summary.answers.forEach(ans => {
                    if (Array.isArray(ans)) {
                        ans.forEach(a => {
                            if (freq[a] !== undefined) {
                                freq[a]++;
                            } else {
                                freq[a] = 1;
                            }
                        });
                    } else {
                        if (freq[ans] !== undefined) {
                            freq[ans]++;
                        } else {
                            freq[ans] = 1;
                        }
                    }
                });
                const labels = options;
                const dataCounts = labels.map(label => freq[label] || 0);
                createSummaryBlock(questionSchema, summary, labels, dataCounts);
            } else if (questionSchema.questionType === "stars") {
                // For stars: create a scale from 1 to maxStars.
                let maxStars = questionSchema.maxStars || 5;
                let labels = [];
                let freq = {};
                for (let i = 1; i <= maxStars; i++) {
                    labels.push(i.toString());
                    freq[i] = 0;
                }
                summary.answers.forEach(ans => {
                    let num = Number(ans);
                    if (num >= 1 && num <= maxStars) {
                        freq[num]++;
                    }
                });
                const dataCounts = labels.map(label => freq[label] || 0);
                createSummaryBlock(questionSchema, summary, labels, dataCounts, true);
            } else if (questionSchema.questionType === "date") {
                // For date questions, aggregate unique dates from responses.
                let freq = {};
                summary.answers.forEach(ans => {
                    freq[ans] = (freq[ans] || 0) + 1;
                });
                // Order dates by natural order.
                let labels = Object.keys(freq).sort();
                const dataCounts = labels.map(label => freq[label]);
                createSummaryBlock(questionSchema, summary, labels, dataCounts);
            } else if (questionSchema.questionType === "text" || questionSchema.questionType === "longtext") {
                // For text answers, simply display a note.
                createSummaryBlock(questionSchema, summary, null, null);
            }
        });

        // Open the full-page overlay.
        openSurveyDataPage();

        // Helper function: creates the summary block (chart and/or list) for a question.
        function createSummaryBlock(questionSchema, summary, labels, dataCounts, isStars = false) {
            const container = document.createElement("div");
            container.className = "question-summary";
            container.style.padding = "1rem";
            container.style.border = "1px solid #ddd";
            container.style.borderRadius = "8px";
            container.style.boxShadow = "0 2px 5px rgba(0,0,0,0.1)";
            container.style.background = "#fff";

            // Header: question text and type.
            const header = document.createElement("h5");
            header.textContent = `${questionSchema.questionText} (${questionSchema.questionType})`;
            header.style.fontSize = "1rem";
            header.style.marginBottom = "0.5rem";
            header.style.color = "#333";
            container.appendChild(header);

            // For text/longtext, display note and do not create a chart.
            if (questionSchema.questionType === "text" || questionSchema.questionType === "longtext") {
                const note = document.createElement("p");
                note.textContent = i18n_local[currentLang].textAnswerSummaryNote;
                note.style.fontStyle = "italic";
                note.style.color = "#666";
                container.appendChild(note);
                content.appendChild(container);
                return;
            }

            // Create a canvas element for the chart.
            const canvas = document.createElement("canvas");
            canvas.id = "chart_" + questionSchema.id;
            canvas.style.width = "100%";
            canvas.style.height = "200px";
            canvas.style.marginBottom = "0.5rem";
            container.appendChild(canvas);

            // Delay chart creation to ensure canvas is in the DOM.
            setTimeout(() => {
                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                                label: questionSchema.questionText,
                                data: dataCounts,
                                backgroundColor: backgroundColors.slice(0, labels.length),
                                borderColor: borderColors.slice(0, labels.length),
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: false,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    precision: 0
                                },
                                title: {
                                    display: true,
                                    text: "回應數量",
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: "選項",
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            }
                        }
                    }
                });
            }, 100);

            // For stars questions, also calculate and display the average rating.
            if (questionSchema.questionType === "stars") {
                const total = summary.answers.reduce((sum, ans) => sum + Number(ans), 0);
                const avg = summary.answers.length ? total / summary.answers.length : 0;
                const avgP = document.createElement("p");
                avgP.style.fontWeight = "bold";
                avgP.style.color = "#00796b";
                avgP.textContent = `平均評分: ${avg.toFixed(2)} （共 ${summary.answers.length} 筆回應）`;
                container.appendChild(avgP);
            } else if (questionSchema.questionType === "radio" ||
                questionSchema.questionType === "checkbox" ||
                questionSchema.questionType === "date") {
                // Display frequency list below the chart.
                const list = document.createElement("ul");
                list.style.listStyleType = "none";
                list.style.paddingLeft = "0";
                labels.forEach(label => {
                    const li = document.createElement("li");
                    li.textContent = `${label}: ${dataCounts[labels.indexOf(label)]} 筆`;
                    li.style.padding = "0.25rem 0";
                    list.appendChild(li);
                });
                container.appendChild(list);
            }
            content.appendChild(container);
        }
    }
	
	
	
	function exportSurvey() {
	    if (!CurrentSurveySchemaId) {
	        M.toast({
	            html: "Please select current survey first",
	            displayLength: 2000
	        });
	        return;
	    }
	    const surveyData = {
	        surveyTitle: document.getElementById("survey-title-input").value,
	        bannerImage: document.getElementById("survey-banner-input").value,
	        channelId: document.getElementById("channel-select").value,
	        surveyItems: surveyItems,
	        _channelId: document.getElementById("channel-select").value,
	        timestamp: new Date().toISOString()
	    };

	    // Create filename
	    const filename = i18n_local[currentLang].exportFileName
	        .replace('{date}', new Date().toISOString().split('T')[0]) +
	        (surveyData.surveyTitle ? ` - ${surveyData.surveyTitle}` : '') + '.json';

		try {
			// Create blob and download
			const blob = new Blob([JSON.stringify(surveyData, null, 2)], {
				type: 'application/json'
			});
			const url = URL.createObjectURL(blob);

			const a = document.createElement('a');
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			
			// Show success toast with filename
			M.toast({
				html: `${i18n_local[currentLang].exportSurveyMessage}: <strong>${filename}</strong>`,
				displayLength: 4000,
				classes: 'green'
			});		

			setTimeout(() => {
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
			}, 0);
		}
		catch (error) {
			M.toast({
				html: `Export failed: ${error.message}`,
				displayLength: 4000,
				classes: 'red'
			});
		}
	}

    // Functions to open and close the full-page overlay.
    function openSurveyDataPage() {
        const page = document.getElementById("surveyDataPage");
        page.classList.add("active");
    }

    function closeSurveyDataPage() {
        const page = document.getElementById("surveyDataPage");
        page.classList.remove("active");
    }

    // Function to fetch the user's channels and populate the dropdown.
    async function fetchChannelList() {
        try {
            // Send a POST request to list channels for the current user.
            const response = await fetch(`${BASE_URL}/api/list-admin`, {
                method: 'POST',
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + currentUserToken,
                    "X-User-Id": currentUserId
                },
                body: JSON.stringify({
                    userId: currentUserId
                })
            });
            const data = await response.json();
            // If there is an error in the response, handle it.
            if (data.error) {
                M.toast({
                    html: data.error,
                    displayLength: 2000
                });
                return;
            }
            const selectElem = document.getElementById("channel-select");
            // Clear any previous options (except the default one).
            selectElem.innerHTML = `<option value="">-- 選擇頻道 --</option>`;

            // Populate the dropdown with channels. Assume each channel object has channelId and channelDescription.
            data.channels.forEach(channel => {
                const option = document.createElement("option");
                option.value = channel.channelId;
                option.textContent = channel.channelDescription || channel.channelId;
                selectElem.appendChild(option);
            });
            // Reinitialize the Materialize select to update the dropdown UI
            M.FormSelect.init(document.querySelectorAll('#channel-select'));
        } catch (error) {
            console.error("Error fetching channels:", error);
            M.toast({
                html: "無法取得頻道清單",
                displayLength: 2000
            });
        }
    }

    /*******************************************
     * Survey Event trigger funtions
     */
    let currentTriggers = [];

    async function showEventTriggers() {
        // Open the modal
        const modal = M.Modal.getInstance(document.getElementById('eventTriggersModal'));
        modal.open();

        // Load triggers if we have a survey selected
        if (CurrentSurveySchemaId) {
            try {
                const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}/triggers`);
                currentTriggers = await response.json();
                renderTriggersList();
            } catch (error) {
                console.error('Error loading triggers:', error);
                M.toast({
                    html: 'Failed to load triggers',
                    classes: 'red'
                });
            }
        }
    }

    function renderTriggersList() {
        const container = document.getElementById('triggersList');
        container.innerHTML = "";
        currentTriggers.forEach(trigger => {
            const cardPanel = document.createElement("div");
			cardPanel.id = `trigger-${trigger._id}`;
            cardPanel.className = "card-panel";

            // Create a header container that always shows Title and Type
            const headerContainer = document.createElement("div");
            headerContainer.className = "trigger-header";
            const header = document.createElement("h6");
            header.textContent = trigger.name;
            headerContainer.appendChild(header);

            const typePara = document.createElement("p");
            typePara.textContent = "類型: " + trigger.conditionType;
            headerContainer.appendChild(typePara);

            cardPanel.appendChild(headerContainer);

            // Create a container for the script content
            const scriptContainer = document.createElement("div");
            scriptContainer.className = "trigger-script";
            const scriptPre = document.createElement("pre");
            scriptPre.textContent = trigger.script;
            scriptPre.style.maxHeight = "200px";
            scriptPre.style.overflowY = "auto";
            scriptPre.style.whiteSpace = "pre-wrap";
            scriptPre.style.wordBreak = "break-word";
            scriptPre.style.cursor = "pointer";
            // Allow user to toggle expansion if needed
            scriptPre.addEventListener("click", function () {
                scriptPre.style.maxHeight = scriptPre.style.maxHeight === "none" ? "200px" : "none";
            });
            scriptContainer.appendChild(scriptPre);
            cardPanel.appendChild(scriptContainer);

            // Button container for Delete and Edit buttons
            const buttonContainer = document.createElement("div");
            buttonContainer.style.display = "flex";
            buttonContainer.style.gap = "10px";
            buttonContainer.style.marginTop = "10px";

            // Delete button
            const deleteButton = document.createElement("button");
            deleteButton.className = "btn red";
            deleteButton.textContent = i18n_local[currentLang].deleteTriggerButton;
            deleteButton.onclick = () => deleteTrigger(trigger._id);
            buttonContainer.appendChild(deleteButton);

            // Edit button
            const editButton = document.createElement("button");
            editButton.className = "btn blue";
            editButton.textContent = i18n_local[currentLang].editTriggerButton;
            buttonContainer.appendChild(editButton);

            // When user clicks Edit, only replace the script container with an Ace editor.
            editButton.onclick = () => {
                // Create a new div to host the Ace editor
                const editorDiv = document.createElement("div");
                editorDiv.style.width = "100%";
                editorDiv.style.height = "400px";
                // Replace script container's content with the editor div
                scriptContainer.innerHTML = "";
                scriptContainer.appendChild(editorDiv);

                // Initialize Ace on the new div
                const editor = ace.edit(editorDiv);
                editor.setTheme("ace/theme/monokai");
                editor.session.setMode("ace/mode/javascript");
                editor.session.setOption("useWorker", true);
                editor.setOptions({
                    fontSize: "12pt",
                    showPrintMargin: false
                });
                editor.setValue(trigger.script, -1);

                // Remove the Edit button from the button container
                buttonContainer.removeChild(editButton);

                // Create Save and Cancel buttons
                const saveButton = document.createElement("button");
                saveButton.className = "btn green";
                saveButton.textContent = i18n_local[currentLang].saveTriggerButton;
                const cancelButton = document.createElement("button");
                cancelButton.className = "btn grey";
                cancelButton.textContent = i18n_local[currentLang].cancel;
                buttonContainer.appendChild(saveButton);
                buttonContainer.appendChild(cancelButton);

                // Save button: update the trigger's script and revert back to static view
                saveButton.onclick = async() => {
                    const updatedScript = editor.getValue();
                    // Create an updated trigger object that includes the full data
                    const updatedTrigger = {
						_id: trigger._id,  
                        name: trigger.name,
                        conditionType: trigger.conditionType, // "starThreshold", "answerMatch", or "timeBased"
                        parameters: trigger.parameters, // retain existing parameters
                        script: updatedScript
                    };
                    try {
                        const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}/triggers/${trigger._id}`, {
                            method: 'PUT',
                            headers: {
                                "Content-Type": "application/json",
                                Authorization: "Bearer " + currentUserToken,
                                "X-User-Id": currentUserId
                            },
                            body: JSON.stringify(updatedTrigger)
                        });
                        const result = await response.json();
                        if (response.ok) {
                            // Update local trigger data and revert scriptContainer to a <pre> view
                            trigger.script = updatedScript;
                            const newPre = document.createElement("pre");
                            newPre.textContent = updatedScript;
                            newPre.style.maxHeight = "200px";
                            newPre.style.overflowY = "auto";
                            newPre.style.whiteSpace = "pre-wrap";
                            newPre.style.wordBreak = "break-word";
                            newPre.style.cursor = "pointer";
                            newPre.addEventListener("click", function () {
                                newPre.style.maxHeight = newPre.style.maxHeight === "none" ? "200px" : "none";
                            });
                            scriptContainer.innerHTML = "";
                            scriptContainer.appendChild(newPre);

                            // Remove Save and Cancel buttons, add back the Edit button
                            buttonContainer.removeChild(saveButton);
                            buttonContainer.removeChild(cancelButton);
                            buttonContainer.appendChild(editButton);
                        } else {
                            M.toast({
                                html: result.error || "儲存腳本失敗",
                                displayLength: 2000
                            });
                        }
                    } catch (err) {
                        console.error(err);
                        M.toast({
                            html: "儲存腳本時發生錯誤",
                            displayLength: 2000
                        });
                    }
                };

                // Cancel button: discard changes and revert to the original script view
                cancelButton.onclick = () => {
                    // Restore the original <pre> element
                    scriptContainer.innerHTML = "";
                    scriptContainer.appendChild(scriptPre);
                    // Remove Save and Cancel buttons, add back the Edit button
                    buttonContainer.removeChild(saveButton);
                    buttonContainer.removeChild(cancelButton);
                    buttonContainer.appendChild(editButton);
                };
            };
            cardPanel.appendChild(buttonContainer);
            container.appendChild(cardPanel);
        });
    }

	function scrollToTrigger(triggerId) {
	  const el = document.getElementById(`trigger-${triggerId}`);
	  if (!el) return;
	  // Smooth scroll into center of viewport
	  el.scrollIntoView({ behavior: 'smooth', block: 'center' });
	  // Add a temporary highlight class
	  el.classList.add('highlight');
	  // Remove it after 2 seconds
	  setTimeout(() => el.classList.remove('highlight'), 2000);
	}


    async function deleteTrigger(triggerId) {
        const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}/triggers/${triggerId}`, {
            method: 'DELETE',
            headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + currentUserToken,
                "X-User-Id": currentUserId
            },
            body: JSON.stringify({})
        });
        let result = await response.json();
        if (result?.success) {
            currentTriggers = currentTriggers.filter(item => item._id !== triggerId);
        }
        renderTriggersList();
    }
    async function saveNewTrigger() {
        const type = document.getElementById('triggerType').value;
        let script,
        params = {};
        let triggerName = "";

        if (type === 'starThreshold') {
            const thresholdValue = document.getElementById('starThreshold').value;
            const countValue = document.getElementById('starCount').value;
            const threshold = parseFloat(thresholdValue);
            const count = parseInt(countValue, 10);
            if (!thresholdValue || isNaN(threshold) || threshold <= 0 ||
                !countValue || isNaN(count) || count <= 0) {
                M.toast({
                    html: i18n_local[currentLang].validation_starThreshold,
                    displayLength: 3000
                });
                return;
            }
            params = {
                threshold,
                count
            };
            script = generateStarThresholdScript(params);
            triggerName = i18n_local[currentLang].triggerName_starThreshold
                .replace("{threshold}", threshold)
                .replace("{count}", count);
        } else if (type === 'answerMatch') {
            const targetQuestionSelect = document.getElementById('targetQuestion');
            const targetQuestionValue = targetQuestionSelect.value;
            // Retrieve the displayed question text from the selected option
            const selectedOption = targetQuestionSelect.options[targetQuestionSelect.selectedIndex];
            const selectedQuestionText = selectedOption ? selectedOption.textContent : "Unknown Question";
            const targetAnswerElem = document.getElementById('targetAnswer');
            const selectedAnswers = Array.from(targetAnswerElem.selectedOptions).map(opt => opt.value);
            if (!targetQuestionValue) {
                M.toast({
                    html: i18n_local[currentLang].validation_targetQuestion,
                    displayLength: 3000
                });
                return;
            }
            if (selectedAnswers.length === 0) {
                M.toast({
                    html: i18n_local[currentLang].validation_expectedAnswer,
                    displayLength: 3000
                });
                return;
            }
            params = {
                questionId: targetQuestionValue,
                answer: selectedAnswers
            };
            script = generateAnswerMatchScript(params);
            // Use the question text in the trigger name
            triggerName = i18n_local[currentLang].triggerName_answerMatch
                .replace("{question}", selectedQuestionText)
                .replace("{answers}", selectedAnswers.join(", "));

        }
        else if (type === 'timeBased') {
            // 1. 讀取回溯時間數值
            const timeWindowValue = document.getElementById('timeWindowValue').value;
            // 2. 讀取回溯時間單位（hours 或 days）
            const timeWindowUnit = document.getElementById('timeWindowUnit').value;
            // 3. 讀取要計算統計的題目 ID
            const questionId = document.getElementById('targetQuestionTimeBased').value;
			const questionTitle = document.getElementById('targetQuestionTimeBased').options[questionId].text;
            // 4. 讀取統計方法
            const metric = document.getElementById('metricSelect').value;
            // 5. 讀取比較運算符
            const operator = document.getElementById('operatorSelect').value;
            // 6. 讀取閾值
            const thresholdValue = document.getElementById('thresholdValue').value;

            // 驗證：回溯數值與閾值都須非空、數字、且大於 0；題目、統計方法、運算符需有選定
            const timeWindow = parseInt(timeWindowValue, 10);
            const threshold = parseFloat(thresholdValue);
            if (
                !timeWindowValue || isNaN(timeWindow) || timeWindow <= 0 ||
                !questionId ||
                !metric ||
                !operator ||
                !thresholdValue || isNaN(threshold)) {
                M.toast({
                    html: i18n_local[currentLang].validation_timeBased_detailed,
                    displayLength: 3000
                });
                return;
            }

            // 將「回溯時間」轉成毫秒
            let timeWindowMs = 0;
            if (timeWindowUnit === 'hours') {
                timeWindowMs = timeWindow * 3600 * 1000;
            } else {
                // days
                timeWindowMs = timeWindow * 24 * 3600 * 1000;
            }

            // 組成 params 並呼叫 generateTimeBasedScript
            params = {
                timeWindowMs,
                questionId,
                metric,
                operator,
                threshold
            };
            script = generateTimeBasedScript(params);

            // 依據 i18n 產生一個可讀的 trigger 名稱
            // 假設 i18n_local 裡有 triggerName_timeBased_template 例如：
            // "過去 {timeWindow}{unit}，題目 {questionId} 的 {metric} {operator} {threshold}"
			
			const opKeyMap = {
			    ">": "operatorGreaterThan",
			    ">=": "operatorGreaterEqual",
			    "<": "operatorLessThan",
			    "<=": "operatorLessEqual",
			    "==": "operatorEqual"
			};
			const operatorLabel = i18n_local[currentLang][ opKeyMap[operator] ];
			
            triggerName = i18n_local[currentLang].triggerName_timeBased_template
                .replace('{timeWindow}', timeWindow)
                .replace('{unit}', i18n_local[currentLang][timeWindowUnit + 'Label'])
                .replace('{questionId}', questionId)				
				.replace('{questionTitle}', questionTitle)			
                .replace('{metric}', i18n_local[currentLang]['metric' + metric.charAt(0).toUpperCase() + metric.slice(1) + 'Label'])
                .replace("{operator}", operatorLabel)
                .replace('{threshold}', threshold);
        } else {
            M.toast({
                html: i18n_local[currentLang].validation_invalidTrigger,
                displayLength: 3000
            });
            return;
        }

        // Save the new trigger using the dynamically generated, translated trigger name.
        const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}/triggers`, {
            method: 'POST',
            headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + currentUserToken,
                "X-User-Id": currentUserId
            },
            body: JSON.stringify({
                name: triggerName,
                conditionType: type,
                parameters: params,
                script: script
            })
        });
        currentTriggers = await response.json();
        cancelNewTrigger();
        renderTriggersList();
        // scroll & highlight the one we just added
        const newTrigger = currentTriggers[currentTriggers.length - 1];
        scrollToTrigger(newTrigger._id);
    }

    function showNewTriggerForm() {
        // Hide the triggers list
        document.getElementById("triggersList").classList.add("hideTriggerList");

        // Show the new trigger form
        document.getElementById("newTriggerForm").style.display = "block";

        // Hide the "Add New Trigger" button (assumed to be the blue button in the modal footer)
        const addTriggerBtn = document.querySelector("#eventTriggersModal .modal-footer .btn.blue");
        if (addTriggerBtn) {
            addTriggerBtn.style.display = "none";
        }
    }

    function cancelNewTrigger() {
        // Hide the new trigger form
        document.getElementById("newTriggerForm").style.display = "none";

        // Show the triggers list again
        document.getElementById("triggersList").classList.remove("hideTriggerList");

        // Show back the "Add New Trigger" button
        const addTriggerBtn = document.querySelector("#eventTriggersModal .modal-footer .btn.blue");
        if (addTriggerBtn) {
            addTriggerBtn.style.display = "";

        }

        // ← New: reset the select back to the placeholder
        const typeSelect = document.getElementById('triggerType');
        if (typeSelect) {
            typeSelect.selectedIndex = 0; // go back to “selectTriggerType”
            M.FormSelect.init(typeSelect); // re-initialize Materialize
        }

        // ← New: hide all config panels
        document.querySelectorAll('.trigger-config').forEach(panel => {
            panel.style.display = 'none';
        });
    }

    function generateStarThresholdScript(params) {
        if (currentLang === 'zh-TW') {
            return `
    const threshold = ${params.threshold};
    const requiredCount = ${params.count};

    (function() {
      return async function checkCondition(surveyData) {
        // 篩選出所有星級評分題，其回答低於設定的 threshold
        const lowRatedQuestions = surveyData.data.filter(q => 
          q.questionType === 'stars' && Number(q.answer) < threshold
        );
        if (lowRatedQuestions.length >= requiredCount) {
          // 收集觸發條件的題目文字
          const triggeredQuestions = lowRatedQuestions.map(q => q.question).join('、');
          return \`觸發條件達成：共有 \${lowRatedQuestions.length} 題星級評分題的回答低於 \${threshold} 星。觸發題目：\${triggeredQuestions}。原因：這些題目的評分均低於設定的 \${threshold} 星。\`;
        }
        return null;
      };
    })();
  `;
        } else if (currentLang === 'ja-JP') {
            return `
    const threshold = ${params.threshold};
    const requiredCount = ${params.count};

    (function() {
      return async function checkCondition(surveyData) {
        const lowRatedQuestions = surveyData.data.filter(q => 
          q.questionType === 'stars' && Number(q.answer) < threshold
        );
        if (lowRatedQuestions.length >= requiredCount) {
          const triggeredQuestions = lowRatedQuestions.map(q => q.question).join('、');
          return \`条件が満たされました：\${lowRatedQuestions.length} 件の星評価の質問の回答が \${threshold} 星未満です。対象の質問: \${triggeredQuestions}。理由: これらの質問の評価はすべて設定された \${threshold} 星未満です。\`;
        }
        return null;
      };
    })();
  `;
        } else {
            return `
    const threshold = ${params.threshold};
    const requiredCount = ${params.count};

    (function() {
      return async function checkCondition(surveyData) {
        const lowRatedQuestions = surveyData.data.filter(q => 
          q.questionType === 'stars' && Number(q.answer) < threshold
        );
        if (lowRatedQuestions.length >= requiredCount) {
          const triggeredQuestions = lowRatedQuestions.map(q => q.question).join(', ');
          return \`Condition met: There are \${lowRatedQuestions.length} star rating questions with answers below \${threshold} stars. Triggered questions: \${triggeredQuestions}. Reason: All these questions have ratings below the set threshold of \${threshold} stars.\`;
        }
        return null;
      };
    })();
  `;
        }
    }

    function generateAnswerMatchScript(params) {
        if (currentLang === 'zh-TW') {
            return `
    (function() {
      async function checkCondition(surveyData) {
        // 直接使用傳入的預期答案陣列
        const expectedAnswers = ${JSON.stringify(params.answer)};
        
        // 透過比較 questionId（轉為數字）尋找目標問題
        const targetQuestion = surveyData.data.find(q => q.questionId === Number('${params.questionId}'));
        if (targetQuestion) {
          let answer = targetQuestion.answer;
          // 如果答案不是陣列，則轉換為陣列
          if (!Array.isArray(answer)) {
            answer = [answer];
          }
          
          // 檢查答案中是否有符合任一預期答案
          const matched = expectedAnswers.some(expected => answer.includes(expected));
          if (matched) {
            return \`觸發條件達成：問題「\${targetQuestion.question}」的回答（\${answer.join(', ')}）包含預期選項（\${expectedAnswers.join(', ')}）。原因：該回答符合預期的答案條件。\`;
          }
        }
        return null;
      }
      return checkCondition;
    })();
  `;
        } else if (currentLang === 'ja-JP') {
            return `
    (function() {
      async function checkCondition(surveyData) {
        const expectedAnswers = ${JSON.stringify(params.answer)};
        const targetQuestion = surveyData.data.find(q => q.questionId === Number('${params.questionId}'));
        if (targetQuestion) {
          let answer = targetQuestion.answer;
          if (!Array.isArray(answer)) {
            answer = [answer];
          }
          const matched = expectedAnswers.some(expected => answer.includes(expected));
          if (matched) {
            return \`条件が満たされました：質問「\${targetQuestion.question}」の回答（\${answer.join(', ')}）に、予想される選択肢（\${expectedAnswers.join(', ')}）が含まれています。理由：その回答は期待される条件を満たしています。\`;
          }
        }
        return null;
      }
      return checkCondition;
    })();
  `;
        } else {
            return `
    (function() {
      async function checkCondition(surveyData) {
        const expectedAnswers = ${JSON.stringify(params.answer)};
        const targetQuestion = surveyData.data.find(q => q.questionId === Number('${params.questionId}'));
        if (targetQuestion) {
          let answer = targetQuestion.answer;
          if (!Array.isArray(answer)) {
            answer = [answer];
          }
          const matched = expectedAnswers.some(expected => answer.includes(expected));
          if (matched) {
            return \`Condition met: The answer for question "\${targetQuestion.question}" (\${answer.join(', ')}) contains the expected option(s) (\${expectedAnswers.join(', ')}). Reason: The answer meets the expected criteria.\`;
          }
        }
        return null;
      }
      return checkCondition;
    })();
  `;
        }
    }
	
	
	function generateTimeBasedScript({
	  timeWindowMs,
	  questionId,
	  metric,
	  operator,
	  threshold
	}) {
	  return `
		const TIME_WINDOW = ${timeWindowMs};
		const TARGET_QUESTION_ID = "${questionId}";
		const METRIC = "${metric}";
		const OPERATOR = "${operator}";
		const THRESHOLD = ${threshold};

		(function() {
		  return async function checkCondition(surveyData) {
			// 1. 計算 endTime 與 startTime（以毫秒為單位）
			const endTime = Date.now();
			const startTime = endTime - TIME_WINDOW;

			// 2. 只取回「這個時間範圍內」的歷史填答
			const history = await fetchHistoricalData(startTime, endTime);
			//    （注意：後端 fetchHistoricalData 應對應 signature: fetchHistoricalData(startTime, endTime)）

			// 3. 提取「指定題目」的回答值（只取可轉數字者）
			const values = [];
			let questionTitle = "";
			history.forEach(item => {
			  if (Array.isArray(item.data)) {
				const q = item.data.find(x => x.questionId === Number(TARGET_QUESTION_ID));
				if (q && q.answer != null) {
				  const val = Number(q.answer);
				  questionTitle = q.question;
				  if (!isNaN(val)) {
					values.push(val);
				  }
				}
			  }
			});

			// 4. 如果沒有符合的，就不觸發
			if (values.length === 0) {
			  return null;
			}

			// 5. 根據 METRIC 計算指標
			let computed;
			switch (METRIC) {
			  case "sum":
				computed = values.reduce((acc, v) => acc + v, 0);
				break;
			  case "avg":
				computed = values.reduce((acc, v) => acc + v, 0) / values.length;
				break;
			  case "median":
				values.sort((a, b) => a - b);
				const mid = Math.floor(values.length / 2);
				computed = (values.length % 2 === 0)
				  ? (values[mid - 1] + values[mid]) / 2
				  : values[mid];
				break;
			  case "count":
				computed = values.length;
				break;
			  case "max":
				computed = Math.max(...values);
				break;
			  case "min":
				computed = Math.min(...values);
				break;
			  default:
				return null;
			}

			// 6. 比較 computed 與 THRESHOLD
			let conditionMet = false;
			switch (OPERATOR) {
			  case ">":
				conditionMet = computed > THRESHOLD;
				break;
			  case ">=":
				conditionMet = computed >= THRESHOLD;
				break;
			  case "<":
				conditionMet = computed < THRESHOLD;
				break;
			  case "<=":
				conditionMet = computed <= THRESHOLD;
				break;
			  case "==":
				conditionMet = computed == THRESHOLD;
				break;
			}

			// 7. 如果滿足，就回傳提示文字；否則回傳 null
			if (conditionMet) {
			  // 這裡的字串可依需求改成详细描述
			  return \`觸發條件達成：過去 \${TIME_WINDOW / 3600000} 小時內，題目 「\${questionTitle}」 的 \${METRIC} 為 \${computed}， \${METRIC} \${OPERATOR} \${THRESHOLD}。\`;
			}
			return null;
		  };
		})();
	  `;
	}
		

    function loadTriggerConfig() {
        // Clear previous config
        const configContainer = document.getElementById('triggerConfig');
        configContainer.innerHTML = '';

        // Define configuration panels with descriptions (using i18n_local for the descriptions
        // and i18n_local for field labels)
        const triggerTypes = {
            starThreshold: `
      <div class="row">
        <div class="col s12">
          <p style="font-size: 0.9em; color: #666;">
            ${i18n_local[currentLang].triggerDescription_starThreshold}
          </p>
        </div>
        <div class="input-field col s6">
          <input type="number" id="starThreshold" step="0.1" min="1">
          <label for="starThreshold">${i18n_local[currentLang].starThresholdLabel}</label>
        </div>
        <div class="input-field col s6">
          <input type="number" id="starCount" min="1">
          <label for="starCount">${i18n_local[currentLang].starCountLabel}</label>
        </div>
      </div>
    `,
            answerMatch: `
      <div class="row">
        <div class="col s12">
          <p style="font-size: 0.9em; color: #666;">
            ${i18n_local[currentLang].triggerDescription_answerMatch}
          </p>
        </div>
        <div class="input-field col s6">
          <select id="targetQuestion">
            <!-- Options will be populated via JS -->
          </select>
          <label>${i18n_local[currentLang].targetQuestionLabel}</label>
        </div>
        <div class="input-field col s6">
          <select id="targetAnswer" multiple>
            <!-- Options will be populated via JS -->
          </select>
          <label>${i18n_local[currentLang].expectedAnswerLabel}</label>
        </div>
      </div>
    `,
            timeBased: `
      <div class="row">
        <div class="col s12">
          <p style="font-size: 0.9em; color: #666;">
            ${i18n_local[currentLang].triggerDescription_timeBased}
          </p>
        </div>

        <!-- 1. 回溯時間數值 -->
        <div class="input-field col s4">
          <input type="number" id="timeWindowValue" min="1">
          <label for="timeWindowValue">${i18n_local[currentLang].timeWindowLabel}</label>
        </div>

        <!-- 2. 回溯時間單位（小時／天）-->
        <div class="input-field col s4">
          <select id="timeWindowUnit">
            <option value="hours" selected>${i18n_local[currentLang].hoursLabel}</option>
            <option value="days">${i18n_local[currentLang].daysLabel}</option>
          </select>
          <label>${i18n_local[currentLang].timeWindowUnitLabel}</label>
        </div>

        <!-- 3. 選擇要計算統計的題目 -->
        <div class="input-field col s4">
          <select id="targetQuestionTimeBased">
            <!-- 這裡的選項需由 JS 以 surveyItems 填入所有 questionId -->
          </select>
          <label>${i18n_local[currentLang].targetQuestionLabel}</label>
        </div>

        <!-- 4. 統計方法 -->
        <div class="input-field col s4">
          <select id="metricSelect">
            <option value="sum">${i18n_local[currentLang].metricSumLabel}</option>
            <option value="avg" selected>${i18n_local[currentLang].metricAvgLabel}</option>
            <option value="median">${i18n_local[currentLang].metricMedianLabel}</option>
            <option value="count">${i18n_local[currentLang].metricCountLabel}</option>
            <option value="max">${i18n_local[currentLang].metricMaxLabel}</option>
            <option value="min">${i18n_local[currentLang].metricMinLabel}</option>
          </select>
          <label>${i18n_local[currentLang].metricLabel}</label>
        </div>

        <!-- 5. 比較運算符 -->
        <div class="input-field col s4">
          <select id="operatorSelect">
            <option value=">" selected>&gt; ${i18n_local[currentLang].operatorGreaterThan}</option>
            <option value=">=">&ge; ${i18n_local[currentLang].operatorGreaterEqual}</option>
            <option value="<">&lt; ${i18n_local[currentLang].operatorLessThan}</option>
            <option value="<=">&le; ${i18n_local[currentLang].operatorLessEqual}</option>
            <option value="==">= ${i18n_local[currentLang].operatorEqual}</option>
          </select>
          <label>${i18n_local[currentLang].operatorLabel}</label>
        </div>

        <!-- 6. 閾值輸入 -->
        <div class="input-field col s4">
          <input type="number" id="thresholdValue" step="any">
          <label for="thresholdValue">${i18n_local[currentLang].thresholdLabel}</label>
        </div>
      </div>
    `
        };

        // Create a config panel for each trigger type
        for (const [type, html] of Object.entries(triggerTypes)) {
            const div = document.createElement("div");
            div.className = "trigger-config";
            div.dataset.type = type;
            div.style.display = "none"; // initially hidden; show when trigger type is selected
            div.innerHTML = html;
            configContainer.appendChild(div);
        }

        // Initialize Materialize components for any <select> elements
        M.FormSelect.init(document.querySelectorAll('select'));
        M.updateTextFields();
    }

    // Add this to handle trigger type changes
    document.getElementById('triggerType').addEventListener('change', function () {
        const selectedType = this.value;
        const configPanels = document.querySelectorAll('.trigger-config');
        configPanels.forEach(panel => {
            panel.style.display = panel.dataset.type === selectedType ? 'block' : 'none';
        });
        if (selectedType === 'answerMatch') {
            populateQuestionSelect('targetQuestion');
            // Add listener so that when the selected question changes, the answers get updated
            document.getElementById('targetQuestion').addEventListener('change', populateExpectedAnswerSelect);
        }
		else if (selectedType === 'timeBased') {
			 populateQuestionSelect('targetQuestionTimeBased');
		}

    });

    async function populateQuestionSelect(id) {
        const select = document.getElementById(id);
        select.innerHTML = `<option value="" disabled selected>${i18n_local[currentLang].selectQuestion}</option>`;

        if (!CurrentSurveySchemaId)
            return;

        try {
            const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}`);
            const survey = await response.json();

            survey.surveyItems.forEach(item => {
                if (item.type === 'question') {
                    // 單獨的題目
                    const option = document.createElement('option');
                    option.value = item.id;
                    option.textContent = item.questionText || `Question ${item.id}`;
                    select.appendChild(option);
                } else if (item.type === 'group' && Array.isArray(item.subQuestions)) {
                    // group 本身不做為選項，但把它底下的 subQuestions 加入
                    item.subQuestions.forEach(sub => {
                        if (sub.type === 'question') {
                            const option = document.createElement('option');
                            option.value = sub.id;
                            option.textContent = sub.questionText || `Question ${sub.id}`;
                            select.appendChild(option);
                        }
                    });
                }
            });

            M.FormSelect.init(select);
        } catch (error) {
            console.error('Error loading questions:', error);
            M.toast({
                html: 'Failed to load questions',
                classes: 'red'
            });
        }

        // 當使用者改變題目選擇時，再去更新 expected answers
        select.addEventListener('change', populateExpectedAnswerSelect);
    }


    function populateExpectedAnswerSelectElement(options) {
        const selectElem = document.getElementById('targetAnswer');
        selectElem.innerHTML = '';
        options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt;
            selectElem.appendChild(option);
        });
        M.FormSelect.init(selectElem);
    }

    async function populateExpectedAnswerSelect() {
        const targetQuestionSelect = document.getElementById('targetQuestion');
        const selectedQuestionId = targetQuestionSelect.value;
        if (!selectedQuestionId)
            return;
        try {
            const response = await fetch(`${BASE_URL}/api/survey/${CurrentSurveySchemaId}`);
            const survey = await response.json();
            let question;
            // Search for the matching question (either standalone or in a group)
            survey.surveyItems.forEach(item => {
                if (item.type === 'question' && item.id == selectedQuestionId) {
                    question = item;
                } else if (item.type === 'group' && Array.isArray(item.subQuestions)) {
                    item.subQuestions.forEach(subq => {
                        if (subq.id == selectedQuestionId) {
                            question = subq;
                        }
                    });
                }
            });
            if (question) {
                let options = [];
                if (question.questionType === 'radio' || question.questionType === 'checkbox') {
                    options = (question.options || []).map(opt =>
                        typeof opt === 'object' ? opt.text : opt);
                } else if (question.questionType === 'stars') {
                    const maxStars = question.maxStars || 5;
                    for (let i = 1; i <= maxStars; i++) {
                        options.push(i.toString());
                    }
                }
                populateExpectedAnswerSelectElement(options);
            }
        } catch (error) {
            console.error("Error populating expected answer select:", error);
        }
    }


    /***********************************************
     * VOICE recognition
     ***********************************************/

    // Global variables for voice recognition insertion tracking
    let isListening = false;
    let recognition = null;
    let insertionPoint = null; // The starting index where recognized text is inserted
    let lastInsertedLength = 0; // How many characters of interim text have been inserted
    let keyInserted = false; // Indicate key is inserting, so that the recog result should be skip
    let rec;
    // Helper to create a new SpeechRecognition instance
    function createRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            alert("Speech recognition is not supported in this browser.");
            return null;
        }
        rec = new SpeechRecognition();
        rec.continuous = true; // Keep listening until manually stopped
        rec.interimResults = true; // Get interim (partial) results
        rec.lang = currentLang || 'en-US'; // Adjust as needed

        document.getElementById("start-voice-btn").classList.add("recording-btn");
        // Global variable to track the current interim string
        let currentInterim = "";

        rec.onresult = (event) => {
            const descInput = document.getElementById("survey-description-input");
            if (insertionPoint === null) {
                insertionPoint = descInput.selectionStart;
                lastInsertedLength = 0;
                currentInterim = "";
            }

            // Use only the last result from the event
            let result = event.results[event.results.length - 1];
            let transcript = result[0].transcript;

            //console.log(result);

            // If the result is not final and the new transcript is a partial (i.e. a prefix)
            // of the previously inserted interim, then skip updating the display.
            if (!result.isFinal && currentInterim && (currentInterim.indexOf(transcript) >= 0 || currentInterim.length > transcript.length)) {
                console.log("repeat");
                return;
            }
            if (keyInserted) {
                console.log("interrupt");
                if (result.isFinal) {
                    lastInsertedLength = 0;
                    currentInterim = "";
                }
                return;
            }
            console.log(keyInserted, transcript);

            // Remove the previously inserted interim text from the textarea:
            let currentVal = descInput.value;
            let before = currentVal.substring(0, insertionPoint);
            let after = currentVal.substring(insertionPoint + lastInsertedLength);

            // Insert the new transcript
            descInput.value = before + transcript + after;

            // Move the cursor to the end of the newly inserted text
            const newCursorPos = insertionPoint + transcript.length;
            descInput.setSelectionRange(newCursorPos, newCursorPos);
            descInput.focus();

            // Update lastInsertedLength and currentInterim
            lastInsertedLength = transcript.length;
            currentInterim = transcript;

            // If the result is final, finalize the insertion:
            if (result.isFinal) {
                // Advance the insertion point so that future speech is appended at the end of this text.
                insertionPoint += transcript.length;
                lastInsertedLength = 0;
                currentInterim = "";

                // trigger the button
                // Manually dispatch an "input" event so the listener fires
                const event = new Event("input", {
                    bubbles: true,
                    cancelable: true
                });
                descInput.dispatchEvent(event);
            }
        };
        rec.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            try {
                rec.stop();
            } catch (e) {}
        };
        rec.onend = () => {
            // Reset variables when recognition ends
            isListening = false;
            recognition = null;
            insertionPoint = null;
            lastInsertedLength = 0;
            if (keyInserted) {
                rec.start();
                isListening = true;
                keyInserted = false;
                return;
            }
            document.getElementById("start-voice-btn").innerHTML = '<i class="material-icons">mic</i>';
            document.getElementById("start-voice-btn").classList.remove("recording-btn");
        };
        return rec;
    }

    // Add event listeners to update the insertion point if user manually changes the cursor
    const descInput = document.getElementById("survey-description-input");
    descInput.addEventListener("click", () => {
        if (isListening) {
            insertionPoint = descInput.selectionStart;
            lastInsertedLength = 0;
        }
    });
    descInput.addEventListener("keyup", () => {
        if (isListening) {
            insertionPoint = descInput.selectionStart;
            lastInsertedLength = 0;
            keyInserted = true; // indicate we should break the recognition for 200ms
            rec.stop();
        }
    });

    // Handle voice button clicks
    document.getElementById("start-voice-btn").addEventListener("click", () => {
        if (!isListening) {
            // Start recognition: create a new instance and record the current cursor position
            recognition = createRecognition();
            if (!recognition)
                return;
            insertionPoint = descInput.selectionStart;
            lastInsertedLength = 0;
            try {
                recognition.start();
                isListening = true;
                document.getElementById("start-voice-btn").innerHTML = '<i class="material-icons">mic_off</i>';
            } catch (err) {
                console.error("Error starting speech recognition:", err);
            }
        } else {
            try {
                recognition.stop();
                // onend handler will reset state
            } catch (err) {
                console.error("Error stopping speech recognition:", err);
            }
        }
    });

    // Also stop recognition if the user clicks the "Generate Survey Schema" button
    document.getElementById("generate-survey-schema-btn").addEventListener("click", () => {
        if (isListening && recognition) {
            try {
                recognition.stop();
            } catch (err) {
                console.error("Error stopping speech recognition:", err);
            }
        }
        // Continue with your generate logic here...
    });
	
	
	
	/**************************************
	* Utilities
	***************************************/
	/**
	 * 把 type ≠ 'question' / 'group' 的項目矯正成合法值，
	 * 並遞迴處理 group.subQuestions。
	 *  - arr  : surveyItems  或 group.subQuestions
	 */
	function normalizeSurveyItems(arr) {
	  if (!Array.isArray(arr)) return;

	  const ALLOWED = ['question', 'group'];

	  arr.forEach(item => {
		/* ---------- 修正最外層 type ---------- */
		if (!ALLOWED.includes(item.type)) {
		  // 推論：只要不是 group，就視為「單題」
		  item.type = 'question';

		  // 若 questionType 缺失，可用 heuristics 補上；此處示範 longText
		  item.questionType = item.questionType || 'longText';
		}

		/* ---------- 遞迴修正群組內題目 ---------- */
		if (item.type === 'group' && Array.isArray(item.subQuestions)) {
		  normalizeSurveyItems(item.subQuestions);
		}
	  });
	}


	/* initNextId initial the nextId basing on surveyItems
	*/
	let nextId = 1;
	function initNextId() {
	  let maxId = 0;

	  surveyItems.forEach(item => {
		if (item.type === 'question' && typeof item.id === 'number') {
		  maxId = Math.max(maxId, item.id);
		}
		if (item.type === 'group' && Array.isArray(item.subQuestions)) {
		  item.subQuestions.forEach(sub => {
			if (sub.type === 'question' && typeof sub.id === 'number') {
			  maxId = Math.max(maxId, sub.id);
			}
		  });
		}
	  });

	  // 下一個可用的 ID，就從 maxId + 1 開始
	  nextId = maxId + 1;
	}	
	function getUniqueId() {
	  return nextId++;
	}
	
</script>
  </body>
</html>
